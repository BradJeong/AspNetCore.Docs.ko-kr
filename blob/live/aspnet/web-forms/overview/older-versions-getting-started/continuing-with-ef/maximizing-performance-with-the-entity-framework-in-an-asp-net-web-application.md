---
uid: web-forms/overview/older-versions-getting-started/continuing-with-ef/maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application
title: "Entity framework 4.0 ASP.NET 4 웹 응용 프로그램의 성능을 최대화 | Microsoft Docs"
author: tdykstra
description: "이 자습서 시리즈의 Entity Framework 4.0 자습서 시리즈 시작 하기에 의해 만들어진 Contoso 대학 웹 응용 프로그램 기반으로 합니다. I 중..."
ms.author: aspnetcontent
manager: wpickett
ms.date: 01/26/2011
ms.topic: article
ms.assetid: 4e43455e-dfa1-42db-83cb-c987703f04b5
ms.technology: dotnet-webforms
ms.prod: .net-framework
msc.legacyurl: /web-forms/overview/older-versions-getting-started/continuing-with-ef/maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application
msc.type: authoredcontent
ms.openlocfilehash: 9e257f5061f6bdf14ad0776ff6385fb526d6dcb1
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/10/2017
---
<a name="maximizing-performance-with-the-entity-framework-40-in-an-aspnet-4-web-application"></a><span data-ttu-id="5bf51-104">Entity framework 4.0 ASP.NET 4 웹 응용 프로그램에서 성능 최적화</span><span class="sxs-lookup"><span data-stu-id="5bf51-104">Maximizing Performance with the Entity Framework 4.0 in an ASP.NET 4 Web Application</span></span>
====================
<span data-ttu-id="5bf51-105">으로 [Tom Dykstra](https://github.com/tdykstra)</span><span class="sxs-lookup"><span data-stu-id="5bf51-105">by [Tom Dykstra](https://github.com/tdykstra)</span></span>

> <span data-ttu-id="5bf51-106">에 의해 만들어진 Contoso 대학 웹 응용 프로그램을 기반으로 하는이 자습서 시리즈의 [Entity Framework 4.0이 있는 시작](https://asp.net/entity-framework/tutorials#Getting%20Started) 자습서 시리즈 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-106">This tutorial series builds on the Contoso University web application that is created by the [Getting Started with the Entity Framework 4.0](https://asp.net/entity-framework/tutorials#Getting%20Started) tutorial series.</span></span> <span data-ttu-id="5bf51-107">이전 자습서를 완료 하지 않은 경우이 자습서에 대 한 시작 점으로 하면 [응용 프로그램을 다운로드](https://code.msdn.microsoft.com/ASPNET-Web-Forms-97f8ee9a) 만들어졌을 것입니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-107">If you didn't complete the earlier tutorials, as a starting point for this tutorial you can [download the application](https://code.msdn.microsoft.com/ASPNET-Web-Forms-97f8ee9a) that you would have created.</span></span> <span data-ttu-id="5bf51-108">수도 있습니다 [응용 프로그램을 다운로드](https://code.msdn.microsoft.com/ASPNET-Web-Forms-6c7197aa) 완료 하는 자습서 시리즈에서 만들어진 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-108">You can also [download the application](https://code.msdn.microsoft.com/ASPNET-Web-Forms-6c7197aa) that is created by the complete tutorial series.</span></span> <span data-ttu-id="5bf51-109">이 자습서에 대 한 질문이 있으면에 게시할 수 있습니다는 [ASP.NET Entity Framework 포럼](https://forums.asp.net/1227.aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-109">If you have questions about the tutorials, you can post them to the [ASP.NET Entity Framework forum](https://forums.asp.net/1227.aspx).</span></span>


<span data-ttu-id="5bf51-110">이전 자습서에서 동시성 충돌을 처리 하는 방법을 알아보았습니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-110">In the previous tutorial, you saw how to handle concurrency conflicts.</span></span> <span data-ttu-id="5bf51-111">이 자습서는 Entity Framework를 사용 하 여 ASP.NET 웹 응용 프로그램의 성능 향상을 위한 옵션을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-111">This tutorial shows options for improving the performance of an ASP.NET web application that uses the Entity Framework.</span></span> <span data-ttu-id="5bf51-112">성능을 최대화 하거나 성능 문제를 진단 하기 위한 여러 가지 방법을 설명 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-112">You'll learn several methods for maximizing performance or for diagnosing performance problems.</span></span>

<span data-ttu-id="5bf51-113">다음 섹션에 제시 된 정보는 다양 한 시나리오에서에서 유용 하 게 되려면 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-113">Information presented in the following sections is likely to be useful in a broad variety of scenarios:</span></span>

- <span data-ttu-id="5bf51-114">관련된 데이터를 효율적으로 로드 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-114">Efficiently load related data.</span></span>
- <span data-ttu-id="5bf51-115">뷰 상태를 관리 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-115">Manage view state.</span></span>

<span data-ttu-id="5bf51-116">다음 섹션에 제시 된 정보는 개별 쿼리에 있는 해당 성능 문제가 있는 경우 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-116">Information presented in the following sections might be useful if you have individual queries that present performance problems:</span></span>

- <span data-ttu-id="5bf51-117">사용 하 여 `NoTracking` 병합 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-117">Use the `NoTracking` merge option.</span></span>
- <span data-ttu-id="5bf51-118">LINQ 쿼리를 미리 컴파일하십시오.</span><span class="sxs-lookup"><span data-stu-id="5bf51-118">Pre-compile LINQ queries.</span></span>
- <span data-ttu-id="5bf51-119">데이터베이스에 전송 되는 쿼리 명령을 검토 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-119">Examine query commands sent to the database.</span></span>

<span data-ttu-id="5bf51-120">다음 섹션에 제시 된 정보는 매우 큰 데이터 모델에 있는 응용 프로그램에 대 한 잠재적으로 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-120">Information presented in the following section is potentially useful for applications that have extremely large data models:</span></span>

- <span data-ttu-id="5bf51-121">미리 보기를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-121">Pre-generate views.</span></span>

> [!NOTE]
> <span data-ttu-id="5bf51-122">웹 응용 프로그램 성능은 요청 및 응답 데이터의 크기, 데이터베이스 쿼리, 몇 개의 요청 서버 큐에 대기 수 및 속도, 및의 효율성도 서비스할 수의 속도 등을 포함 하 여 다양 한 요인의 영향 클라이언트 스크립트 라이브러리를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-122">Web application performance is affected by many factors, including things like the size of request and response data, the speed of database queries, how many requests the server can queue and how quickly it can service them, and even the efficiency of any client-script libraries you might be using.</span></span> <span data-ttu-id="5bf51-123">성능이 응용 프로그램에서 중요 한 경우 하거나 테스트 또는 환경 표시 되는 응용 프로그램 성능 없습니다 만족 스러운 성능 조정에 대 한 일반 프로토콜을 따라야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-123">If performance is critical in your application, or if testing or experience shows that application performance isn't satisfactory, you should follow normal protocol for performance tuning.</span></span> <span data-ttu-id="5bf51-124">성능 병목 현상이 발생 하는 위치를 확인 하 고 전반적인 응용 프로그램 성능에 가장 큰 영향을 미칠 수 있는 영역을 해결.</span><span class="sxs-lookup"><span data-stu-id="5bf51-124">Measure to determine where performance bottlenecks are occurring, and then address the areas that will have the greatest impact on overall application performance.</span></span>
> 
> <span data-ttu-id="5bf51-125">이 항목에서는 주로 구체적으로 ASP.NET의 Entity Framework의 성능을 잠재적으로 향상 수 있는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-125">This topic focuses mainly on ways in which you can potentially improve the performance specifically of the Entity Framework in ASP.NET.</span></span> <span data-ttu-id="5bf51-126">여기에 제안 사항은 데이터 액세스 응용 프로그램에서 성능 병목 지점 중 하나 인지 확인 한 경우에 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-126">The suggestions here are useful if you determine that data access is one of the performance bottlenecks in your application.</span></span> <span data-ttu-id="5bf51-127">여기에서 설명한 방법으로 간주 해서는 안 언급 했 듯이 점을 제외 하 고 &quot;모범 사례&quot; 일반적-중 대부분이 예외적인 경우에만 또는 성능 병목 현상의 매우 구체적인 종류 주소에 해당 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-127">Except as noted, the methods explained here shouldn't be considered &quot;best practices&quot; in general — many of them are appropriate only in exceptional situations or to address very specific kinds of performance bottlenecks.</span></span>


<span data-ttu-id="5bf51-128">이 자습서를 시작 하려면 Visual Studio를 시작 하 고 이전 자습서에서 작업 하는 Contoso 대학 웹 응용 프로그램을 엽니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-128">To start the tutorial, start Visual Studio and open the Contoso University web application that you were working with in the previous tutorial.</span></span>

## <a name="efficiently-loading-related-data"></a><span data-ttu-id="5bf51-129">관련된 데이터를 효율적으로 로드</span><span class="sxs-lookup"><span data-stu-id="5bf51-129">Efficiently Loading Related Data</span></span>

<span data-ttu-id="5bf51-130">여러 가지 방법으로 Entity Framework가 엔터티의 탐색 속성에 관련된 데이터를 로드할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-130">There are several ways that the Entity Framework can load related data into the navigation properties of an entity:</span></span>

- <span data-ttu-id="5bf51-131">*지연 로드*합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-131">*Lazy loading*.</span></span> <span data-ttu-id="5bf51-132">먼저 엔터티를 읽으면 관련된 데이터가 검색 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-132">When the entity is first read, related data isn't retrieved.</span></span> <span data-ttu-id="5bf51-133">그러나는 탐색 속성에 액세스 하려고 처음으로 해당 탐색 속성에 필요한 데이터가 자동으로 검색 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-133">However, the first time you attempt to access a navigation property, the data required for that navigation property is automatically retrieved.</span></span> <span data-ttu-id="5bf51-134">이 인해 데이터베이스에 전송 하는 여러 개의 쿼리-엔터티 자체에 대 한 개와 때마다 관련 엔터티에 대 한 데이터를 검색 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-134">This results in multiple queries sent to the database — one for the entity itself and one each time that related data for the entity must be retrieved.</span></span> 

    <span data-ttu-id="5bf51-135">[![Image05](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image2.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image1.png)</span><span class="sxs-lookup"><span data-stu-id="5bf51-135">[![Image05](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image2.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image1.png)</span></span>

<span data-ttu-id="5bf51-136">*즉시 로드*합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-136">*Eager loading*.</span></span> <span data-ttu-id="5bf51-137">엔터티를 읽을 때 함께 관련된 데이터가 검색 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-137">When the entity is read, related data is retrieved along with it.</span></span> <span data-ttu-id="5bf51-138">일반적으로 필요한 데이터를 모두 검색 하는 단일 조인 쿼리에서 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-138">This typically results in a single join query that retrieves all of the data that's needed.</span></span> <span data-ttu-id="5bf51-139">즉시 로드를 사용 하 여 지정 된 `Include` 메서드를 때를 살펴 보았으며 이미이 자습서에 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-139">You specify eager loading by using the `Include` method, as you've seen already in these tutorials.</span></span>

<span data-ttu-id="5bf51-140">[![Image07](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image4.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image3.png)</span><span class="sxs-lookup"><span data-stu-id="5bf51-140">[![Image07](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image4.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image3.png)</span></span>

- <span data-ttu-id="5bf51-141">*명시적 로드*합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-141">*Explicit loading*.</span></span> <span data-ttu-id="5bf51-142">이 지연 로드를 제외 하 코드에서 관련된 데이터를 명시적으로 검색 탐색 속성에 액세스할 때 자동으로 발생 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-142">This is similar to lazy loading, except that you explicitly retrieve the related data in code; it doesn't happen automatically when you access a navigation property.</span></span> <span data-ttu-id="5bf51-143">관련된 데이터를 사용 하 여 수동으로 부하는 `Load` 컬렉션 또는 사용자에 대 한 탐색 속성의 메서드를 사용 하 여는 `Load` reference 속성의 단일 개체를 포함 하는 속성에 대 한 메서드.</span><span class="sxs-lookup"><span data-stu-id="5bf51-143">You load related data manually using the `Load` method of the navigation property for collections, or you use the `Load` method of the reference property for properties that hold a single object.</span></span> <span data-ttu-id="5bf51-144">(호출 하는 예를 들어는 `PersonReference.Load` 개체에 대 한는 `Person` 의 탐색 속성을 `Department` 엔터티.)</span><span class="sxs-lookup"><span data-stu-id="5bf51-144">(For example, you call the `PersonReference.Load` method to load the `Person` navigation property of a `Department` entity.)</span></span>

    <span data-ttu-id="5bf51-145">[![Image06](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image6.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image5.png)</span><span class="sxs-lookup"><span data-stu-id="5bf51-145">[![Image06](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image6.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image5.png)</span></span>

<span data-ttu-id="5bf51-146">속성 값을 즉시 검색 하지 않으므로 지연 로드 및 명시적 로딩 둘 다 라고도 *지연 된 로드*합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-146">Because they don't immediately retrieve the property values, lazy loading and explicit loading are also both known as *deferred loading*.</span></span>

<span data-ttu-id="5bf51-147">지연 로드는 디자이너에서 생성 된 개체 컨텍스트에 대 한 기본 동작입니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-147">Lazy loading is the default behavior for an object context that has been generated by the designer.</span></span> <span data-ttu-id="5bf51-148">여는 경우는 *SchoolModel.Designer.cs* 파일 개체 컨텍스트 클래스를 정의 하는, 세 가지 생성자 메서드를 찾을 수 있습니다 및 다음 문은 각각의 포함:</span><span class="sxs-lookup"><span data-stu-id="5bf51-148">If you open the *SchoolModel.Designer.cs* file that defines the object context class, you'll find three constructor methods, and each of them includes the following statement:</span></span>

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample1.cs)]

<span data-ttu-id="5bf51-149">일반적으로 알고 있는 경우 관련 된 데이터에 필요한 모든 엔터티 검색, 신속 하 게 로드 최상의 성능을 제공 데이터베이스에 전송 하는 단일 쿼리를 검색할 각 엔터티에 대 한 별개의 쿼리와 보다 일반적으로 더 효율적 이므로 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-149">In general, if you know you need related data for every entity retrieved, eager loading offers the best performance, because a single query sent to the database is typically more efficient than separate queries for each entity retrieved.</span></span> <span data-ttu-id="5bf51-150">반면, 자주 엔터티의 탐색 속성에 액세스 해야 할 경우에 대해서만 또는 작은 즉시 로드 필요한 것 보다 더 많은 데이터를 검색 하기 때문에 엔터티, 지연 로드 또는 명시적 로드 집합을 보다 효율적 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-150">On the other hand, if you need to access an entity's navigation properties only infrequently or only for a small set of the entities, lazy loading or explicit loading may be more efficient, because eager loading would retrieve more data than you need.</span></span>

<span data-ttu-id="5bf51-151">웹 응용 프로그램에서 한 지연 로딩이 때문일 상대적으로 작은 값의 누르고, 페이지를 렌더링 하는 개체 컨텍스트에 연결 되지 브라우저에서 관련된 데이터에 대 한 필요성에 영향을 주는 사용자 작업이 수행입니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-151">In a web application, lazy loading may be of relatively little value anyway, because user actions that affect the need for related data take place in the browser, which has no connection to the object context that rendered the page.</span></span> <span data-ttu-id="5bf51-152">반면에 컨트롤 databind 알고 있는 경우 일반적으로 필요한을 즉시 로드 또는 지연 된 로드에 따라 선택할 수 있으므로 일반적으로 최상의 데이터 란 각 시나리오에 적합 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-152">On the other hand, when you databind a control, you typically know what data you need, and so it's generally best to choose eager loading or deferred loading based on what's appropriate in each scenario.</span></span>

<span data-ttu-id="5bf51-153">또한 데이터 바인딩된 컨트롤 개체 컨텍스트를 삭제 한 후 엔터티 개체를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-153">In addition, a databound control might use an entity object after the object context is disposed.</span></span> <span data-ttu-id="5bf51-154">이 경우에 탐색 속성 지연 로드 하려는 시도가 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-154">In that case, an attempt to lazy-load a navigation property would fail.</span></span> <span data-ttu-id="5bf51-155">나타나는 오류 메시지는 명확.&quot;`The ObjectContext instance has been disposed and can no longer be used for operations that require a connection.`&quot;</span><span class="sxs-lookup"><span data-stu-id="5bf51-155">The error message you receive is clear: &quot;`The ObjectContext instance has been disposed and can no longer be used for operations that require a connection.`&quot;</span></span>

<span data-ttu-id="5bf51-156">`EntityDataSource` 컨트롤 기본적으로 지연 로딩을 사용 하지 않도록 설정 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-156">The `EntityDataSource` control disables lazy loading by default.</span></span> <span data-ttu-id="5bf51-157">에 대 한는 `ObjectDataSource` 컨트롤 현재 자습서에 사용 하는 (또는 개체 컨텍스트에 페이지 코드에서 액세스 하는 경우), 여러 가지 방법으로 지연 가능 로딩을 기본적으로 비활성화 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-157">For the `ObjectDataSource` control that you're using for the current tutorial (or if you access the object context from page code), there are several ways you can make lazy loading disabled by default.</span></span> <span data-ttu-id="5bf51-158">개체 컨텍스트에 인스턴스화할 때 해제할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-158">You can disable it when you instantiate an object context.</span></span> <span data-ttu-id="5bf51-159">예를 들어 다음 줄의 생성자 메서드를 추가할 수 있습니다는 `SchoolRepository` 클래스:</span><span class="sxs-lookup"><span data-stu-id="5bf51-159">For example, you can add the following line to the constructor method of the `SchoolRepository` class:</span></span>

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample2.cs)]

<span data-ttu-id="5bf51-160">Contoso 대학 응용 프로그램에 대 한 개체 컨텍스트에 자동으로이 속성 컨텍스트 인스턴스화될 때마다 설정 하지 않아도 되도록 지연 로드를 사용 하지 않도록 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-160">For the Contoso University application, you'll make the object context automatically disable lazy loading so that this property doesn't have to be set whenever a context is instantiated.</span></span>

<span data-ttu-id="5bf51-161">열기는 *SchoolModel.edmx* 데이터 모델을 디자인 화면을 클릭 한 다음 속성 창에서 설정 된 **지연 로드 사용** 속성을 `False`합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-161">Open the *SchoolModel.edmx* data model, click the design surface, and then in the properties pane set the **Lazy Loading Enabled** property to `False`.</span></span> <span data-ttu-id="5bf51-162">저장 하 고 데이터 모델을 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-162">Save and close the data model.</span></span>

<span data-ttu-id="5bf51-163">[![Image04](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image8.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="5bf51-163">[![Image04](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image8.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image7.png)</span></span>

## <a name="managing-view-state"></a><span data-ttu-id="5bf51-164">뷰 상태를 관리합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-164">Managing View State</span></span>

<span data-ttu-id="5bf51-165">업데이트 기능을 제공 하기 위해 ASP.NET 웹 페이지는 페이지가 렌더링 될 때 엔터티 원래 속성 값을 저장 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-165">In order to provide update functionality, an ASP.NET web page must store the original property values of an entity when a page is rendered.</span></span> <span data-ttu-id="5bf51-166">포스트백 컨트롤을 처리 하는 동안 다시 엔터티의 원래 상태로 만들고 수 엔터티의 호출 `Attach` 메서드를 호출 하 고 변경 내용을 적용 하기 전에 `SaveChanges` 메서드.</span><span class="sxs-lookup"><span data-stu-id="5bf51-166">During postback processing the control can re-create the original state of the entity and call the entity's `Attach` method before applying changes and calling the `SaveChanges` method.</span></span> <span data-ttu-id="5bf51-167">기본적으로 ASP.NET Web Forms 데이터 컨트롤 뷰 상태를 사용 하 여 원래 값을 저장 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-167">By default, ASP.NET Web Forms data controls use view state to store the original values.</span></span> <span data-ttu-id="5bf51-168">그러나 뷰 상태 브라우저에서 보내고 있는 페이지의 크기를 크게 높일 수 있는 숨겨진된 필드에 저장 되므로 성능에 영향을 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-168">However, view state can affect performance, because it's stored in hidden fields that can substantially increase the size of the page that's sent to and from the browser.</span></span>

<span data-ttu-id="5bf51-169">보기 상태나 세션 상태 등의 대체 기능을 관리 하기 위한 기술이 되므로이 자습서를 자세히가이 항목으로 이동 하지 않습니다 Entity Framework에 고유 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-169">Techniques for managing view state, or alternatives such as session state, aren't unique to the Entity Framework, so this tutorial doesn't go into this topic in detail.</span></span> <span data-ttu-id="5bf51-170">자세한 내용은 자습서의 끝에 링크를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-170">For more information see the links at the end of the tutorial.</span></span>

<span data-ttu-id="5bf51-171">버전 4의 ASP.NET Web Forms 응용 프로그램의 모든 ASP.NET 개발자가 알아야 할 뷰 상태와 함께 작업 하는 새로운 방식으로 제공 하는 반면:는 `ViewStateMode` 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-171">However, version 4 of ASP.NET provides a new way of working with view state that every ASP.NET developer of Web Forms applications should be aware of: the `ViewStateMode` property.</span></span> <span data-ttu-id="5bf51-172">이 새 속성 페이지 또는 제어 수준에서 설정할 수 있습니다 및 페이지에 대해 기본적으로 상태 보기를 사용 하지 않도록 설정 하 고 필요로 하는 컨트롤에 대해서만 사용 하도록 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-172">This new property can be set at the page or control level, and it enables you to disable view state by default for a page and enable it only for controls that need it.</span></span>

<span data-ttu-id="5bf51-173">응용 프로그램의 성능 상태가 심각 경우 항상 페이지 수준에서 뷰 상태를 사용 하지 않도록 설정 하 고 필요로 하는 컨트롤에 대해서만 사용 하도록 설정 하는 좋은 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-173">For applications where performance is critical, a good practice is to always disable view state at the page level and enable it only for controls that require it.</span></span> <span data-ttu-id="5bf51-174">Contoso 대학 페이지에 대 한 뷰 상태의 크기는이 메서드에 의해 상당히 줄일 수 없게 되지만 작동 방식을 보려면 합니다 것에 대 한는 *Instructors.aspx* 페이지.</span><span class="sxs-lookup"><span data-stu-id="5bf51-174">The size of view state in the Contoso University pages wouldn't be substantially decreased by this method, but to see how it works, you'll do it for the *Instructors.aspx* page.</span></span> <span data-ttu-id="5bf51-175">다양 한 컨트롤을 포함 하 여 해당 페이지에 포함 되어는 `Label` 컨트롤을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-175">That page contains many controls, including a `Label` control that has view state disabled.</span></span> <span data-ttu-id="5bf51-176">이 페이지에 있는 컨트롤의 없음 실제로 필요 보기 상태에서 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-176">None of the controls on this page actually need to have view state enabled.</span></span> <span data-ttu-id="5bf51-177">(의 `DataKeyNames` 속성은 `GridView` 다시 게시 간에 유지 해야 하는 상태를 지정 하는 제어 하지만 이러한 값에 영향을 받지 않습니다 컨트롤 상태를 유지 됩니다는 `ViewStateMode` 속성입니다.)</span><span class="sxs-lookup"><span data-stu-id="5bf51-177">(The `DataKeyNames` property of the `GridView` control specifies state that must be maintained between postbacks, but these values are kept in control state, which isn't affected by the `ViewStateMode` property.)</span></span>

<span data-ttu-id="5bf51-178">`Page` 지시문 및 `Label` 컨트롤 태그에는 현재 다음 예제와 유사 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-178">The `Page` directive and `Label` control markup currently resembles the following example:</span></span>

[!code-aspx[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample3.aspx)]

<span data-ttu-id="5bf51-179">다음과 같이 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-179">Make the following changes:</span></span>

- <span data-ttu-id="5bf51-180">추가 `ViewStateMode="Disabled"` 에 `Page` 지시문입니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-180">Add `ViewStateMode="Disabled"` to the `Page` directive.</span></span>
- <span data-ttu-id="5bf51-181">제거 `ViewStateMode="Disabled"` 에서 `Label` 제어 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-181">Remove `ViewStateMode="Disabled"` from the `Label` control.</span></span>

<span data-ttu-id="5bf51-182">태그에는 이제 다음 예제를 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-182">The markup now resembles the following example:</span></span>

[!code-aspx[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample4.aspx)]

<span data-ttu-id="5bf51-183">모든 컨트롤에 대 한 현재 뷰 상태 비활성화 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-183">View state is now disabled for all controls.</span></span> <span data-ttu-id="5bf51-184">포함은 하기만 하면 나중에 뷰 상태를 사용 해야 하는 컨트롤을 추가 하는 경우는 `ViewStateMode="Enabled"` 해당 컨트롤에 대 한 특성입니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-184">If you later add a control that does need to use view state, all you need to do is include the `ViewStateMode="Enabled"` attribute for that control.</span></span>

## <a name="using-the-notracking-merge-option"></a><span data-ttu-id="5bf51-185">NoTracking 병합 옵션을 사용 하 여</span><span class="sxs-lookup"><span data-stu-id="5bf51-185">Using The NoTracking Merge Option</span></span>

<span data-ttu-id="5bf51-186">개체 컨텍스트에 데이터베이스 행을 검색 하 고을 나타내는 엔터티 개체를 만드는 경우 기본적으로도 추적의 개체 상태 관리자를 사용 하 여 해당 엔터티 개체입니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-186">When an object context retrieves database rows and creates entity objects that represent them, by default it also tracks those entity objects using its object state manager.</span></span> <span data-ttu-id="5bf51-187">이 추적 데이터는 한 캐시 역할을 하 고 엔터티를 업데이트할 때 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-187">This tracking data acts as a cache and is used when you update an entity.</span></span> <span data-ttu-id="5bf51-188">일반적으로 웹 응용 프로그램의 수명이 짧은 개체 컨텍스트 인스턴스가 때문에 쿼리 보통 개체 컨텍스트를 읽어옵니다를 읽어 온 엔터티는 다시 사용 전에 삭제 되는지 때문에 추적 되어야 필요 없는 데이터를 반환 합니다. 또는 업데이트 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-188">Because a web application typically has short-lived object context instances, queries often return data that doesn't need to be tracked, because the object context that reads them will be disposed before any of the entities it reads are used again or updated.</span></span>

<span data-ttu-id="5bf51-189">Entity Framework에서 지정할 수 있습니다 개체 컨텍스트를 설정 하 여 엔터티 개체를 추적 하는지 여부를 *병합 옵션*합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-189">In the Entity Framework, you can specify whether the object context tracks entity objects by setting a *merge option*.</span></span> <span data-ttu-id="5bf51-190">개별 쿼리에 대 한 또는 엔터티 집합에 대 한 병합 옵션을 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-190">You can set the merge option for individual queries or for entity sets.</span></span> <span data-ttu-id="5bf51-191">엔터티 집합에 대해 설정한 경우 해당 엔터티 집합에 대해 생성 된 모든 쿼리에 대 한 기본 병합 옵션을 설정 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-191">If you set it for an entity set, that means that you're setting the default merge option for all queries that are created for that entity set.</span></span>

<span data-ttu-id="5bf51-192">Contoso 대학 응용 프로그램에 대 한 추적 병합 옵션을 설정할 수 있는 저장소에서 액세스 하는 엔터티 집합에 대 한 필요 하지 않습니다 `NoTracking` 개체 컨텍스트 저장소 클래스를 인스턴스화할 때 해당 엔터티 집합에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-192">For the Contoso University application, tracking isn't needed for any of the entity sets that you access from the repository, so you can set the merge option to `NoTracking` for those entity sets when you instantiate the object context in the repository class.</span></span> <span data-ttu-id="5bf51-193">(참고는이 자습서에서는 병합 옵션을 설정 하지 않습니다 필요 응용 프로그램의 성능에 별다른 영향입니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-193">(Note that in this tutorial, setting the merge option won't have a noticeable effect on the application's performance.</span></span> <span data-ttu-id="5bf51-194">`NoTracking` 옵션은 특정 데이터 대량 시나리오에만 예측 가능한 성능 향상 가능성이 있습니다.)</span><span class="sxs-lookup"><span data-stu-id="5bf51-194">The `NoTracking` option is likely to make an observable performance improvement only in certain high-data-volume scenarios.)</span></span>

<span data-ttu-id="5bf51-195">DAL 폴더를 열고는 *SchoolRepository.cs* 파일을 저장소에서 액세스 하는 엔터티 집합에 대 한 병합 옵션을 설정 하는 생성자 메서드를 추가 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-195">In the DAL folder, open the *SchoolRepository.cs* file and add a constructor method that sets the merge option for the entity sets that the repository accesses:</span></span>

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample5.cs)]

## <a name="pre-compiling-linq-queries"></a><span data-ttu-id="5bf51-196">미리 컴파일 LINQ 쿼리</span><span class="sxs-lookup"><span data-stu-id="5bf51-196">Pre-Compiling LINQ Queries</span></span>

<span data-ttu-id="5bf51-197">Entity Framework의 수명 내에서 Entity SQL 쿼리를 실행 하는 처음으로 주어진 `ObjectContext` 인스턴스의 시간이 걸리는 쿼리를 컴파일하는 데 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-197">The first time that the Entity Framework executes an Entity SQL query within the life of a given `ObjectContext` instance, it takes some time to compile the query.</span></span> <span data-ttu-id="5bf51-198">쿼리의 후속 실행 속도가 훨씬 빨라집니다 됨을 의미 하는 컴파일 결과 캐시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-198">The result of compilation is cached, which means that subsequent executions of the query are much quicker.</span></span> <span data-ttu-id="5bf51-199">LINQ 쿼리 제외 하 고 쿼리를 컴파일하는 데 필요한 작업의 일부 완료 때마다 쿼리가 실행 되는 유사한 패턴을 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-199">LINQ queries follow a similar pattern, except that some of the work required to compile the query is done every time the query is executed.</span></span> <span data-ttu-id="5bf51-200">즉, LINQ 쿼리에 대해 기본적으로 모든 컴파일 결과를 캐시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-200">In other words, for LINQ queries, by default not all of the results of compilation are cached.</span></span>

<span data-ttu-id="5bf51-201">개체 컨텍스트에의 수명에서 반복적으로 실행 해야 하는 LINQ 쿼리를 사용 하도록 설정한 경우 모든 LINQ 쿼리를 실행 하는 처음으로 캐시 되도록 컴파일 결과 발생 시키는 코드를 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-201">If you have a LINQ query that you expect to run repeatedly in the life of an object context, you can write code that causes all of the results of compilation to be cached the first time the LINQ query is run.</span></span>

<span data-ttu-id="5bf51-202">그림과 같이 작업 2에 대 한 `Get` 의 메서드는 `SchoolRepository` 클래스 중 하나는 매개 변수를 사용 하지 않습니다 (의 `GetInstructorNames` 메서드)에 매개 변수가 필요 하 고 다른 하나 (의 `GetDepartmentsByAdministrator` 메서드).</span><span class="sxs-lookup"><span data-stu-id="5bf51-202">As an illustration, you'll do this for two `Get` methods in the `SchoolRepository` class, one of which doesn't take any parameters (the `GetInstructorNames` method), and one that does require a parameter (the `GetDepartmentsByAdministrator` method).</span></span> <span data-ttu-id="5bf51-203">이러한 방법으로 서식을 이제 실제로 필요가 없습니다 LINQ 쿼리 수 없기 때문에 컴파일할 수 없습니다:</span><span class="sxs-lookup"><span data-stu-id="5bf51-203">These methods as they stand now actually don't need to be compiled because they aren't LINQ queries:</span></span>

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample6.cs)]

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample7.cs)]

<span data-ttu-id="5bf51-204">그러나 있으므로 진행 하는 컴파일된 쿼리를 수행 하려면 합니다 다음 LINQ 쿼리도 기록 된 이러한 하는 경우:</span><span class="sxs-lookup"><span data-stu-id="5bf51-204">However, so that you can try out compiled queries, you'll proceed as if these had been written as the following LINQ queries:</span></span>

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample8.cs)]

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample9.cs)]

<span data-ttu-id="5bf51-205">위에 표시 된 개이고 계속 하기 전에 작동 하는지 확인 하려면 응용 프로그램 실행 작업으로 이러한 메서드의 코드를 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-205">You could change the code in these methods to what's shown above and run the application to verify that it works before continuing.</span></span> <span data-ttu-id="5bf51-206">하지만 다음 지침에 미리 컴파일된 버전을 만드는 바로 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-206">But the following instructions jump right into creating pre-compiled versions of them.</span></span>

<span data-ttu-id="5bf51-207">클래스 파일을 만듭니다는 *DAL* 폴더를 이름을 *SchoolEntities.cs*, 기존 코드를 다음 코드로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-207">Create a class file in the *DAL* folder, name it *SchoolEntities.cs*, and replace the existing code with the following code:</span></span>

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample10.cs)]

<span data-ttu-id="5bf51-208">이 코드는 자동으로 생성 된 개체 컨텍스트 클래스를 확장 하는 partial 클래스를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-208">This code creates a partial class that extends the automatically generated object context class.</span></span> <span data-ttu-id="5bf51-209">사용 하 여 두 개의 컴파일된 LINQ 쿼리를 포함 하는 partial 클래스는 `Compile` 의 메서드는 `CompiledQuery` 클래스입니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-209">The partial class includes two compiled LINQ queries using the `Compile` method of the `CompiledQuery` class.</span></span> <span data-ttu-id="5bf51-210">또한 쿼리를 호출 하는 데 사용할 수 있는 메서드를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-210">It also creates methods that you can use to call the queries.</span></span> <span data-ttu-id="5bf51-211">저장 하 고이 파일을 닫습니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-211">Save and close this file.</span></span>

<span data-ttu-id="5bf51-212">다음 *SchoolRepository.cs*, 기존 변경 `GetInstructorNames` 및 `GetDepartmentsByAdministrator` 저장소의 메서드는 컴파일된 쿼리를 호출할 수 있도록 클래스:</span><span class="sxs-lookup"><span data-stu-id="5bf51-212">Next, in *SchoolRepository.cs*, change the existing `GetInstructorNames` and `GetDepartmentsByAdministrator` methods in the repository class so that they call the compiled queries:</span></span>

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample11.cs)]

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample12.cs)]

<span data-ttu-id="5bf51-213">실행 된 *Departments.aspx* 페이지 이전과 같이 작동 하는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-213">Run the *Departments.aspx* page to verify that it works as it did before.</span></span> <span data-ttu-id="5bf51-214">`GetInstructorNames` 관리자 드롭 다운 목록 채우기 위해 메서드를 호출 및 `GetDepartmentsByAdministrator` 클릭 하면 메서드는 **업데이트** 없는 강사 둘 이상의의 관리자 인지 확인 하려면 부서입니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-214">The `GetInstructorNames` method is called in order to populate the administrator drop-down list, and the `GetDepartmentsByAdministrator` method is called when you click **Update** in order to verify that no instructor is an administrator of more than one department.</span></span>

<span data-ttu-id="5bf51-215">[![Image03](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image10.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image9.png)</span><span class="sxs-lookup"><span data-stu-id="5bf51-215">[![Image03](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image10.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image9.png)</span></span>

<span data-ttu-id="5bf51-216">미리 컴파일된 쿼리 성능이 눈에 띄게 향상 시키는 때문이 아니라, 수행 하는 방법을 참조에 Contoso 대학 응용 프로그램에서 했습니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-216">You've pre-compiled queries in the Contoso University application only to see how to do it, not because it would measurably improve performance.</span></span> <span data-ttu-id="5bf51-217">LINQ 쿼리를 미리 컴파일 코드에 간단한 수준을 제시 추가할가, 실제로 응용 프로그램에서 성능 병목 상태를 표현 하는 쿼리에 대해서만 수행 해야.</span><span class="sxs-lookup"><span data-stu-id="5bf51-217">Pre-compiling LINQ queries does add a level of complexity to your code, so make sure you do it only for queries that actually represent performance bottlenecks in your application.</span></span>

## <a name="examining-queries-sent-to-the-database"></a><span data-ttu-id="5bf51-218">데이터베이스에 전송 하는 쿼리</span><span class="sxs-lookup"><span data-stu-id="5bf51-218">Examining Queries Sent to the Database</span></span>

<span data-ttu-id="5bf51-219">때 성능 문제를 조사 하는 것이 유용한 경우도 Entity Framework 데이터베이스에 전송 하는 정확한 SQL 명령에 알아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-219">When you're investigating performance issues, sometimes it's helpful to know the exact SQL commands that the Entity Framework is sending to the database.</span></span> <span data-ttu-id="5bf51-220">작업 하는 경우는 `IQueryable` 개체를 사용 하는 것이 작업을 수행 하는 한 가지 방법은 `ToTraceString` 메서드.</span><span class="sxs-lookup"><span data-stu-id="5bf51-220">If you're working with an `IQueryable` object, one way to do this is to use the `ToTraceString` method.</span></span>

<span data-ttu-id="5bf51-221">*SchoolRepository.cs*의 코드 변경의 `GetDepartmentsByName` 다음 예제와 일치 하도록 메서드:</span><span class="sxs-lookup"><span data-stu-id="5bf51-221">In *SchoolRepository.cs*, change the code in the `GetDepartmentsByName` method to match the following example:</span></span>

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample13.cs)]

<span data-ttu-id="5bf51-222">`departments` 변수도 캐스팅 되어야 합니다는 `ObjectQuery` 때문에 입력는 `Where` 앞 줄의 끝에 메서드를 만듭니다는 `IQueryable` 개체 없이 `Where` 메서드를 캐스팅 필요 하지 않을 것입니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-222">The `departments` variable must be cast to an `ObjectQuery` type only because the `Where` method at the end of the preceding line creates an `IQueryable` object; without the `Where` method, the cast would not be necessary.</span></span>

<span data-ttu-id="5bf51-223">에 중단점을 설정의 `return` 줄을 실행 한 다음는 *Departments.aspx* 디버거에서 페이지입니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-223">Set a breakpoint on the `return` line, and then run the *Departments.aspx* page in the debugger.</span></span> <span data-ttu-id="5bf51-224">중단점에 도달 하면 검사는 `commandText` 에서 변수는 **지역** 창과 텍스트 시각화 도우미를 사용 하 여 (에 돋보기는 **값** 열)는 에해당값을표시**텍스트 시각화 도우미** 창.</span><span class="sxs-lookup"><span data-stu-id="5bf51-224">When you hit the breakpoint, examine the `commandText` variable in the **Locals** window and use the text visualizer (the magnifying glass in the **Value** column) to display its value in the **Text Visualizer** window.</span></span> <span data-ttu-id="5bf51-225">이 코드에서 생성 된 전체 SQL 명령으로 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-225">You can see the entire SQL command that results from this code:</span></span>

<span data-ttu-id="5bf51-226">[![Image08](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image12.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image11.png)</span><span class="sxs-lookup"><span data-stu-id="5bf51-226">[![Image08](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image12.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image11.png)</span></span>

<span data-ttu-id="5bf51-227">대신 Visual Studio Ultimate에서 IntelliTrace 기능 코드를 변경 하거나도 중단점을 설정 하도록 요구 하지 않습니다는 Entity Framework에서 생성 된 SQL 명령을 확인 하는 방법을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-227">As an alternative, the IntelliTrace feature in Visual Studio Ultimate provides a way to view SQL commands generated by the Entity Framework that doesn't require you to change your code or even set a breakpoint.</span></span>

> [!NOTE]
> <span data-ttu-id="5bf51-228">Visual Studio Ultimate가 있는 경우에 다음 절차를 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-228">You can perform the following procedures only if you have Visual Studio Ultimate.</span></span>


<span data-ttu-id="5bf51-229">복원의 원본 코드는 `GetDepartmentsByName` 메서드와 다음 실행은 *Departments.aspx* 디버거에서 페이지입니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-229">Restore the original code in the `GetDepartmentsByName` method, and then run the *Departments.aspx* page in the debugger.</span></span>

<span data-ttu-id="5bf51-230">Visual Studio에서 선택 된 **디버그** 메뉴, **IntelliTrace**, 차례로 **IntelliTrace 이벤트**합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-230">In Visual Studio, select the **Debug** menu, then **IntelliTrace**, and then **IntelliTrace Events**.</span></span>

<span data-ttu-id="5bf51-231">[![Image11](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image14.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image13.png)</span><span class="sxs-lookup"><span data-stu-id="5bf51-231">[![Image11](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image14.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image13.png)</span></span>

<span data-ttu-id="5bf51-232">에 **IntelliTrace** 창 클릭 **모두 중단**합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-232">In the **IntelliTrace** window, click **Break All**.</span></span>

<span data-ttu-id="5bf51-233">[![Image12](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image16.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image15.png)</span><span class="sxs-lookup"><span data-stu-id="5bf51-233">[![Image12](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image16.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image15.png)</span></span>

<span data-ttu-id="5bf51-234">**IntelliTrace** 창은 최근 이벤트의 목록을 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-234">The **IntelliTrace** window displays a list of recent events:</span></span>

<span data-ttu-id="5bf51-235">[![Image09](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image18.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image17.png)</span><span class="sxs-lookup"><span data-stu-id="5bf51-235">[![Image09](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image18.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image17.png)</span></span>

<span data-ttu-id="5bf51-236">클릭는 **ADO.NET** 선입니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-236">Click the **ADO.NET** line.</span></span> <span data-ttu-id="5bf51-237">명령 텍스트를 표시 하려면 확장 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-237">It expands to show you the command text:</span></span>

<span data-ttu-id="5bf51-238">[![Image10](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image20.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image19.png)</span><span class="sxs-lookup"><span data-stu-id="5bf51-238">[![Image10](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image20.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image19.png)</span></span>

<span data-ttu-id="5bf51-239">전체 명령 텍스트 문자열에서 클립보드에 복사할 수 있습니다는 **지역** 창.</span><span class="sxs-lookup"><span data-stu-id="5bf51-239">You can copy the entire command text string to the clipboard from the **Locals** window.</span></span>

<span data-ttu-id="5bf51-240">테이블, 관계 및 간단한 보다 열을 사용 하 여 데이터베이스를 사용 하는 가정 `School` 데이터베이스입니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-240">Suppose you were working with a database with more tables, relationships, and columns than the simple `School` database.</span></span> <span data-ttu-id="5bf51-241">단일에 필요한 모든 정보를 수집 하는 쿼리를 찾을 수 있습니다 `Select` 다중 포함 하는 문이 `Join` 효율적으로 작동 하도록 절 너무 복잡해 집니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-241">You might find that a query that gathers all the information you need in a single `Select` statement containing multiple `Join` clauses becomes too complex to work efficiently.</span></span> <span data-ttu-id="5bf51-242">이 경우 쿼리를 단순화 하기 위해 명시적으로 로드 하려면 로드 하는 eager에서 전환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-242">In that case you can switch from eager loading to explicit loading to simplify the query.</span></span>

<span data-ttu-id="5bf51-243">예를 들어 바꾸려고의 코드는 `GetDepartmentsByName` 메서드에서 *SchoolRepository.cs*합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-243">For example, try changing the code in the `GetDepartmentsByName` method in *SchoolRepository.cs*.</span></span> <span data-ttu-id="5bf51-244">현재 수 있다는 점에서 메서드가 포함 된 개체 쿼리에 `Include` 에 대 한 메서드는 `Person` 및 `Courses` 탐색 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-244">Currently in that method you have an object query that has `Include` methods for the `Person` and `Courses` navigation properties.</span></span> <span data-ttu-id="5bf51-245">대체는 `return` 다음 예제와 같이 명시적 로드를 수행 하는 코드를 사용 하 여 문을:</span><span class="sxs-lookup"><span data-stu-id="5bf51-245">Replace the `return` statement with code that performs explicit loading, as shown in the following example:</span></span>

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample14.cs)]

<span data-ttu-id="5bf51-246">실행 된 *Departments.aspx* 디버거에서 페이지는 **IntelliTrace** 창으로 다시 가입 하지 않은 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-246">Run the *Departments.aspx* page in the debugger and check the **IntelliTrace** window again as you did before.</span></span> <span data-ttu-id="5bf51-247">이제는 단일 쿼리 하기 전에 있었던의 긴 시퀀스가 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-247">Now, where there was a single query before, you see a long sequence of them.</span></span>

<span data-ttu-id="5bf51-248">[![Image13](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image22.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image21.png)</span><span class="sxs-lookup"><span data-stu-id="5bf51-248">[![Image13](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image22.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image21.png)</span></span>

<span data-ttu-id="5bf51-249">첫 번째 클릭 **ADO.NET** 줄 변경 된 것으로 복잡 한 쿼리 수를 확인 하려면 이전 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-249">Click the first **ADO.NET** line to see what has happened to the complex query you viewed earlier.</span></span>

<span data-ttu-id="5bf51-250">[![Image14](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image24.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image23.png)</span><span class="sxs-lookup"><span data-stu-id="5bf51-250">[![Image14](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image24.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image23.png)</span></span>

<span data-ttu-id="5bf51-251">부서에서 쿼리는 간단한 바뀌었기 `Select` 없이 쿼리 `Join` 원본에서 반환 된 각 부서에 대 한 두 개의 쿼리 집합을 사용 하 여 관련된 과정 및 관리자를 검색 하는 별도 쿼리 절 하지만 뒤, 쿼리입니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-251">The query from Departments has become a simple `Select` query with no `Join` clause, but it's followed by separate queries that retrieve related courses and an administrator, using a set of two queries for each department returned by the original query.</span></span>

> [!NOTE]
> <span data-ttu-id="5bf51-252">두면 지연 로드 사용, 동일한 쿼리를 여러 번 반복와 여기에서 표시 하는 패턴의 지연 로드 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-252">If you leave lazy loading enabled, the pattern you see here, with the same query repeated many times, might result from lazy loading.</span></span> <span data-ttu-id="5bf51-253">방지 하려면 일반적으로 하는 패턴은 기본 테이블의 모든 행에 대 한 지연 로딩이 관련된 데이터입니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-253">A pattern that you typically want to avoid is lazy-loading related data for every row of the primary table.</span></span> <span data-ttu-id="5bf51-254">단일 조인 쿼리가 너무 복잡해 서 효율적 임을 확인 한 경우가 아니면는 일반적으로 즉시 로드를 사용 하는 기본 쿼리를 변경 하 여 이러한 경우에는 성능 향상 시킬 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-254">Unless you've verified that a single join query is too complex to be efficient, you'd typically be able to improve performance in such cases by changing the primary query to use eager loading.</span></span>


## <a name="pre-generating-views"></a><span data-ttu-id="5bf51-255">뷰 미리 생성</span><span class="sxs-lookup"><span data-stu-id="5bf51-255">Pre-Generating Views</span></span>

<span data-ttu-id="5bf51-256">경우는 `ObjectContext` 개체가 먼저 만들어진 새 응용 프로그램 도메인, Entity Framework에서 사용 하 여 데이터베이스에 액세스 하는 클래스 집합을 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-256">When an `ObjectContext` object is first created in a new application domain, the Entity Framework generates a set of classes that it uses to access the database.</span></span> <span data-ttu-id="5bf51-257">이러한 클래스 라고 *뷰*, 매우 큰 데이터 모델을 사용 하는 경우 이러한 뷰를 생성이 지연 될 수 웹 사이트의 요청에 응답 하는 첫 번째 페이지에 대 한 새 응용 프로그램 도메인 초기화 된 후입니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-257">These classes are called *views*, and if you have a very large data model, generating these views can delay the web site's response to the first request for a page after a new application domain is initialized.</span></span> <span data-ttu-id="5bf51-258">런타임이 아닌 컴파일 타임에 뷰를 만들어 이러한 첫 번째 요청 지연 시간을 줄일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-258">You can reduce this first-request delay by creating the views at compile time rather than at run time.</span></span>

> [!NOTE]
> <span data-ttu-id="5bf51-259">응용 프로그램이 없는 경우는 매우 큰 데이터 모델 또는 큰 데이터 모델에는 IIS가 재활용 후에 첫 번째 페이지 요청에 영향을 주는 성능 문제에 대 한 고려 하지 않는 경우에이 섹션을 건너뛸 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-259">If your application doesn't have an extremely large data model, or if it does have a large data model but you aren't concerned about a performance problem that affects only the very first page request after IIS is recycled, you can skip this section.</span></span> <span data-ttu-id="5bf51-260">보기 만들기를 인스턴스화할 때마다 발생 하지 않는 한 `ObjectContext` 개체는 뷰는 응용 프로그램 도메인에 캐시 되므로 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-260">View creation doesn't happen every time you instantiate an `ObjectContext` object, because the views are cached in the application domain.</span></span> <span data-ttu-id="5bf51-261">따라서 IIS에서 응용 프로그램 재활용 자주 하는 경우가 아니면 매우 적은 페이지 요청 미리 생성 된 뷰에서 좋지 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-261">Therefore, unless you're frequently recycling your application in IIS, very few page requests would benefit from pre-generated views.</span></span>


<span data-ttu-id="5bf51-262">사용 하 여 뷰를 미리 생성할 수 있습니다는 *EdmGen.exe* 명령줄 도구를 사용 하 여 또는 *Text Template Transformation Toolkit* (T4) 템플릿을 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-262">You can pre-generate views using the *EdmGen.exe* command-line tool or by using a *Text Template Transformation Toolkit* (T4) template.</span></span> <span data-ttu-id="5bf51-263">이 자습서에서는 T4 템플릿을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-263">In this tutorial you'll use a T4 template.</span></span>

<span data-ttu-id="5bf51-264">에 *DAL* 폴더를 사용 하 여 파일을 추가 **텍스트 템플릿** 서식 파일 (은 아래에 **일반** 에서 노드는 **설치 된 템플릿** 목록), 이름을 지정 *SchoolModel.Views.tt*합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-264">In the *DAL* folder, add a file using the **Text Template** template (it's under the **General** node in the **Installed Templates** list), and name it *SchoolModel.Views.tt*.</span></span> <span data-ttu-id="5bf51-265">파일의 기존 코드를 다음 코드로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-265">Replace the existing code in the file with the following code:</span></span>

[!code-csharp[Main](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/samples/sample15.cs)]

<span data-ttu-id="5bf51-266">이 코드에 대 한 뷰를 생성 한 *.edmx* 템플릿 파일과 같은 이름을 가진 및 템플릿과 같은 폴더에 있는 파일입니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-266">This code generates views for an *.edmx* file that's located in the same folder as the template and that has the same name as the template file.</span></span> <span data-ttu-id="5bf51-267">예를 들어, 템플릿 파일의 이름은 *SchoolModel.Views.tt*, 명명 된 데이터 모델 파일을 찾습니다 *SchoolModel.edmx*합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-267">For example, if your template file is named *SchoolModel.Views.tt*, it will look for a data model file named *SchoolModel.edmx*.</span></span>

<span data-ttu-id="5bf51-268">파일을 마우스 오른쪽 단추로 클릭 한 다음 파일을 저장 **솔루션 탐색기** 선택 **사용자 지정 도구 실행**합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-268">Save the file, then right-click the file in **Solution Explorer** and select **Run Custom Tool**.</span></span>

<span data-ttu-id="5bf51-269">[![Image02](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image26.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image25.png)</span><span class="sxs-lookup"><span data-stu-id="5bf51-269">[![Image02](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image26.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image25.png)</span></span>

<span data-ttu-id="5bf51-270">Visual Studio 이라고 하는 뷰를 만드는 코드 파일을 생성 *SchoolModel.Views.cs* 템플릿을 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-270">Visual Studio generates a code file that creates the views, which is named *SchoolModel.Views.cs* based on the template.</span></span> <span data-ttu-id="5bf51-271">(보았을 것을 선택 하기 전에 코드 파일이 생성 됩니다 **사용자 지정 도구 실행**서식 파일을 저장 하는 즉시,.)</span><span class="sxs-lookup"><span data-stu-id="5bf51-271">(You might have noticed that the code file is generated even before you select **Run Custom Tool**, as soon as you save the template file.)</span></span>

<span data-ttu-id="5bf51-272">[![Image01](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image28.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image27.png)</span><span class="sxs-lookup"><span data-stu-id="5bf51-272">[![Image01](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image28.png)](maximizing-performance-with-the-entity-framework-in-an-asp-net-web-application/_static/image27.png)</span></span>

<span data-ttu-id="5bf51-273">이제 응용 프로그램을 실행 하 고 이전과 같이 작동 하는지 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-273">You can now run the application and verify that it works as it did before.</span></span>

<span data-ttu-id="5bf51-274">미리 생성 된 뷰에 대 한 자세한 내용은 다음 리소스를 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-274">For more information about pre-generated views, see the following resources:</span></span>

- <span data-ttu-id="5bf51-275">[방법: 미리 생성 뷰를 쿼리 성능을 향상 시킬](https://msdn.microsoft.com/en-us/library/bb896240.aspx) MSDN 웹 사이트.</span><span class="sxs-lookup"><span data-stu-id="5bf51-275">[How to: Pre-Generate Views to Improve Query Performance](https://msdn.microsoft.com/en-us/library/bb896240.aspx) on the MSDN web site.</span></span> <span data-ttu-id="5bf51-276">사용 하는 방법에 설명 된 `EdmGen.exe` 명령줄 도구를 미리 보기를 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-276">Explains how to use the `EdmGen.exe` command-line tool to pre-generate views.</span></span>
- <span data-ttu-id="5bf51-277">[미리 컴파일된/사전 generated 보기와 Entity Framework 4의 성능 격리](https://blogs.msdn.com/b/appfabriccat/archive/2010/08/06/isolating-performance-with-precompiled-pre-generated-views-in-the-entity-framework-4.aspx) Windows Server AppFabric 고객 자문 팀 블로그.</span><span class="sxs-lookup"><span data-stu-id="5bf51-277">[Isolating Performance with Precompiled/Pre-generated Views in the Entity Framework 4](https://blogs.msdn.com/b/appfabriccat/archive/2010/08/06/isolating-performance-with-precompiled-pre-generated-views-in-the-entity-framework-4.aspx) on the Windows Server AppFabric Customer Advisory Team blog.</span></span>

<span data-ttu-id="5bf51-278">Entity Framework를 사용 하 여 ASP.NET 웹 응용 프로그램의 성능 향상을 도입을 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-278">This completes the introduction to improving performance in an ASP.NET web application that uses the Entity Framework.</span></span> <span data-ttu-id="5bf51-279">자세한 내용은 다음 리소스를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="5bf51-279">For more information, see the following resources:</span></span>

- <span data-ttu-id="5bf51-280">[성능 고려 사항 (Entity Framework)](https://msdn.microsoft.com/en-us/library/cc853327.aspx) MSDN 웹 사이트입니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-280">[Performance Considerations (Entity Framework)](https://msdn.microsoft.com/en-us/library/cc853327.aspx) on the MSDN web site.</span></span>
- <span data-ttu-id="5bf51-281">[Entity Framework 팀 블로그 게시물 성능 관련](https://blogs.msdn.com/b/adonet/archive/tags/performance/)합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-281">[Performance-related posts on the Entity Framework Team blog](https://blogs.msdn.com/b/adonet/archive/tags/performance/).</span></span>
- <span data-ttu-id="5bf51-282">[EF 병합 옵션 및 컴파일된 쿼리](https://blogs.msdn.com/b/dsimmons/archive/2010/01/12/ef-merge-options-and-compiled-queries.aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-282">[EF Merge Options and Compiled Queries](https://blogs.msdn.com/b/dsimmons/archive/2010/01/12/ef-merge-options-and-compiled-queries.aspx).</span></span> <span data-ttu-id="5bf51-283">컴파일된 쿼리와 병합의 예기치 않은 동작을 설명 하는 블로그 게시물와 같은 옵션 `NoTracking`합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-283">Blog post that explains unexpected behaviors of compiled queries and merge options such as `NoTracking`.</span></span> <span data-ttu-id="5bf51-284">컴파일된 쿼리를 사용 하거나 응용 프로그램에서 병합 옵션 설정을 조작 하려는 경우 먼저 읽으십시오.</span><span class="sxs-lookup"><span data-stu-id="5bf51-284">If you plan to use compiled queries or manipulate merge option settings in your application, read this first.</span></span>
- <span data-ttu-id="5bf51-285">[Entity Framework 관련 데이터 및 모델링 고객 자문 팀 블로그의 게시물](https://blogs.msdn.com/b/dmcat/archive/tags/entity+framework/)합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-285">[Entity Framework-related posts in the Data and Modeling Customer Advisory Team blog](https://blogs.msdn.com/b/dmcat/archive/tags/entity+framework/).</span></span> <span data-ttu-id="5bf51-286">컴파일된 쿼리 및 성능 문제를 발견 하는 Visual Studio 2010 프로파일러 사용에 대 한 게시를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-286">Includes posts on compiled queries and using the Visual Studio 2010 Profiler to discover performance issues.</span></span>
- <span data-ttu-id="5bf51-287">[매우 복잡 한 쿼리 성능 향상에 정보를 제공 entity Framework 포럼 스레드](https://social.msdn.microsoft.com/Forums/en-US/adodotnetentityframework/thread/ffe8b2ab-c5b5-4331-8988-33a872d0b5f6)합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-287">[Entity Framework forum thread with advice on improving performance of highly complex queries](https://social.msdn.microsoft.com/Forums/en-US/adodotnetentityframework/thread/ffe8b2ab-c5b5-4331-8988-33a872d0b5f6).</span></span>
- <span data-ttu-id="5bf51-288">[ASP.NET 상태 관리 권장 사항](https://msdn.microsoft.com/en-us/library/z1hkazw7.aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-288">[ASP.NET State Management Recommendations](https://msdn.microsoft.com/en-us/library/z1hkazw7.aspx).</span></span>
- <span data-ttu-id="5bf51-289">[Entity Framework와는 ObjectDataSource를 사용 하 여: 사용자 지정 페이징](http://geekswithblogs.net/Frez/articles/using-the-entity-framework-and-the-objectdatasource-custom-paging.aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-289">[Using the Entity Framework and the ObjectDataSource: Custom Paging](http://geekswithblogs.net/Frez/articles/using-the-entity-framework-and-the-objectdatasource-custom-paging.aspx).</span></span> <span data-ttu-id="5bf51-290">블로그 게시물에서 페이징을 구현 하는 방법을 설명 하기 위해이 자습서에서 만든 ContosoUniversity 응용에 작성 되는 *Departments.aspx* 페이지.</span><span class="sxs-lookup"><span data-stu-id="5bf51-290">Blog post that builds on the ContosoUniversity application created in these tutorials to explain how to implement paging in the *Departments.aspx* page.</span></span>

<span data-ttu-id="5bf51-291">다음 자습서에서 중요 한 향상 된 기능은을 Entity Framework 버전 4의에서 새로운 기능 중 일부를 검토 합니다.</span><span class="sxs-lookup"><span data-stu-id="5bf51-291">The next tutorial reviews some of the important enhancements to the Entity Framework that are new in version 4.</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="5bf51-292">[이전](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application.md)
[다음](what-s-new-in-the-entity-framework-4.md)</span><span class="sxs-lookup"><span data-stu-id="5bf51-292">[Previous](handling-concurrency-with-the-entity-framework-in-an-asp-net-web-application.md)
[Next](what-s-new-in-the-entity-framework-4.md)</span></span>
