---
title: ASP.NET Core 2.2에서 3.0로 마이그레이션
author: rick-anderson
description: ASP.NET Core 2.2 프로젝트를 ASP.NET Core 3.0로 마이그레이션하는 방법에 대해 알아봅니다.
ms.author: riande
ms.custom: mvc
ms.date: 09/25/2019
uid: migration/22-to-30
ms.openlocfilehash: 5d0feebfd0ad3bdb1f46393d43c90c0d623e01af
ms.sourcegitcommit: e644258c95dd50a82284f107b9bf3becbc43b2b2
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/26/2019
ms.locfileid: "71317628"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>ASP.NET Core 2.2에서 3.0로 마이그레이션

[Scott Addie](https://github.com/scottaddie) 및 [Rick Anderson](https://twitter.com/RickAndMSFT)

이 문서에서는 기존 ASP.NET Core 2.2 프로젝트를 ASP.NET Core 3.0로 업데이트 하는 방법을 설명 합니다.

## <a name="prerequisites"></a>전제 조건

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Visual Studio for Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-the-project-file"></a>프로젝트 파일 업데이트

### <a name="update-the-target-framework"></a>대상 프레임 워크 업데이트

ASP.NET Core 3.0 이상 .NET Core 에서만 실행 됩니다. [대상 프레임 워크 모니커 (TFM)](/dotnet/standard/frameworks) 를 `netcoreapp3.0`다음과 같이 설정 합니다.

```xml
<TargetFramework>netcoreapp3.0</TargetFramework>
```

### <a name="remove-obsolete-package-references"></a>사용 되지 않는 패키지 참조 제거

ASP.NET Core 더 이상 NuGet 패키지 기능을 많이 생성 하지 않습니다. 이러한 패키지 참조는 프로젝트 파일에서 제거 해야 합니다. 더 이상 생성 되지 않는 패키지의 전체 목록을 보려면 아래를 참조 하세요.

<details>
    <summary>더 이상 생성 되지 않는 패키지 목록을 확장 하려면 여기를 클릭 하세요.</summary>
    <ul>
        <li>Microsoft.AspNetCore</li>
        <li>Microsoft.AspNetCore.All</li>
        <li>Microsoft.AspNetCore.App</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft.AspNetCore.Authentication.Cookies</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.JwtBearer</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authentication.OpenIdConnect</li>
        <li>Microsoft.AspNetCore.Authorization</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft.AspNetCore.CookiePolicy</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Cryptography.Internal</li>
        <li>Microsoft.AspNetCore.Cryptography.KeyDerivation</li>
        <li>Microsoft.AspNetCore.DataProtection</li>
        <li>Microsoft.AspNetCore.DataProtection.Abstractions</li>
        <li>Microsoft.AspNetCore.DataProtection.Extensions</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft.AspNetCore.HostFiltering</li>
        <li>Microsoft.AspNetCore.Hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.Http.Features</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft.AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft.AspNetCore.MiddlewareAnalysis</li>
        <li>Microsoft.AspNetCore.Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft.AspNetCore.Mvc.Razor</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.Extensions</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.ViewCompilation</li>
        <li>Microsoft.AspNetCore.Mvc.RazorPages</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft.AspNetCore.Razor</li>
        <li>Microsoft.AspNetCore.Razor.Runtime</li>
        <li>Microsoft.AspNetCore.Razor.Design</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft.AspNetCore.Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>Microsoft.AspNetCore.SignalR</li>
        <li>Microsoft.AspNetCore.SignalR.Core</li>
        <li>Microsoft.AspNetCore.StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.Net</li>
    </ul>
</details>

### <a name="framework-reference"></a>프레임 워크 참조

위에 나열 된 패키지 중 하나를 통해 사용할 수 있는 ASP.NET Core 기능은 `Microsoft.AspNetCore.App` 공유 프레임 워크의 일부로 제공 됩니다. *공유 프레임 워크* 는 컴퓨터에 설치 되는 어셈블리 ( *.dll* 파일) 집합으로, 런타임 구성 요소와 대상 팩을 포함 합니다. 자세한 내용은 [공유 프레임워크](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/)를 참조하세요.

* SDK를 `Microsoft.NET.Sdk.Web` 대상으로 하는 프로젝트는 `Microsoft.AspNetCore.App` 프레임 워크를 암시적으로 참조 합니다.

이러한 프로젝트에는 추가 참조가 필요 하지 않습니다.

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
  </PropertyGroup>
    ...
</Project>
```

* 또는 `Microsoft.NET.Sdk` `FrameworkReference` `Microsoft.AspNetCore.App`SDK를 대상으로 하는 프로젝트는 명시적를에 추가 해야 합니다. `Microsoft.NET.Sdk.Razor`

```xml
<Project Sdk="Microsoft.NET.Sdk.Razor">
  <PropertyGroup>
    <TargetFramework>netcoreapp3.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>
    ...
</Project>
```

#### <a name="framework-dependent-builds-using-docker"></a>Docker를 사용 하는 프레임 워크 종속 빌드

ASP.NET Core [공유 프레임 워크](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) 에 종속 된 패키지를 사용 하는 콘솔 앱의 프레임 워크 종속 빌드는 다음과 같은 런타임 오류를 제공할 수 있습니다.

```cli
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App`는 ASP.NET Core 런타임을 포함 하는 공유 프레임 워크로 [dotnet/Core/aspnet](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) docker 이미지에만 존재 합니다.  3\.0 SDK는 공유 프레임 워크에서 사용할 수 있는 라이브러리의 중복 복사본을 포함 하지 않으므로 asp.net core를 사용 하 여 프레임 워크 종속 빌드의 크기를 줄입니다.  이는 최대 18MB의 잠재적 절감 효과를 제공 하지만 앱을 실행 하려면 ASP.NET Core 런타임을 설치/설치 해야 합니다.

앱에 ASP.NET Core 공유 프레임 워크에 대 한 종속성 (직접 또는 간접)이 있는지 확인 하려면 앱 빌드/게시 중에 생성 된 *runtimeconfig.template.json* 파일을 검사 합니다. 다음 JSON 파일은 ASP.NET Core 공유 프레임 워크에 대 한 종속성을 보여 줍니다.

```JSON
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

앱에서 docker를 사용 하는 경우 ASP.NET Core 3.0를 포함 하는 기본 이미지를 사용 합니다. 예를 들어, `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`을 입력합니다.

### <a name="add-package-references-for-removed-assemblies"></a>제거 되는 어셈블리에 대 한 패키지 참조 추가

ASP.NET Core 3.0는 이전에 `Microsoft.AspNetCore.App` 패키지 참조의 일부인 일부 어셈블리를 제거 합니다. 이러한 어셈블리에서 제공 하는 기능을 계속 사용 하려면 해당 패키지의 3.0 버전을 참조 하세요.

* Entity Framework Core &ndash; 데이터베이스 공급자별 패키지를 참조 하는 방법에 대 한 자세한 내용은 [데이터베이스 공급자](/ef/core/providers/index)를 참조 하세요.

* Id UI

  [AspNetCore](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) 패키지를 참조 하 여 [id ui](xref:security/authentication/identity) 에 대 한 지원을 추가할 수 있습니다.

* SPA 서비스
  * [AspNetCore. SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [AspNetCore. SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* 타사 &ndash; 인증 흐름에 대 한 인증 지원은 NuGet 패키지로 사용할 수 있습니다.

  * Facebook OAuth ([AspNetCore](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([AspNetCore](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * Openid connect Connect 전달자 토큰 ([AspNetCore. JwtBearer](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Microsoft 계정 인증 ([AspNetCore. MicrosoftAccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * Openid connect Connect 인증 ([AspNetCore connect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * Twitter OAuth ([AspNetCore](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * WsFederation 인증 ([AspNetCore WsFederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* [WebApi](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) NuGet 패키지에 대 `System.Net.HttpClient` 한 `System.Net.HttpClient` &ndash; 서식 및 콘텐츠 협상 지원은 등의 api `ReadAsAsync` `PostJsonAsync` 를 사용 하 여에 유용한 확장성을 제공 합니다.

* Razor 뷰 및 &ndash; 페이지의 런타임 컴파일에 대 한 razor 런타임 컴파일 지원은 이제 AspNetCore의 일부입니다. [RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation).

* Mvc에서 mvc를 사용할 수 있도록 지원 [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson)의 일부입니다. `Newtonsoft.Json` &ndash; `Newtonsoft.Json`

### <a name="analyzer-support"></a>분석기 지원

* AspNetCore 패키지의 `Microsoft.NET.Sdk.Web` 일부로 이전에 제공 된 분석기를 암시적으로 [Microsoft.AspNetCore.Mvc.Analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) 참조 하는 프로젝트입니다. 이러한 기능을 사용 하도록 설정 하는 데 필요한 추가 참조는 없습니다.

* 앱이 이전에 [AspNetCore](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) 패키지를 사용 하 여 제공한 [API 분석기](xref:web-api/advanced/analyzers) 를 사용 하는 경우 .net Core 웹 SDK의 일부로 제공 되는 분석기를 참조 하도록 프로젝트 파일을 편집 합니다.

    ```xml
    <Project Sdk="Microsoft.NET.Sdk.Web">
      <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
      </PropertyGroup>
    
      ...
    </Project>
    ```

### <a name="razor-class-library"></a>Razor 클래스 라이브러리

MVC에 대 한 UI 구성 요소를 제공 하는 Razor 클래스 `AddRazorSupportForMvc` 라이브러리 프로젝트는 프로젝트 파일에서 속성을 설정 해야 합니다.

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>In-Process 호스팅 모델

프로젝트는 ASP.NET Core 3.0 이상에서 [in-process 호스팅 모델로](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) 기본 됩니다. 해당 값이 인 `<AspNetCoreHostingModel>` `InProcess`경우 프로젝트 파일에서 속성을 선택적으로 제거할 수 있습니다.

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Configuration

( `ConfigureWebHostDefaults` *Program.cs*)에서 제공 하는 웹 호스트 작성기로 kestrel 구성 마이그레이션:

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

앱이를 사용 `HostBuilder`하 여 호스트를 수동으로 만드는 경우의 `ConfigureWebHostDefaults`웹 호스트 빌더에서를 호출 `UseKestrel` 합니다.

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>연결의 미들웨어가 연결 어댑터를 대체 합니다.

연결 어댑터 (<xref:Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter>)가 kestrel에서 제거 되었습니다. 연결 어댑터를 연결 미들웨어로 대체 합니다. 연결 미들웨어는 ASP.NET Core 파이프라인의 HTTP 미들웨어와 유사 하지만 하위 수준 연결의 경우입니다. HTTPS 및 연결 로깅:

* 연결 어댑터에서 연결 미들웨어로 이동 되었습니다.
* 이러한 확장 메서드는 이전 버전의 ASP.NET Core와 동일 하 게 작동 합니다. 

자세한 내용은 [Kestrel 문서의 ListenOptions 섹션에서 TlsFilterConnectionHandler 예](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols)를 참조 하세요.

### <a name="transport-abstractions-moved-and-made-public"></a>전송 추상화 이동 및 공개

Kestrel 전송 계층이에서 `Connections.Abstractions`공용 인터페이스로 노출 되었습니다. 이러한 업데이트의 일부로:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions`및 관련 형식이 제거 되었습니다.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay>는에서 <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> 전송 옵션으로 이동 되었습니다.
* <xref:Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode>가에서 <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>제거 되었습니다.

자세한 내용은 다음 GitHub 리소스를 참조 하세요.

* [클라이언트/서버 네트워킹 추상화 (aspnet/AspNetCore #10308)](https://github.com/aspnet/AspNetCore/issues/10308)
* [새 bedrock 수신기 추상화를 구현 하 고 맨 위에 cross-plat Kestrel을 구현 합니다 (aspnet/AspNetCore #10321).](https://github.com/aspnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Kestrel 요청 트레일러 헤더

이전 버전의 ASP.NET Core를 대상으로 하는 앱의 경우:

* Kestrel은 HTTP/1.1 청크 분할 트레일러 헤더를 요청 헤더 컬렉션에 추가 합니다.
* 트레일러는 요청 본문을 끝으로 읽은 후에 사용할 수 있습니다.

이로 인해 헤더와 트레일러의 모호성에 대 한 우려 사항이 발생 하므로, 3.0에서 트레일러는 새 컬렉션`RequestTrailerExtensions`()으로 이동 되었습니다.

HTTP/2 요청 트레일러는 다음과 같습니다.

* ASP.NET Core 2.2에서는 사용할 수 없습니다.
* 3\.0에서로 `RequestTrailerExtensions`사용할 수 있습니다.

이러한 트레일러에 액세스 하기 위한 새 요청 확장 메서드가 있습니다. HTTP/1.1과 마찬가지로 트레일러는 요청 본문을 끝까지 읽은 후에 사용할 수 있습니다.

3\.0 릴리스의 경우 다음 `RequestTrailerExtensions` 메서드를 사용할 수 있습니다.

* `GetDeclaredTrailers`본문 후에 `Trailer` 사용할 트레일러를 나열 하는 요청 헤더를 가져옵니다. &ndash;
* `SupportsTrailers`&ndash; 요청에서 트레일러 헤더 수신을 지원 하는지 여부를 나타냅니다.
* `CheckTrailersAvailable`&ndash; 요청에서 트레일러를 지원 하 고 읽을 수 있는지 여부를 확인 합니다. 이 검사는 읽을 후행이 있다고 가정 하지 않습니다. 이 메서드에서 `true` 을 반환 하더라도 읽을 트레일러가 없을 수 있습니다.
* `GetTrailer`&ndash; 응답에서 요청 된 후행 헤더를 가져옵니다. 를 `SupportsTrailers` 호출 `GetTrailer`하기 전에 확인 하거나 <xref:System.NotSupportedException> 요청이 후행 헤더를 지원 하지 않는 경우이 발생할 수 있습니다.

자세한 내용은 [별도의 컬렉션에 요청 트레일러 배치 (aspnet/AspNetCore #10410)](https://github.com/aspnet/AspNetCore/pull/10410)를 참조 하세요.

### <a name="allowsynchronousio-disabled"></a>AllowSynchronousIO 사용 안 함

`AllowSynchronousIO``HttpRequest.Body.Read` ,`HttpResponse.Body.Write` ,`Stream.Flush`등의 동기 IO api를 사용 하거나 사용 하지 않도록 설정 합니다. 이러한 Api는 앱 작동 중단에 대 한 스레드 고갈의 소스입니다. 3\.0 `AllowSynchronousIO` 에서은 기본적으로 사용 하지 않도록 설정 되어 있습니다. 자세한 내용은 [Kestrel 문서의 동기 IO 섹션](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io)을 참조 하세요.

의 옵션을 사용 `AllowSynchronousIO` 하도록 설정 하는 것 외에도, 비동기 IO는 요청 별로 임시 완화 방법으로 재정의할 수 있습니다. `ConfigureKestrel`

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

[Dispose](/dotnet/standard/garbage-collection/implementing-dispose) 에서 동기 api를 <xref:System.IO.TextWriter> 호출 하는 다른 스트림이나 구현에 문제가 있는 경우 대신 새 <xref:System.IO.Stream.DisposeAsync*> API를 호출 합니다.

자세한 내용은 [[알림] AllowSynchronousIO disabled in all servers (aspnet/AspNetCore #7644)](https://github.com/aspnet/AspNetCore/issues/7644)를 참조 하세요.

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>AspNetCore 어셈블리를 제거 했습니다.

ASP.NET Core 2.1에서는 *AspNetCore* 의 내용이 *AspNetCore*로 이동 되었습니다... n a m .dll. n a m .dll. 이는 특성을 사용 하 `TypeForwardedTo` 는 주요 업데이트가 아닙니다. 3\.0의 경우 빈 *AspNetCore* 어셈블리 (및 NuGet 패키지)가 제거 된 것이 고,

[AspNetCore](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) 를 참조 하는 라이브러리는 ASP.NET Core 종속성을 2.1 이상으로 업데이트 해야 합니다.

ASP.NET Core 2.1 이상을 대상으로 하는 앱 및 라이브러리는 [AspNetCore](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) 패키지에 대 한 직접 참조를 모두 제거 해야 합니다.

## <a name="jsonnet-support"></a>Json.NET 지원

[ASP.NET Core 공유 프레임 워크를 개선](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/)하는 작업의 일환으로 ASP.NET Core 공유 프레임 워크에서 [Json.NET](https://www.newtonsoft.com/json/help/html/Introduction.htm) 이 제거 되었습니다.

ASP.NET Core에 대 한 기본값은 [이제 .Net](/dotnet/api/system.text.json?view=netcore-3.0)Core 3.0의 새로운 system.string입니다. 가능 하면 `System.Text.Json` 를 사용 하는 것이 좋습니다. 고성능 이며 추가 라이브러리 종속성이 필요 하지 않습니다. 그러나가 새로운 `System.Text.Json` 이기 때문에 현재 앱에 필요한 기능이 없을 수 있습니다.

앱이 JsonPatch 또는 `Newtonsoft.Json` 변환기와 같은 특정 `Newtonsoft.Json`기능을 사용 하거나 [형식이](xref:web-api/advanced/formatting) `Newtonsoft.Json`특정 형식인 경우 통합이 필요할 수 있습니다.

ASP.NET Core 3.0 SignalR 프로젝트에서 Json.NET를 사용 하려면이 문서에서 [newtonsoft.json로 전환](#switch-to-newtonsoftjson) 을 참조 하세요.

ASP.NET Core 3.0 프로젝트에서 Json.NET를 사용 하려면 다음을 수행 합니다.

* [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson)에 패키지 참조를 추가합니다.
* 를 `Startup.ConfigureServices` 호출`AddNewtonsoftJson`하도록 업데이트 합니다.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson`는 새로운 MVC 서비스 등록 방법과 호환 됩니다.

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  Json.NET 설정은 다음에 대 한 `AddNewtonsoftJson`호출에서 설정할 수 있습니다.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## <a name="mvc-service-registration"></a>MVC 서비스 등록

ASP.NET Core 3.0에는 내 `Startup.ConfigureServices`에서 MVC 시나리오를 등록 하기 위한 새로운 옵션이 추가 되었습니다.

에서 `IServiceCollection` MVC 시나리오와 관련 된 세 가지 새로운 최상위 확장 메서드를 사용할 수 있습니다. 템플릿은 대신 이러한 새 메서드를 `UseMvc`사용 합니다. 그러나는 이전 릴리스에서와 같이 계속동작합니다.`AddMvc`

다음 예에서는 뷰 또는 페이지가 아니라 컨트롤러 및 API 관련 기능에 대 한 지원을 추가 합니다. API 템플릿에서는 다음 코드를 사용 합니다.

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

다음 예에서는 컨트롤러, API 관련 기능 및 보기에 대 한 지원을 추가 하지만 페이지는 추가 하지 않습니다. 웹 응용 프로그램 (MVC) 템플릿은 다음 코드를 사용 합니다.

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

다음 예에서는 Razor Pages 및 최소 컨트롤러 지원에 대 한 지원을 추가 합니다. 웹 응용 프로그램 템플릿은 다음 코드를 사용 합니다.

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

새 메서드를 결합할 수도 있습니다. 다음 예제는 ASP.NET Core 2.2에서를 `AddMvc` 호출 하는 것과 같습니다.

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>시작 코드 라우팅

앱이 또는 `UseSignalR`를 `UseMvc` 호출 하는 경우 가능 하면 앱을 [끝점 라우팅](xref:fundamentals/routing) 으로 마이그레이션합니다. 이전 버전의 MVC와의 끝점 라우팅 호환성을 개선 하기 위해 ASP.NET Core 2.2에서 도입 된 URL 생성의 일부 변경 내용을 되돌렸습니다. 2\.2에서 끝점 라우팅을 사용 하는 데 문제가 발생 한 경우 다음과 같은 예외를 제외 하 고 ASP.NET Core 3.0에서 향상 된 기능을 사용할 수 있습니다.

* 앱이에서 `Route`구현 `IRouter` 하거나 상속 하는 경우 [DynamicRouteValuesTransformer](https://github.com/aspnet/AspNetCore.Docs/issues/12997) 을 대체로 사용 합니다.

* 앱이 MVC 내에서 `RouteData.Routers` 직접 액세스 하 여 url을 구문 분석 하는 경우를 `LinkParser.ParsePathByEndpointName`사용 하 여 바꿀 수 있습니다. 
 * 경로 이름을 사용 하 여 경로를 정의 합니다.
 * 을 `LinkParser.ParsePathByEndpointName` 사용 하 고 원하는 경로 이름을 전달 합니다.

끝점 라우팅은와 `IRouter`동일한 경로 패턴 구문 및 경로 패턴 작성 기능을 지원 합니다. 끝점 라우팅은를 `IRouteConstraint`지원 합니다. 끝점 라우팅은, `[Route]`및 `[HttpGet]`기타 MVC 라우팅 특성을 지원 합니다.

대부분의 응용 프로그램의 `Startup` 경우에는 변경만 필요 합니다.

### <a name="migrate-startupconfigure"></a>마이그레이션 시작. 구성

일반 권장 사항:

* `UseRouting`를 추가합니다.
* 앱이를 호출 `UseStaticFiles`하는 `UseStaticFiles` 경우 **앞** `UseRouting`에 놓습니다.
* 앱 `AuthorizePage` 에서 또는 `UseCors` `UseAuthorization` `UseRouting` `UseEndpoints` `UseAuthentication`와 같은 인증/권한 부여 기능을 사용 하는 경우, 및에 대 한 호출을 수행 합니다. `[Authorize]`

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    }
  ```

* 또는 `UseMvc` 를`UseSignalR` 로`UseEndpoints`바꿉니다.
* 앱에서와 `[EnableCors]`같은 [cors](xref:security/cors) 시나리오를 사용 하는 경우 cors를 사용 `UseCors` 하는 다른 미들웨어 앞에에 대 한 호출을 추가 합니다 `UseAuthentication`(예: `UseEndpoints`, `UseAuthorization`및 앞에 두기 `UseCors` ).
* 로 `IHostingEnvironment` <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> `using` 대체 하 고 네임 스페이스에 대 한 문을 추가 합니다. `IWebHostEnvironment`
* <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> ( `IApplicationLifetime` 네임스페이스)로대체합니다<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> .
* <xref:Microsoft.Extensions.Hosting.Environments> ( `EnvironmentName` 네임스페이스)로대체합니다<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> .

다음 코드는 일반적인 ASP.NET Core 2.2 앱 `Startup.Configure` 의 예제입니다.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

이전 `Startup.Configure` 코드를 업데이트 한 후:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> 대부분의 앱에서 `UseAuthentication`, `UseAuthorization`및 `UseCors` 에 대 한 호출은 `UseRouting` 및 `UseEndpoints` 에 대 한 호출과 적용 사이에 나타나야 합니다.

### <a name="health-checks"></a>상태 검사

상태 검사는 일반 호스트와의 끝점 라우팅을 사용 합니다. `Startup.Configure`에서 엔드포인트 URL 또는 상대 경로를 사용하여 엔드포인트 작성기에 `MapHealthChecks`를 호출합니다.

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

상태 검사 끝점은 다음을 수행할 수 있습니다.

* 허용 되는 호스트/포트를 하나 이상 지정 하십시오.
* 권한 부여가 필요 합니다.
* CORS가 필요 합니다.

자세한 내용은 <xref:host-and-deploy/health-checks>을 참조하세요.

### <a name="security-middleware-guidance"></a>보안 미들웨어 지침

권한 부여 및 CORS에 대 한 지원은 [미들웨어](xref:fundamentals/middleware/index) 접근 방식에 통합 됩니다. 이를 통해 이러한 시나리오에서 동일한 미들웨어 및 기능을 사용할 수 있습니다. 업데이트 된 권한 부여 미들웨어는이 릴리스에서 제공 되며, CORS 미들웨어는 MVC 컨트롤러에서 사용 하는 특성을 이해할 수 있도록 향상 되었습니다.

#### <a name="cors"></a>용

이전에 CORS는 구성 하기가 어려울 수 있습니다. 미들웨어는 일부 사용 사례에서 사용할 수 있도록 제공 되었지만 다른 사용 사례에서 미들웨어 **없이** 사용 하기 위한 MVC 필터입니다. ASP.NET Core 3.0를 사용 하는 경우 CORS가 필요한 모든 앱은 끝점 라우팅과 함께 CORS 미들웨어를 사용 하는 것이 좋습니다. `UseCors`기본 정책 `[EnableCors]` 으로 제공할 수 있으며, 및 `[DisableCors]` 특성을 사용 하 여 필요한 경우 기본 정책을 재정의할 수 있습니다.

다음 예제에서는

* CORS는 `default` 명명 된 정책을 사용 하는 모든 끝점에 대해 사용 하도록 설정 됩니다.
* 클래스 `MyController` 는 `[DisableCors]` 특성을 사용 하 여 CORS를 사용 하지 않도록 설정 합니다.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Authorization

이전 버전의 ASP.NET Core에서는 `[Authorize]` 특성을 통해 권한 부여 지원을 제공 했습니다. 권한 부여 미들웨어를 사용할 수 없습니다. ASP.NET Core 3.0에서는 권한 부여 미들웨어가 필요 합니다. ASP.NET Core 권한 부여 미들웨어 (`UseAuthorization`)는 바로 뒤에 `UseAuthentication`배치 하는 것이 좋습니다. 권한 부여 미들웨어는 재정의 될 수 있는 기본 정책으로 구성 될 수도 있습니다.

ASP.NET Core 3.0 이상 `UseAuthorization` 에서는가에서 `Startup.Configure`호출 되 고 다음 `HomeController` 에 로그인 한 사용자가 필요 합니다.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

앱이 MVC에서을 `AuthorizeFilter` 전역 필터로 사용 하는 경우에 대 `AddAuthorization`한 호출에서 정책을 제공 하도록 코드를 리팩터링 하는 것이 좋습니다.

는 `DefaultPolicy` 처음에 인증을 요구 하도록 구성 되므로 추가 구성이 필요 하지 않습니다. 다음 예제에서 MVC 끝점은로 `RequireAuthorization` 표시 되므로 모든 요청은 `DefaultPolicy`에 따라 권한을 부여 받아야 합니다. 그러나에서는 `HomeController` 사용자가 응용 프로그램에 로그인 할 `[AllowAnonymous]`필요 없이 다음과 같은 이유로 액세스할 수 있습니다.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

정책을 사용자 지정할 수도 있습니다. 이전 예제를 `DefaultPolicy` 기반으로 작성 된은 인증과 특정 범위를 요구 하도록 구성 됩니다.

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.DefaultPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .RequireScope("MyScope")
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

`[Authorize]` 또는를 구성 하거나 `RequireAuthorization` 를 `FallbackPolicy`구성 하 여 모든 끝점에서 권한 부여를 요구 하도록 구성할 수 있습니다. 는와 다릅니다 `DefaultPolicy`. `FallbackPolicy` `DefaultPolicy` 는 `[Authorize]` 또는 에서`RequireAuthorization`트리거되고다른 정책이 설정되지않은경우는트리거됩니다.`FallbackPolicy` `FallbackPolicy`는 처음에 권한 부여 없이 요청을 허용 하도록 구성 됩니다.

다음 예제는 이전 `DefaultPolicy` 예제와 동일 하지만가 지정 된 경우 `[AllowAnonymous]` 를 `FallbackPolicy` 제외 하 고를 사용 하 여 항상 모든 끝점에 대 한 인증을 요구 합니다.

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .RequireScope("MyScope")
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

미들웨어 별 권한 부여는 권한 부여에 대 한 특정 지식이 없는 프레임 워크 없이 작동 합니다. 예를 들어 [상태 검사](xref:host-and-deploy/health-checks) 에는 권한 부여에 대 한 특정 지식이 없지만 상태 검사에는 미들웨어에서 적용 되는 구성 가능한 권한 부여 정책이 있을 수 있습니다.

또한 각 끝점은 권한 부여 요구 사항을 사용자 지정할 수 있습니다. 다음 예제 `UseAuthorization` 에서는 `DefaultPolicy`를 사용 하 여 권한 부여를 처리 `/healthz` 하지만 상태 검사 끝점에 `admin` 는 사용자가 필요 합니다.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

보호는 일부 시나리오에 대해 구현 됩니다. `UseEndpoint`미들웨어는 누락 된 미들웨어로 인해 권한 부여 또는 CORS 정책을 건너뛰는 경우 예외를 throw 합니다. 구성 오류에 대 한 추가 피드백을 제공 하는 분석기 지원이 진행 중입니다.

### <a name="signalr"></a>SignalR

이제 SignalR hubs의 매핑이 내 `UseEndpoints`에서 수행 됩니다.

각 허브를에 `MapHub`매핑합니다. 이전 버전과 마찬가지로 각 허브는 명시적으로 나열 됩니다.

다음 예제에서는 `ChatHub` SignalR hub에 대 한 지원이 추가 되었습니다.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

클라이언트에서 메시지 크기 제한을 제어 하는 새로운 옵션이 있습니다. 예를 들면 `Startup.ConfigureServices`다음과 같습니다.

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

ASP.NET Core 2.2에서를 설정 하 여 `TransportMaxBufferSize` 최대 메시지 크기를 효과적으로 제어할 수 있습니다. ASP.NET Core 3.0에서이 옵션은 이제는 백 압력이 관찰 되기 전의 최대 크기만 제어 합니다.

### <a name="mvc-controllers"></a>MVC 컨트롤러

이제 컨트롤러 매핑이 내 `UseEndpoints`에서 발생 합니다.

앱 `MapControllers` 에서 특성 라우팅을 사용 하는 경우를 추가 합니다. 라우팅은 ASP.NET Core 3.0 이상에서 많은 프레임 워크에 대 한 지원을 포함 하기 때문에 특성으로 라우팅된 컨트롤러를 추가 하는 것은 옵트인 (opt in)입니다.

다음을 바꿉니다.

* `MapRoute`는`MapControllerRoute`
* `MapAreaRoute`는`MapAreaControllerRoute`

라우팅은 이제 MVC 이상에 대 한 지원을 포함 하므로 이러한 메서드가 수행 하는 작업을 명확 하 게 나타내도록 용어가 변경 되었습니다. `MapControllerRoute` 와 같은기존`MapDefaultControllerRoute` 경로는 추가 된 순서 대로 적용 됩니다. / `MapAreaControllerRoute` / 먼저 특정 경로 (예: 영역에 대 한 경로)를 추가 합니다.

다음 예제에서는

* `MapControllers`특성 라우트된 컨트롤러에 대 한 지원을 추가 합니다.
* `MapAreaControllerRoute`영역에 있는 컨트롤러에 대 한 기본 경로를 추가 합니다.
* `MapControllerRoute`컨트롤러에 대 한 기본 경로를 추가 합니다.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

### <a name="razor-pages"></a>Razor 페이지

이제 매핑 Razor Pages이 내 `UseEndpoints`에서 수행 됩니다.

앱 `MapRazorPages` 에서 Razor Pages 사용 하는 경우를 추가 합니다. 끝점 라우팅은 많은 프레임 워크에 대 한 지원을 포함 하므로 현재 옵트인 (opt in) Razor Pages 추가 됩니다.

`Startup.Configure` 다음`MapRazorPages` 메서드에서는 Razor Pages에 대 한 지원을 추가 합니다.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>끝점 라우팅 없이 MVC 사용

ASP.NET Core 3.0에서 `UseMvc` 또는 `UseMvcWithDefaultRoute` 를 통해 MVC를 사용 하려면 내 `Startup.ConfigureServices`에서 명시적인 옵트인이 필요 합니다. MVC는 초기화 하는 동안 권한 부여 및 CORS 미들웨어에 의존할 수 있는지 여부를 알아야 하므로이 작업을 수행 해야 합니다. 앱에서 지원 되지 않는 구성을 사용 하려고 하면 경고를 표시 하는 분석기가 제공 됩니다.

앱에 레거시 `IRouter` 지원이 필요한 경우에서 `Startup.ConfigureServices`다음 `EnableEndpointRouting` 방법 중 하나를 사용 하지 않도록 설정 합니다.

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>상태 확인

상태 검사는 끝점 라우팅을 사용 하는 *라우터-웨어* 로 사용할 수 있습니다.

끝점 `MapHealthChecks` 라우팅을 사용 하 여 상태 검사를 사용 하려면를 추가 합니다. 메서드 `MapHealthChecks` 는와 유사한 인수를 `UseHealthChecks`허용 합니다. `MapHealthChecks` Over`UseHealthChecks` 를 사용 하는 이점은 권한 부여를 적용 하 고 일치 정책에 대 한 보다 세분화 된 제어를 제공 하는 기능입니다.

다음 예제에서는에서 상태 `MapHealthChecks` 검사 `/healthz`끝점에 대해를 호출 합니다.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder가 WebHostBuilder를 대체 합니다.

ASP.NET Core 3.0 템플릿은 [제네릭 호스트](xref:fundamentals/host/generic-host)를 사용 합니다. 이전 버전은 [웹 호스트](xref:fundamentals/host/web-host)를 사용 했습니다. 다음 코드에서는 ASP.NET Core 3.0 템플릿이 생성 `Program` 된 클래스를 보여 줍니다.

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

다음 코드는 ASP.NET Core 2.2 템플릿에서 생성 `Program` 된 클래스를 보여 줍니다.

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>는 3.0에 유지 되며 앞의 코드 샘플 `webBuilder` 에서 볼 수 있는의 형식입니다. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder>이후 릴리스에서는 더 이상 사용 되지 않으며로 `HostBuilder`대체 됩니다.

에서 `WebHostBuilder` 로`HostBuilder` 의 가장 중요 한 변경 내용은 [DI (종속성 주입)](xref:fundamentals/dependency-injection)에 있습니다. 를 사용 `HostBuilder`하는 경우를의 <xref:Microsoft.Extensions.Configuration.IConfiguration> 생성자 <xref:Microsoft.AspNetCore.Hosting.IHostingEnvironment> 에 `Startup`만 삽입할 수 있습니다. `HostBuilder` DI 제약 조건:

* DI 컨테이너를 한 번만 작성 하도록 설정 합니다.
* 단일 항목의 여러 인스턴스를 확인 하는 것과 같은 결과 개체 수명 문제를 방지 합니다.

## <a name="addauthorization-moved-to-a-different-assembly"></a>AddAuthorization이 다른 어셈블리로 이동 됨

AspNetCore의 ASP.NET Core 2.2 및 `AddAuthorization` 하위 메서드는 다음과 같습니다.

* 이름이 변경 `AddAuthorizationCore`되었습니다.
* *AspNetCore*로 이동 되었습니다 .입니다.

*AspNetCore* 및 *AspNetCore* 를 모두 사용 하는 앱은 영향을 받지 않습니다.

*AspNetCore* 를 사용 하지 않는 앱은 다음 중 하나를 수행 해야 합니다.

* 사용으로 전환`AddAuthorizationCore`
* *AspNetCore*에 대 한 참조를 추가 합니다.

자세한 내용은 [다른 어셈블리 #386에 있는 오버 `AddAuthorization(o =>`로드의 주요 변경 내용](https://github.com/aspnet/Announcements/issues/386)을 참조 하세요.

## <a name="signalr"></a>SignalR

SignalR JavaScript 클라이언트가에서 `@aspnet/signalr` 로 `@microsoft/signalr`변경 되었습니다. 이 변경 내용에 반응 하려면 *package. json* 파일, `require` 문 및 ECMAScript `import` 문에서 참조를 변경 합니다.

### <a name="systemtextjson-is-the-default-protocol"></a>System.object는 기본 프로토콜입니다.

`System.Text.Json`는 이제 클라이언트와 서버 모두에서 사용 되는 기본 허브 프로토콜입니다.

에서 `Startup.ConfigureServices`를 호출 `AddJsonProtocol` 하 여 serializer 옵션을 설정 합니다.

**서버인**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.WriteIndented = false;
        })
```

**클라이언트:**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Newtonsoft.json로 전환 합니다.

`Newtonsoft.Json`에서 `Newtonsoft.Json` 지원되지않는기능을사용하는경우다음으로다시전환할수있습니다.`System.Text.Json`

1. AspNetCore. [SignalR NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) NuGet 패키지를 설치 합니다.
1. 클라이언트 `AddNewtonsoftJsonProtocol` 에서 메서드 호출 `HubConnectionBuilder` 을 인스턴스에 연결 합니다.

    ```csharp
    new HubConnectionBuilder()
        .WithUrl("/chatHub")
        .AddNewtonsoftJsonProtocol(...)
        .Build();
    ```

1. 서버 `AddNewtonsoftJsonProtocol` 에서 메서드 호출 `AddSignalR` 을의 `Startup.ConfigureServices`메서드 호출에 연결 합니다.

    ```csharp
    services.AddSignalR()
        .AddNewtonsoftJsonProtocol(...);
    ```

## <a name="opt-in-to-runtime-compilation"></a>런타임 컴파일 옵트인 (Opt in)

3\.0에서 런타임 컴파일은 옵트인 시나리오입니다. 런타임 컴파일을 사용 하도록 설정 하려면 <xref:mvc/views/view-compilation#runtime-compilation>을 참조 하세요.

## <a name="migrating-libraries-via-multi-targeting"></a>다중 대상을 통해 라이브러리 마이그레이션

라이브러리는 여러 버전의 ASP.NET Core을 지원 해야 하는 경우가 많습니다. 이전 버전의 ASP.NET Core에 대해 컴파일된 대부분의 라이브러리는 문제 없이 계속 작동 해야 합니다. 다음 조건에서는 앱을 교차 컴파일해야 합니다.

* 라이브러리는 이진이 [변경](#breaking-api-changes)된 기능을 사용 합니다.
* 라이브러리는 ASP.NET Core 3.0의 새로운 기능을 활용 하려고 합니다. 

예를 들어 다음과 같은 가치를 제공해야 합니다.

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

ASP.NET Core `#ifdefs` 3.0 관련 api를 사용 하도록 설정 하는 데 사용 합니다.

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#else if NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

## <a name="breaking-api-changes"></a>API 변경 내용 중단

* [ASP.NET Core 3.0 릴리스의 전체 주요 변경 내용 목록](https://github.com/aspnet/Announcements/issues?page=2&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [위조 방지, CORS, 진단, Mvc 및 라우팅을 방지 하기 위해 API 변경을 중단](https://github.com/aspnet/Announcements/issues/387)합니다. 이 목록에는 호환성 스위치에 대 한 주요 변경 내용이 포함 되어 있습니다.
* .NET Core, ASP.NET Core 및 Entity Framework Core 전체에서 2.2-3.0의 주요 변경 내용에 대 한 요약은 [버전 2.2에서 3.0로 마이그레이션에 대 한 주요 변경 내용](/dotnet/core/compatibility/2.2-3.0)을 참조 하세요.

## <a name="aspnet-core-30-not-currently-available-for-azure-app-service"></a>ASP.NET Core 3.0 Azure App Service 현재 사용할 수 없음

이를 곧 사용할 수 있도록 하는 것이 좋습니다. Azure App Service에서 ASP.NET Core 3.0를 사용할 수 있을 때까지 [Azure App Service에 ASP.NET Core preview 릴리스 배포](xref:host-and-deploy/azure-apps/index#deploy-aspnet-core-preview-release-to-azure-app-service)의 지침을 따르세요.

## <a name="mysqldataentityframeworkcore-currently-not-supported-on-aspnet-core-30"></a>Microsoft.entityframeworkcore.tools.dotnet는 ASP.NET Core 3.0에서 현재 지원 되지 않습니다.

자세한 내용은 [이 GitHub 문제](https://github.com/aspnet/EntityFrameworkCore/issues/17788)합니다.
