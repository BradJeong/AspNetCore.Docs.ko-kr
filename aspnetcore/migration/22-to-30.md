---
title: ASP.NET Core 2.2에서 3.0로 마이그레이션
author: rick-anderson
description: ASP.NET Core 2.2 프로젝트를 ASP.NET Core 3.0로 마이그레이션하는 방법에 대해 알아봅니다.
ms.author: riande
ms.custom: mvc
ms.date: 11/21/2019
no-loc:
- SignalR
uid: migration/22-to-30
ms.openlocfilehash: e65f4b6f680da89745ec9d4f9cc883cb2fd8892e
ms.sourcegitcommit: 3e503ef510008e77be6dd82ee79213c9f7b97607
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/22/2019
ms.locfileid: "74317323"
---
# <a name="migrate-from-aspnet-core-22-to-30"></a>ASP.NET Core 2.2에서 3.0로 마이그레이션

[Scott Addie](https://github.com/scottaddie) 및 [Rick Anderson](https://twitter.com/RickAndMSFT)

이 문서에서는 기존 ASP.NET Core 2.2 프로젝트를 ASP.NET Core 3.0로 업데이트 하는 방법을 설명 합니다.

## <a name="prerequisites"></a>전제 조건

# <a name="visual-studiotabvisual-studio"></a>[Visual Studio](#tab/visual-studio)

[!INCLUDE[](~/includes/net-core-prereqs-vs-3.0.md)]

# <a name="visual-studio-codetabvisual-studio-code"></a>[Visual Studio Code](#tab/visual-studio-code)

[!INCLUDE[](~/includes/net-core-prereqs-vsc-3.0.md)]

# <a name="visual-studio-for-mactabvisual-studio-mac"></a>[Visual Studio for Mac](#tab/visual-studio-mac)

[!INCLUDE[](~/includes/net-core-prereqs-mac-3.0.md)]

---

## <a name="update-net-core-sdk-version-in-globaljson"></a>global.json의 .NET Core SDK 버전 업데이트

솔루션이 특정 .NET Core SDK 버전을 대상으로 하는 [전역 json](/dotnet/core/tools/global-json) 파일을 사용 하는 경우 `version` 속성을 컴퓨터에 설치 된 3.0 버전으로 업데이트 합니다.

```json
{
  "sdk": {
    "version": "3.0.100"
  }
}
```

## <a name="update-the-project-file"></a>프로젝트 파일 업데이트

### <a name="update-the-target-framework"></a>대상 프레임 워크 업데이트

ASP.NET Core 3.0 이상 .NET Core 에서만 실행 됩니다. [TFM (대상 프레임 워크 모니커)](/dotnet/standard/frameworks) 를 `netcoreapp3.0`으로 설정 합니다.

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

### <a name="remove-obsolete-package-references"></a>사용 되지 않는 패키지 참조 제거

ASP.NET Core 3.0에 대해 많은 수의 NuGet 패키지가 생성 되지 않습니다. 이러한 패키지 참조는 프로젝트 파일에서 제거 해야 합니다. ASP.NET Core 2.2 웹 앱에 대 한 다음 프로젝트 파일을 고려 합니다.

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>netcoreapp2.2</TargetFramework>
    <AspNetCoreHostingModel>InProcess</AspNetCoreHostingModel>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.App"/>
    <PackageReference Include="Microsoft.AspNetCore.Razor.Design" Version="2.2.0" PrivateAssets="All" />
  </ItemGroup>

</Project>
```

ASP.NET Core 3.0에 대 한 업데이트 된 프로젝트 파일:

[!code-xml[](22-to-30/samples/Web1.csproj?highlight=4)]

업데이트 된 ASP.NET Core 3.0 프로젝트 파일:

* `<PropertyGroup>`에서 다음 단계를 수행합니다.
  * TFM를 `netcoreapp3.0` 업데이트 합니다.
  * `<AspNetCoreHostingModel>` 요소를 제거 합니다. 자세한 내용은이 문서의 [in-process 호스팅 모델](#in-process-hosting-model) 을 참조 하세요.

* `<ItemGroup>`에서 다음 단계를 수행합니다.
  * `Microsoft.AspNetCore.App` 제거 됩니다. 자세한 내용은이 문서의 [프레임 워크 참조](#framework-reference) 를 참조 하세요.
  * `Microsoft.AspNetCore.Razor.Design` 제거 되며 다음 패키지 목록에서 더 이상 생성 되지 않습니다.

더 이상 생성 되지 않는 패키지의 전체 목록을 보려면 다음 확장 목록을 선택 합니다.

<details>
    <summary>더 이상 생성 되지 않는 패키지 목록을 확장 하려면 클릭 하십시오.</summary>
    <ul>
        <li>Microsoft.AspNetCore</li>
        <li>Microsoft.AspNetCore.All</li>
        <li>Microsoft.AspNetCore.App</li>
        <li>Microsoft.AspNetCore.Antiforgery</li>
        <li>Microsoft.AspNetCore.Authentication</li>
        <li>Microsoft.AspNetCore.Authentication.Abstractions</li>
        <li>Microsoft.AspNetCore.Authentication.Cookies</li>
        <li>Microsoft.AspNetCore.Authentication.Core</li>
        <li>Microsoft.AspNetCore.Authentication.OAuth</li>
        <li>Microsoft.AspNetCore.Authorization.Policy</li>
        <li>Microsoft.AspNetCore.CookiePolicy</li>
        <li>Microsoft.AspNetCore.Cors</li>
        <li>Microsoft.AspNetCore.Diagnostics</li>
        <li>Microsoft.AspNetCore.Diagnostics.HealthChecks</li>
        <li>Microsoft.AspNetCore.HostFiltering</li>
        <li>Microsoft.AspNetCore.Hosting</li>
        <li>Microsoft.AspNetCore.Hosting.Abstractions</li>
        <li>Microsoft.AspNetCore.Hosting.Server.Abstractions</li>
        <li>Microsoft.AspNetCore.Http</li>
        <li>Microsoft.AspNetCore.Http.Abstractions</li>
        <li>Microsoft.AspNetCore.Http.Connections</li>
        <li>Microsoft.AspNetCore.Http.Extensions</li>
        <li>Microsoft.AspNetCore.HttpOverrides</li>
        <li>Microsoft.AspNetCore.HttpsPolicy</li>
        <li>Microsoft.AspNetCore.Identity</li>
        <li>Microsoft.AspNetCore.Localization</li>
        <li>Microsoft.AspNetCore.Localization.Routing</li>
        <li>Microsoft.AspNetCore.Mvc</li>
        <li>Microsoft.AspNetCore.Mvc.Abstractions</li>
        <li>Microsoft.AspNetCore.Mvc.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.ApiExplorer</li>
        <li>Microsoft.AspNetCore.Mvc.Api.Analyzers</li>
        <li>Microsoft.AspNetCore.Mvc.Core</li>
        <li>Microsoft.AspNetCore.Mvc.Cors</li>
        <li>Microsoft.AspNetCore.Mvc.DataAnnotations</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Json</li>
        <li>Microsoft.AspNetCore.Mvc.Formatters.Xml</li>
        <li>Microsoft.AspNetCore.Mvc.Localization</li>
        <li>Microsoft.AspNetCore.Mvc.Razor</li>
        <li>Microsoft.AspNetCore.Mvc.Razor.ViewCompilation</li>
        <li>Microsoft.AspNetCore.Mvc.RazorPages</li>
        <li>Microsoft.AspNetCore.Mvc.TagHelpers</li>
        <li>Microsoft.AspNetCore.Mvc.ViewFeatures</li>
        <li>Microsoft.AspNetCore.Razor</li>
        <li>Microsoft.AspNetCore.Razor.Runtime</li>
        <li>Microsoft.AspNetCore.Razor.Design</li>
        <li>Microsoft.AspNetCore.ResponseCaching</li>
        <li>Microsoft.AspNetCore.ResponseCaching.Abstractions</li>
        <li>Microsoft.AspNetCore.ResponseCompression</li>
        <li>Microsoft.AspNetCore.Rewrite</li>
        <li>Microsoft.AspNetCore.Routing</li>
        <li>Microsoft.AspNetCore.Routing.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.HttpSys</li>
        <li>Microsoft.AspNetCore.Server.IIS</li>
        <li>Microsoft.AspNetCore.Server.IISIntegration</li>
        <li>Microsoft.AspNetCore.Server.Kestrel</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Core</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Https</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions</li>
        <li>Microsoft.AspNetCore.Server.Kestrel.Transport.Sockets</li>
        <li>Microsoft.AspNetCore.Session</li>
        <li>AspNetCoreSignalR</li>
        <li>AspNetCoreSignalR. Core</li>
        <li>Microsoft.AspNetCore.StaticFiles</li>
        <li>Microsoft.AspNetCore.WebSockets</li>
        <li>Microsoft.AspNetCore.WebUtilities</li>
        <li>Microsoft.Net</li>
    </ul>
</details>

### <a name="review-breaking-changes"></a>주요 변경 내용 검토

[주요 변경 내용 검토](#break)

### <a name="framework-reference"></a>프레임 워크 참조

위에 나열 된 패키지 중 하나를 통해 사용할 수 있는 ASP.NET Core 기능은 `Microsoft.AspNetCore.App` 공유 프레임 워크의 일부로 제공 됩니다. *공유 프레임워크*는 머신에 설치된 어셈블리( *.dll* 파일) 세트이며 런타임 구성 요소 및 타기팅 팩을 포함합니다. 자세한 내용은 [공유 프레임워크](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/)를 참조하세요.

* `Microsoft.NET.Sdk.Web` SDK를 대상으로 하는 프로젝트는 `Microsoft.AspNetCore.App` 프레임워크를 암시적으로 참조합니다.

  이러한 프로젝트에는 추가 참조가 필요하지 않습니다.

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>
      ...
  </Project>
  ```

* `Microsoft.NET.Sdk` 또는 `Microsoft.NET.Sdk.Razor` SDK를 대상으로 하는 프로젝트는 `Microsoft.AspNetCore.App`에 명시적 `FrameworkReference`를 추가 해야 합니다.

  ```xml
  <Project Sdk="Microsoft.NET.Sdk.Razor">
    <PropertyGroup>
      <TargetFramework>netcoreapp3.0</TargetFramework>
    </PropertyGroup>

    <ItemGroup>
      <FrameworkReference Include="Microsoft.AspNetCore.App" />
    </ItemGroup>
      ...
  </Project>
  ```

#### <a name="framework-dependent-builds-using-docker"></a>Docker를 사용 하는 프레임 워크 종속 빌드

ASP.NET Core [공유 프레임 워크](https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/) 에 종속 된 패키지를 사용 하는 콘솔 앱의 프레임 워크 종속 빌드는 다음과 같은 런타임 오류를 제공할 수 있습니다.

```console
It was not possible to find any compatible framework version
The specified framework 'Microsoft.AspNetCore.App', version '3.0.0' was not found.
  - No frameworks were found.
```

`Microsoft.AspNetCore.App`은 ASP.NET Core 런타임을 포함 하는 공유 프레임 워크로 [dotnet/Core/aspnet](https://hub.docker.com/_/microsoft-dotnet-core-aspnet/) docker 이미지에만 있습니다. 3\.0 SDK는 공유 프레임 워크에서 사용할 수 있는 라이브러리의 중복 복사본을 포함 하지 않으므로 asp.net core를 사용 하 여 프레임 워크 종속 빌드의 크기를 줄입니다. 이는 최대 18MB의 잠재적 절감 효과를 제공 하지만 앱을 실행 하려면 ASP.NET Core 런타임을 설치/설치 해야 합니다.

앱에 ASP.NET Core 공유 프레임 워크에 대 한 종속성 (직접 또는 간접)이 있는지 확인 하려면 앱 빌드/게시 중에 생성 된 *runtimeconfig.template.json* 파일을 검사 합니다. 다음 JSON 파일은 ASP.NET Core 공유 프레임 워크에 대 한 종속성을 보여 줍니다.

```json
{
  "runtimeOptions": {
    "tfm": "netcoreapp3.0",
    "framework": {
      "name": "Microsoft.AspNetCore.App",
      "version": "3.0.0"
    },
    "configProperties": {
      "System.GC.Server": true
    }
  }
}
```

앱에서 docker를 사용 하는 경우 ASP.NET Core 3.0를 포함 하는 기본 이미지를 사용 합니다. 예를 들어, `docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0`을 입력합니다.

### <a name="add-package-references-for-removed-assemblies"></a>제거 되는 어셈블리에 대 한 패키지 참조 추가

ASP.NET Core 3.0는 이전에 `Microsoft.AspNetCore.App` 패키지 참조의 일부인 일부 어셈블리를 제거 합니다. 제거 된 어셈블리를 시각화 하려면 두 개의 공유 프레임 워크 폴더를 비교 합니다. 예를 들어 2.2.7 및 3.0.0 버전을 비교 합니다.

![공유 프레임 워크 어셈블리 비교](22-to-30/_static/assembly-diff.png)

제거 된 어셈블리에서 제공 하는 기능을 계속 사용 하려면 해당 패키지의 3.0 버전을 참조 하세요.

* **개별 사용자 계정을** 포함 하는 템플릿 생성 웹 앱에는 다음 패키지를 추가 해야 합니다.

  [!code-xml[](22-to-30/samples/WebFull.csproj?highlight=9-13)]

* [Microsoft.entityframeworkcore.tools.dotnet](https://www.nuget.org/packages/Microsoft.EntityFrameworkCore)

  데이터베이스 공급자 관련 패키지를 참조 하는 방법에 대 한 자세한 내용은 [데이터베이스 공급자](/ef/core/providers/index)를 참조 하세요.

* Id UI

  [AspNetCore](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity.UI) 패키지를 참조 하 여 [id ui](xref:security/authentication/identity) 에 대 한 지원을 추가할 수 있습니다.

* SPA 서비스

  * [Microsoft.AspNetCore.SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices)
  * [AspNetCore. SpaServices](https://www.nuget.org/packages/Microsoft.AspNetCore.SpaServices.Extensions)

* 타사 인증 흐름에 대 한 인증 &ndash; 지원은 NuGet 패키지로 제공 됩니다.

  * Facebook OAuth ([AspNetCore](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Facebook))
  * Google OAuth ([AspNetCore](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Google))
  * Microsoft 계정 인증 ([AspNetCore. MicrosoftAccount](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.MicrosoftAccount))
  * Openid connect Connect 인증 ([AspNetCore connect](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.OpenIdConnect))
  * Openid connect Connect 전달자 토큰 ([AspNetCore. JwtBearer](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer))
  * Twitter OAuth ([AspNetCore](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Twitter))
  * WsFederation 인증 ([AspNetCore WsFederation](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.WsFederation))

* [WebApi](https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Client/) NuGet 패키지 `System.Net.HttpClient` &ndash;에 대 한 서식 및 콘텐츠 협상 지원은 `ReadAsAsync` 및 `PostJsonAsync`와 같은 api를 사용 하 여 `System.Net.HttpClient` 하는 데 유용한 확장성을 제공 합니다.

* Razor 런타임 컴파일 &ndash; Razor 뷰 및 페이지의 런타임 컴파일을 지원 합니다. [RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation)의 일부입니다.

* Mvc에서 mvc를 사용할 수 있도록 지원 [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson)의 일부입니다. `Newtonsoft.Json` &ndash; `Newtonsoft.Json`

## <a name="startup-changes"></a>시작 변경

다음 이미지는 ASP.NET Core 2.2 Razor Pages 웹 앱에서 삭제 되 고 변경 된 줄을 보여 줍니다.

![ASP.NET Core 2.2 Razor 웹 앱에서 삭제 및 변경 된 줄](22-to-30/_static/startup2.2.png)

위의 그림에서 삭제 된 코드는 빨강으로 표시 됩니다. 삭제 된 코드는 파일을 비교 하기 전에 삭제 된 쿠키 옵션 코드를 표시 하지 않습니다.

다음 이미지는 ASP.NET Core 3.0 Razor Pages 웹 앱에서 추가 및 변경 된 줄을 보여 줍니다.

![ASP.NET Core 3.0 Razor 웹 앱에서 추가 및 변경 된 줄](22-to-30/_static/startup3.0.png)

위의 그림에서 추가 된 코드는 녹색으로 표시 됩니다. 다음 변경 내용에 대 한 정보:

* `services.AddRazorPages``services.AddMvc`이 문서의 [MVC 서비스 등록](#mvc-service-registration) 을 참조 하세요.
* `CompatibilityVersion`<xref:mvc/compatibility-version>를 참조 하세요.
* `IWebHostEnvironment``IHostingEnvironment` [이 GitHub 공지](https://github.com/aspnet/AspNetCore/issues/7749)를 참조 하세요.
* `app.UseAuthorization` 권한 부여 미들웨어를 추가 해야 하는 순서를 보여 주기 위해 템플릿에 추가 되었습니다. 앱에서 권한 부여를 사용 하지 않는 경우 `app.UseAuthorization`에 대 한 호출을 안전 하 게 제거할 수 있습니다.
* `app.UseEndpoints`이 문서의 [Razor Pages](#razor-pages) 또는 [마이그레이션 시작. 구성](#migrate-startupconfigure) 을 참조 하세요.

### <a name="analyzer-support"></a>분석기 지원

AspNetCore 패키지의 `Microsoft.NET.Sdk.Web` 일부로 이전에 제공 된 분석기를 암시적으로 [Microsoft.AspNetCore.Mvc.Analyzers](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Analyzers/) 참조 하는 프로젝트입니다. 이러한 기능을 사용 하도록 설정 하는 데 필요한 추가 참조는 없습니다.

앱이 이전에 [AspNetCore](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Api.Analyzers/) 패키지를 사용 하 여 제공한 [API 분석기](xref:web-api/advanced/analyzers) 를 사용 하는 경우 .net Core 웹 SDK의 일부로 제공 되는 분석기를 참조 하도록 프로젝트 파일을 편집 합니다.

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
    <PropertyGroup>
        <TargetFramework>netcoreapp3.0</TargetFramework>
        <IncludeOpenAPIAnalyzers>true</IncludeOpenAPIAnalyzers>
    </PropertyGroup>

    ...
</Project>
```

### <a name="razor-class-library"></a>Razor 클래스 라이브러리

MVC에 대 한 UI 구성 요소를 제공 하는 Razor 클래스 라이브러리 프로젝트는 프로젝트 파일에서 `AddRazorSupportForMvc` 속성을 설정 해야 합니다.

```xml
<PropertyGroup>
  <AddRazorSupportForMvc>true</AddRazorSupportForMvc>
</PropertyGroup>
```

### <a name="in-process-hosting-model"></a>In-Process 호스팅 모델

프로젝트는 ASP.NET Core 3.0 이상에서 [in-process 호스팅 모델로](xref:host-and-deploy/aspnet-core-module#in-process-hosting-model) 기본 됩니다. 해당 값이 `InProcess`경우 프로젝트 파일에서 `<AspNetCoreHostingModel>` 속성을 선택적으로 제거할 수 있습니다.

## <a name="kestrel"></a>Kestrel

### <a name="configuration"></a>Configuration

*Program.cs*(`ConfigureWebHostDefaults`에서 제공 하는 웹 호스트 작성기로 Kestrel 구성 마이그레이션:

```csharp
public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.ConfigureKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseStartup<Startup>();
        });
```

앱이 `HostBuilder`를 사용 하 여 호스트를 수동으로 만드는 경우 `ConfigureWebHostDefaults`에서 웹 호스트 작성기의 `UseKestrel`를 호출 합니다.

```csharp
public static void Main(string[] args)
{
    var host = new HostBuilder()
        .UseContentRoot(Directory.GetCurrentDirectory())
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.UseKestrel(serverOptions =>
            {
                // Set properties and call methods on options
            })
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
}
```

### <a name="connection-middleware-replaces-connection-adapters"></a>연결의 미들웨어가 연결 어댑터를 대체 합니다.

연결 어댑터 (`Microsoft.AspNetCore.Server.Kestrel.Core.Adapter.Internal.IConnectionAdapter`)가 Kestrel에서 제거 되었습니다. 연결 어댑터를 연결 미들웨어로 대체 합니다. 연결 미들웨어는 ASP.NET Core 파이프라인의 HTTP 미들웨어와 유사 하지만 하위 수준 연결의 경우입니다. HTTPS 및 연결 로깅:

* 연결 어댑터에서 연결 미들웨어로 이동 되었습니다.
* 이러한 확장 메서드는 이전 버전의 ASP.NET Core와 동일 하 게 작동 합니다. 

자세한 내용은 [Kestrel 문서의 ListenOptions 섹션에서 TlsFilterConnectionHandler 예](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#listenoptionsprotocols)를 참조 하세요.

### <a name="transport-abstractions-moved-and-made-public"></a>전송 추상화 이동 및 공개

Kestrel 전송 계층이 `Connections.Abstractions`에서 공용 인터페이스로 공개되었습니다. 이러한 업데이트의 일부로:

* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions` 및 관련 형식이 제거 되었습니다.
* <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions.NoDelay> <xref:Microsoft.AspNetCore.Server.Kestrel.Core.ListenOptions> 전송 옵션으로 이동 되었습니다.
* `Microsoft.AspNetCore.Server.Kestrel.Transport.Abstractions.Internal.SchedulingMode` <xref:Microsoft.AspNetCore.Server.Kestrel.KestrelServerOptions>에서 제거 되었습니다.

자세한 내용은 다음 GitHub 리소스를 참조 하세요.

* [클라이언트/서버 네트워킹 추상화 (aspnet/AspNetCore #10308)](https://github.com/aspnet/AspNetCore/issues/10308)
* [새 bedrock 수신기 추상화를 구현 하 고 맨 위에 cross-plat Kestrel을 구현 합니다 (aspnet/AspNetCore #10321).](https://github.com/aspnet/AspNetCore/pull/10321)

### <a name="kestrel-request-trailer-headers"></a>Kestrel 요청 트레일러 헤더

이전 버전의 ASP.NET Core를 대상으로 하는 앱의 경우:

* Kestrel은 HTTP/1.1 청크 분할 트레일러 헤더를 요청 헤더 컬렉션에 추가 합니다.
* 트레일러는 요청 본문을 끝으로 읽은 후에 사용할 수 있습니다.

이로 인해 헤더와 트레일러 간의 모호성에 대 한 우려 사항이 발생 하므로, 3.0에서 트레일러가 새 컬렉션 (`RequestTrailerExtensions`)으로 이동 되었습니다.

HTTP/2 요청 트레일러는 다음과 같습니다.

* ASP.NET Core 2.2에서는 사용할 수 없습니다.
* `RequestTrailerExtensions`로 3.0에서 사용할 수 있습니다.

이러한 트레일러에 액세스 하기 위한 새 요청 확장 메서드가 있습니다. HTTP/1.1과 마찬가지로 트레일러는 요청 본문을 끝까지 읽은 후에 사용할 수 있습니다.

3\.0 릴리스의 경우 다음 `RequestTrailerExtensions` 메서드를 사용할 수 있습니다.

* `GetDeclaredTrailers` &ndash; 본문 후에 사용할 트레일러를 나열 하는 요청 `Trailer` 헤더를 가져옵니다.
* `SupportsTrailers` &ndash; 요청에서 트레일러 헤더 수신을 지원 하는지 여부를 나타냅니다.
* `CheckTrailersAvailable` &ndash;는 요청에서 트레일러를 지원 하 고 읽을 수 있는지 여부를 확인 합니다. 이 검사는 읽을 후행이 있다고 가정 하지 않습니다. 이 메서드에서 `true`을 반환 하더라도 읽을 트레일러가 없을 수 있습니다.
* 응답에서 요청 된 후행 헤더를 가져오는 `GetTrailer` &ndash;입니다. `GetTrailer`를 호출 하기 전에 `SupportsTrailers` 확인 하거나 요청이 후행 헤더를 지원 하지 않는 경우 <xref:System.NotSupportedException> 발생할 수 있습니다.

자세한 내용은 [별도의 컬렉션에 요청 트레일러 배치 (aspnet/AspNetCore #10410)](https://github.com/aspnet/AspNetCore/pull/10410)를 참조 하세요.

### <a name="allowsynchronousio-disabled"></a>AllowSynchronousIO 사용 안 함

`AllowSynchronousIO` `HttpRequest.Body.Read`, `HttpResponse.Body.Write`, `Stream.Flush`등의 동기 IO Api를 사용 하거나 사용 하지 않도록 설정 합니다. 이러한 Api는 앱 작동 중단에 대 한 스레드 고갈의 소스입니다. 3\.0에서 `AllowSynchronousIO`는 기본적으로 사용하지 않도록 설정됩니다. 자세한 내용은 [Kestrel 문서의 동기 IO 섹션](/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.0#synchronous-io)을 참조 하세요.

동기 IO가 필요한 경우에는 사용 중인 서버에서 `AllowSynchronousIO` 옵션을 구성 하 여 사용할 수 있습니다 (예: Kestrel을 사용 하는 경우 `ConfigureKestrel`를 호출할 때). 서버 (Kestrel, HttpSys, TestServer 등)에는 다른 서버에 영향을 주지 않는 자체 `AllowSynchronousIO` 옵션이 있습니다. `IHttpBodyControlFeature.AllowSynchronousIO` 옵션을 사용 하 여 요청 별로 모든 서버에 대해 동기 IO를 사용 하도록 설정할 수 있습니다.

```csharp
var syncIOFeature = HttpContext.Features.Get<IHttpBodyControlFeature>();

if (syncIOFeature != null)
{
    syncIOFeature.AllowSynchronousIO = true;
}
```

[Dispose](/dotnet/standard/garbage-collection/implementing-dispose) 에서 동기 api를 <xref:System.IO.TextWriter> 호출 하는 다른 스트림이나 구현에 문제가 있는 경우 대신 새 <xref:System.IO.Stream.DisposeAsync*> API를 호출 합니다.

자세한 내용은 [[알림] AllowSynchronousIO disabled in all servers (aspnet/AspNetCore #7644)](https://github.com/aspnet/AspNetCore/issues/7644)를 참조 하세요.

### <a name="microsoftaspnetcoreserverkestrelhttps-assembly-removed"></a>AspNetCore 어셈블리를 제거 했습니다.

ASP.NET Core 2.1에서는 *AspNetCore* 의 내용이 *AspNetCore*로 이동 되었습니다... n a m .dll. n a m .dll. `TypeForwardedTo` 특성을 사용 하는 주요 업데이트가 아닙니다. 3\.0의 경우 빈 *AspNetCore* 어셈블리 및 NuGet 패키지는 제거 되었습니다 (예를 들어,

[AspNetCore](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) 를 참조 하는 라이브러리는 ASP.NET Core 종속성을 2.1 이상으로 업데이트 해야 합니다.

ASP.NET Core 2.1 이상을 대상으로 하는 앱 및 라이브러리는 [AspNetCore](https://www.nuget.org/packages/Microsoft.AspNetCore.Server.Kestrel.Https) 패키지에 대 한 직접 참조를 모두 제거 해야 합니다.

## <a name="jsonnet-support"></a>Json.NET 지원

[ASP.NET Core 공유 프레임 워크를 개선](https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/)하는 작업의 일환으로 ASP.NET Core 공유 프레임 워크에서 [Json.NET](https://www.newtonsoft.com/json/help/html/Introduction.htm) 이 제거 되었습니다.

ASP.NET Core에 대 한 기본값은 [이제 .Net](/dotnet/api/system.text.json?view=netcore-3.0)Core 3.0의 새로운 system.string입니다. 가능 하면 `System.Text.Json`를 사용 하는 것이 좋습니다. 고성능 이며 추가 라이브러리 종속성이 필요 하지 않습니다. 그러나 `System.Text.Json`는 새로운 기능 이므로 현재 앱에 필요한 기능이 없을 수 있습니다.

JsonPatch 또는 변환기와 같은 `Newtonsoft.Json`특정 기능을 사용 하거나 `Newtonsoft.Json`특정 형식의 [형식을 지정](xref:web-api/advanced/formatting) 하는 경우 앱 `Newtonsoft.Json` 통합이 필요할 수 있습니다.

ASP.NET Core 3.0 SignalR 프로젝트에서 Json.NET를 사용 하려면이 문서에서 [newtonsoft.json로 전환](#switch-to-newtonsoftjson) 을 참조 하세요.

ASP.NET Core 3.0 프로젝트에서 Json.NET를 사용 하려면 다음을 수행 합니다.

* [Microsoft.AspNetCore.Mvc.NewtonsoftJson](https://nuget.org/packages/Microsoft.AspNetCore.Mvc.NewtonsoftJson)에 패키지 참조를 추가합니다.
* `AddNewtonsoftJson`를 호출 `Startup.ConfigureServices`를 업데이트 합니다.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson();
  ```

  `AddNewtonsoftJson`은 새로운 MVC 서비스 등록 방법과 호환 됩니다.

  * `AddRazorPages`
  * `AddControllersWithViews`
  * `AddControllers`

  ```csharp
  services.AddControllers()
      .AddNewtonsoftJson();
  ```

  Json.NET 설정은 `AddNewtonsoftJson`호출에서 설정할 수 있습니다.

  ```csharp
  services.AddMvc()
      .AddNewtonsoftJson(options =>
             options.SerializerSettings.ContractResolver =
                new CamelCasePropertyNamesContractResolver());
  ```

## <a name="mvc-service-registration"></a>MVC 서비스 등록

ASP.NET Core 3.0는 `Startup.ConfigureServices`내에서 MVC 시나리오를 등록 하기 위한 새 옵션을 추가 합니다.

`IServiceCollection`에서 MVC 시나리오와 관련 된 세 가지 새로운 최상위 확장 메서드를 사용할 수 있습니다. 템플릿에서는 `AddMvc`대신 이러한 새 메서드를 사용 합니다. 그러나 `AddMvc`은 이전 릴리스와 동일 하 게 계속 작동 합니다.

다음 예에서는 뷰 또는 페이지가 아니라 컨트롤러 및 API 관련 기능에 대 한 지원을 추가 합니다. API 템플릿에서는 다음 코드를 사용 합니다.

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllers();
}
```

다음 예에서는 컨트롤러, API 관련 기능 및 보기에 대 한 지원을 추가 하지만 페이지는 추가 하지 않습니다. 웹 응용 프로그램 (MVC) 템플릿은 다음 코드를 사용 합니다.

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
}
```

다음 예에서는 Razor Pages 및 최소 컨트롤러 지원에 대 한 지원을 추가 합니다. 웹 응용 프로그램 템플릿은 다음 코드를 사용 합니다.

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddRazorPages();
}
```

새 메서드를 결합할 수도 있습니다. 다음 예제는 2.2 ASP.NET Core에서 `AddMvc`를 호출 하는 것과 같습니다.

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddRazorPages();
}
```

## <a name="routing-startup-code"></a>시작 코드 라우팅

앱이 `UseMvc` 또는 `UseSignalR`를 호출 하는 경우 가능 하면 앱을 [끝점 라우팅](xref:fundamentals/routing) 으로 마이그레이션합니다. 이전 버전의 MVC와의 끝점 라우팅 호환성을 개선 하기 위해 ASP.NET Core 2.2에서 도입 된 URL 생성의 일부 변경 내용을 되돌렸습니다. 2\.2에서 끝점 라우팅을 사용 하는 데 문제가 발생 한 경우 다음과 같은 예외를 제외 하 고 ASP.NET Core 3.0에서 향상 된 기능을 사용할 수 있습니다.

* 앱이 `IRouter`를 구현 하거나 `Route`에서 상속 되는 경우 [DynamicRouteValuesTransformer](https://github.com/aspnet/AspNetCore.Docs/issues/12997) 를 대체 항목으로 사용 합니다.

* 앱이 MVC 내의 `RouteData.Routers`에 직접 액세스 하 여 Url을 구문 분석 하는 경우이를 `LinkParser.ParsePathByEndpointName`사용으로 바꿀 수 있습니다. 
 * 경로 이름을 사용 하 여 경로를 정의 합니다.
 * `LinkParser.ParsePathByEndpointName`를 사용 하 여 원하는 경로 이름을 전달 합니다.

끝점 라우팅은 `IRouter`와 동일한 경로 패턴 구문 및 경로 패턴 작성 기능을 지원 합니다. 끝점 라우팅은 `IRouteConstraint`을 지원 합니다. 끝점 라우팅은 `[Route]`, `[HttpGet]`및 기타 MVC 라우팅 특성을 지원 합니다.

대부분의 응용 프로그램에서는 `Startup`만 변경 해야 합니다.

### <a name="migrate-startupconfigure"></a>마이그레이션 시작. 구성

일반 권장 사항:

* `UseRouting`를 추가합니다.
* 앱이 `UseStaticFiles`를 호출 하는 경우 `UseRouting`**앞** 에 `UseStaticFiles`를 놓습니다.
* 앱이 `AuthorizePage` 또는 `[Authorize]`와 같은 인증/권한 부여 기능을 사용 하는 경우 **호출을 `UseAuthentication`** 및 `UseAuthorization`에 저장 합니다 `UseRouting`.

  ```csharp
  public void Configure(IApplicationBuilder app)
  {
    ...

    app.UseStaticFiles();

    app.UseRouting();
    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints => {
       endpoints.MapControllers();
    });
  ```

* `UseMvc` 또는 `UseSignalR`을 `UseEndpoints`바꿉니다.
* 앱에서 `[EnableCors]`와 같은 [cors](xref:security/cors) 시나리오를 사용 하는 경우 cors를 사용 하는 다른 미들웨어 앞에 `UseCors`에 대 한 호출을 추가 합니다 (예: `UseAuthentication`, `UseAuthorization`및 `UseEndpoints`앞에 `UseCors` 두기).
* `IHostingEnvironment`을 `IWebHostEnvironment`로 바꾸고 <xref:Microsoft.Extensions.Hosting?displayProperty=fullName> 네임 스페이스에 대 한 `using` 문을 추가 합니다.
* `IApplicationLifetime`를 <xref:Microsoft.Extensions.Hosting.IHostApplicationLifetime> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> 네임 스페이스)로 바꿉니다.
* `EnvironmentName`를 <xref:Microsoft.Extensions.Hosting.Environments> (<xref:Microsoft.Extensions.Hosting?displayProperty=fullName> 네임 스페이스)로 바꿉니다.

다음 코드는 일반적인 ASP.NET Core 2.2 앱의 `Startup.Configure`에 대 한 예입니다.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseAuthentication();

    app.UseSignalR(hubs =>
    {
        hubs.MapHub<ChatHub>("/chat");
    });

    app.UseMvc(routes =>
    {
        routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

이전 `Startup.Configure` 코드를 업데이트 한 후:

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseStaticFiles();

    app.UseRouting();

    app.UseCors();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>("/chat");
        endpoints.MapControllerRoute("default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

> [!WARNING]
> 대부분의 앱에서 `UseAuthentication`, `UseAuthorization`및 `UseCors`에 대 한 호출은 `UseRouting`에 대 한 호출 및 `UseEndpoints` 적용 사이에 나타나야 합니다.

### <a name="health-checks"></a>상태 검사

상태 검사는 제네릭 호스트와의 엔드포인트 라우팅을 사용합니다. `Startup.Configure`에서 엔드포인트 URL 또는 상대 경로를 사용하여 엔드포인트 작성기에 `MapHealthChecks`를 호출합니다.

```csharp
app.UseEndpoints(endpoints =>
{
    endpoints.MapHealthChecks("/health");
});
```

상태 검사 엔드포인트는 다음을 수행할 수 있습니다.

* 허용되는 호스트/포트를 하나 이상 지정합니다.
* 권한 부여가 필요합니다.
* CORS가 필요합니다.

자세한 내용은 <xref:host-and-deploy/health-checks>을 참조하세요.

### <a name="security-middleware-guidance"></a>보안 미들웨어 지침

권한 부여 및 CORS에 대 한 지원은 [미들웨어](xref:fundamentals/middleware/index) 접근 방식에 통합 됩니다. 이를 통해 이러한 시나리오에서 동일한 미들웨어 및 기능을 사용할 수 있습니다. 업데이트 된 권한 부여 미들웨어는이 릴리스에서 제공 되며, CORS 미들웨어는 MVC 컨트롤러에서 사용 하는 특성을 이해할 수 있도록 향상 되었습니다.

#### <a name="cors"></a>용

이전에 CORS는 구성 하기가 어려울 수 있습니다. 미들웨어는 일부 사용 사례에서 사용할 수 있도록 제공 되었지만 다른 사용 사례에서 미들웨어 **없이** 사용 하기 위한 MVC 필터입니다. ASP.NET Core 3.0를 사용 하는 경우 CORS가 필요한 모든 앱은 끝점 라우팅과 함께 CORS 미들웨어를 사용 하는 것이 좋습니다. `UseCors`은 기본 정책을 사용 하 여 제공 될 수 있으며, `[EnableCors]` 및 `[DisableCors]` 특성은 필요한 경우 기본 정책을 재정의 하는 데 사용할 수 있습니다.

다음 예제에서는

* CORS는 `default` 명명 된 정책을 사용 하는 모든 끝점에 대해 사용 하도록 설정 됩니다.
* `MyController` 클래스는 `[DisableCors]` 특성을 사용 하 여 CORS를 사용 하지 않도록 설정 합니다.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseCors("default");

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[DisableCors]
public class MyController : ControllerBase
{
    ...
}
```

#### <a name="authorization"></a>Authorization

이전 버전의 ASP.NET Core에서는 `[Authorize]` 특성을 통해 권한 부여 지원이 제공 되었습니다. 권한 부여 미들웨어를 사용할 수 없습니다. ASP.NET Core 3.0에서는 권한 부여 미들웨어가 필요 합니다. `UseAuthentication`직후에`UseAuthorization`(ASP.NET Core 권한 부여 미들웨어)를 배치 하는 것이 좋습니다. 권한 부여 미들웨어는 재정의 될 수 있는 기본 정책으로 구성 될 수도 있습니다.

ASP.NET Core 3.0 이상에서는 `Startup.Configure`에서 `UseAuthorization`를 호출 하 고 다음 `HomeController`에 로그인 한 사용자가 필요 합니다.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

public class HomeController : ControllerBase
{
    [Authorize]
    public IActionResult BuyWidgets()
    {
        ...
    }
}
```

앱이 MVC에서 `AuthorizeFilter`를 전역 필터로 사용 하는 경우 `AddAuthorization`호출에서 정책을 제공 하도록 코드를 리팩터링 하는 것이 좋습니다.

`DefaultPolicy`는 처음에 인증을 요구 하도록 구성 되므로 추가 구성이 필요 하지 않습니다. 다음 예제에서 MVC 끝점은 `RequireAuthorization`으로 표시 되므로 모든 요청은 `DefaultPolicy`을 기반으로 권한을 부여 해야 합니다. 그러나 `HomeController` `[AllowAnonymous]`으로 인해 사용자가 앱에 로그인 하지 않아도 액세스할 수 있습니다.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

정책을 사용자 지정할 수도 있습니다. 이전 예제를 기반으로 하 여 `DefaultPolicy` 인증 및 특정 범위를 요구 하도록 구성 됩니다.

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.DefaultPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute().RequireAuthorization();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

또는 `FallbackPolicy`를 구성 하 여 `[Authorize]` 하거나 `RequireAuthorization` 하지 않고 권한 부여를 요구 하도록 모든 끝점을 구성할 수 있습니다. `FallbackPolicy` `DefaultPolicy`와 다릅니다. `DefaultPolicy`은 `[Authorize]` 또는 `RequireAuthorization`에서 트리거되고 다른 정책이 설정 되지 않은 경우에도 `FallbackPolicy` 트리거됩니다. `FallbackPolicy`는 처음에 권한 부여 없이 요청을 허용 하도록 구성 됩니다.

다음 예제는 앞의 `DefaultPolicy` 예제와 동일 하지만 `FallbackPolicy`를 사용 하 여 `[AllowAnonymous]` 지정 된 경우를 제외 하 고 모든 끝점에서 항상 인증을 요구 합니다.

```csharp
public void ConfigureServices(IServiceCollection services)
{
    ...

    services.AddAuthorization(options =>
    {
        options.FallbackPolicy = new AuthorizationPolicyBuilder()
          .RequireAuthenticatedUser()
          .Build();
    });
}

public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapDefaultControllerRoute();
    });
}

[AllowAnonymous]
public class HomeController : ControllerBase
{
    ...
}
```

미들웨어 별 권한 부여는 권한 부여에 대 한 특정 지식이 없는 프레임 워크 없이 작동 합니다. 예를 들어 [상태 검사](xref:host-and-deploy/health-checks) 에는 권한 부여에 대 한 특정 지식이 없지만 상태 검사에는 미들웨어에서 적용 되는 구성 가능한 권한 부여 정책이 있을 수 있습니다.

또한 각 끝점은 권한 부여 요구 사항을 사용자 지정할 수 있습니다. 다음 예제에서 `UseAuthorization`는 `DefaultPolicy`권한 부여를 처리 하지만 `/healthz` health check 끝점에는 `admin` 사용자가 필요 합니다.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseAuthentication();
    app.UseAuthorization();

    app.UseEndpoints(endpoints =>
    {
        endpoints
            .MapHealthChecks("/healthz")
            .RequireAuthorization(new AuthorizeAttribute(){ Roles = "admin", });
    });
}
```

보호는 일부 시나리오에 대해 구현 됩니다. 누락 된 미들웨어로 인해 권한 부여 또는 CORS 정책을 건너뛰면 끝점 미들웨어는 예외를 throw 합니다. 구성 오류에 대 한 추가 피드백을 제공 하는 분석기 지원이 진행 중입니다.

#### <a name="custom-authorization-handlers"></a>사용자 지정 권한 부여 처리기

앱에서 사용자 지정 [권한 부여 처리기](xref:security/authorization/policies#authorization-handlers)를 사용 하는 경우 끝점 라우팅은 다른 리소스 형식을 MVC가 아닌 처리기에 전달 합니다. 권한 부여 처리기 컨텍스트 리소스를 <xref:Microsoft.AspNetCore.Mvc.Filters.AuthorizationFilterContext> 형식 ( [MVC 필터로 제공](xref:security/authorization/policies#accessing-mvc-request-context-in-handlers)된 리소스 형식)으로 간주 하는 처리기는 <xref:Microsoft.AspNetCore.Routing.RouteEndpoint> 형식의 리소스 (끝점 라우팅을 통해 권한 부여 처리기에 지정 된 리소스 형식)를 처리 하도록 업데이트 해야 합니다.

MVC는 여전히 `AuthorizationFilterContext` 리소스를 사용 하므로 앱에서 끝점 라우팅 권한 부여와 함께 MVC 권한 부여 필터를 사용 하는 경우 두 가지 유형의 리소스를 모두 처리 해야 할 수 있습니다.

### SignalR

SignalR 허브 매핑은 이제 `UseEndpoints`내에서 수행 됩니다.

`MapHub`에 각 허브를 매핑합니다. 이전 버전과 마찬가지로 각 허브는 명시적으로 나열 됩니다.

다음 예에서는 `ChatHub` SignalR hub에 대 한 지원이 추가 되었습니다.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHub<ChatHub>();
    });
}
```

클라이언트에서 메시지 크기 제한을 제어 하는 새로운 옵션이 있습니다. 예를 들어 `Startup.ConfigureServices`에서 다음을 수행 합니다.

```csharp
services.AddSignalR(hubOptions =>
{
    hubOptions.MaximumReceiveMessageSize = 32768;
});
```

ASP.NET Core 2.2에서 `TransportMaxBufferSize`를 설정 하 여 최대 메시지 크기를 효과적으로 제어할 수 있습니다. ASP.NET Core 3.0에서이 옵션은 이제는 백 압력이 관찰 되기 전의 최대 크기만 제어 합니다.

### <a name="mvc-controllers"></a>MVC 컨트롤러

이제 컨트롤러 매핑은 `UseEndpoints`내에서 발생 합니다.

앱에서 특성 라우팅을 사용 하는 경우 `MapControllers`를 추가 합니다. 라우팅은 ASP.NET Core 3.0 이상에서 많은 프레임 워크에 대 한 지원을 포함 하기 때문에 특성으로 라우팅된 컨트롤러를 추가 하는 것은 옵트인 (opt in)입니다.

다음을 바꿉니다.

* `MapControllerRoute` `MapRoute`
* `MapAreaControllerRoute` `MapAreaRoute`

라우팅은 이제 MVC 이상에 대 한 지원을 포함 하므로 이러한 메서드가 수행 하는 작업을 명확 하 게 나타내도록 용어가 변경 되었습니다. `MapControllerRoute`/`MapAreaControllerRoute`/`MapDefaultControllerRoute` 등의 기존 경로는 추가 된 순서 대로 적용 됩니다. 먼저 특정 경로 (예: 영역에 대 한 경로)를 추가 합니다.

다음 예제에서는

* `MapControllers`는 특성 라우트된 컨트롤러에 대 한 지원을 추가 합니다.
* `MapAreaControllerRoute`는 영역의 컨트롤러에 대 한 기본 경로를 추가 합니다.
* `MapControllerRoute` 컨트롤러에 대 한 기본 경로를 추가 합니다.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapControllers();
        endpoints.MapAreaControllerRoute(
            "admin",
            "admin",
            "Admin/{controller=Home}/{action=Index}/{id?}");
        endpoints.MapControllerRoute(
            "default", "{controller=Home}/{action=Index}/{id?}");
    });
}
```

#### <a name="async-suffix-removal-from-controller-action-names"></a>컨트롤러 작업 이름에서 비동기 접미사 제거

ASP.NET Core 3.0에서 ASP.NET Core MVC는 컨트롤러 작업 이름에서 `Async` 접미사를 제거 합니다. 라우팅 및 링크 생성은 모두이 새 기본값의 영향을 받습니다. 예를 들어 다음과 같은 가치를 제공해야 합니다.

```csharp
public class ProductsController : Controller
{
    public async Task<IActionResult> ListAsync()
    {
        var model = await _dbContext.Products.ToListAsync();
        return View(model);
    }
}
```

ASP.NET Core 3.0 이전:

* 이전 작업은 *Products/ListAsync* 경로에서 액세스할 수 있습니다.
* `Async` 접미사를 지정 하는 데 필요한 링크가 생성 되었습니다. 예를 들어 다음과 같은 가치를 제공해야 합니다.

    ```cshtml
    <a asp-controller="Products" asp-action="ListAsync">List</a>
    ```

ASP.NET Core 3.0:

* 이전 작업은 *제품/목록* 경로에서 액세스할 수 있습니다.
* 링크 생성에 `Async` 접미사를 지정할 필요가 없습니다. 예를 들어 다음과 같은 가치를 제공해야 합니다.

    ```cshtml
    <a asp-controller="Products" asp-action="List">List</a>
    ```

이 변경 내용은 [[ActionName]](/dotnet/api/microsoft.aspnetcore.mvc.actionnameattribute) 특성을 사용 하 여 지정 된 이름에는 영향을 주지 않습니다. `Startup.ConfigureServices`에서 다음 코드를 사용 하 여 기본 동작을 사용 하지 않도록 설정할 수 있습니다.

```csharp
services.AddMvc(options =>
    options.SuppressAsyncSuffixInActionNames = false);
```

#### <a name="changes-to-link-generation"></a>링크 생성에 대 한 변경 내용

[이전 라우팅 버전의 차이점](xref:fundamentals/routing#differences-from-earlier-versions-of-routing)에 대 한 설명서에 설명 된 것 처럼 링크 생성에는 몇 가지 차이점이 있습니다 (예: `Url.Link` 및 유사한 api 사용). 이러한 개체는 다음과 같습니다.

* 기본적으로 끝점 라우팅을 사용 하는 경우 생성 된 Uri에서 경로 매개 변수의 대/소문자가 유지 되지 않을 수 있습니다. 이 동작은 `IOutboundParameterTransformer` 인터페이스를 사용 하 여 제어할 수 있습니다.
* 잘못 된 경로 (존재 하지 않는 컨트롤러/작업 또는 페이지)에 대 한 URI를 생성 하면 잘못 된 URI를 생성 하는 대신 끝점 라우팅 아래에 빈 문자열이 생성 됩니다.
* 앰비언트 값 (현재 컨텍스트의 경로 매개 변수)은 끝점 라우팅을 사용한 링크 생성에서 자동으로 사용 되지 않습니다. 이전에는 다른 작업 (또는 페이지)에 대 한 링크를 생성할 때 지정 되지 않은 경로 값이 *현재* 경로 앰비언트 값에서 유추 됩니다. 끝점 라우팅을 사용 하는 경우 링크 생성 중에 모든 경로 매개 변수를 명시적으로 지정 해야 합니다.

### <a name="razor-pages"></a>Razor 페이지

이제 매핑 Razor Pages `UseEndpoints`내에서 수행 됩니다.

앱이 Razor Pages를 사용 하는 경우 `MapRazorPages`를 추가 합니다. 끝점 라우팅은 많은 프레임 워크에 대 한 지원을 포함 하므로 현재 옵트인 (opt in) Razor Pages 추가 됩니다.

다음 `Startup.Configure` 메서드에서는 `MapRazorPages` Razor Pages에 대 한 지원을 추가 합니다.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapRazorPages();
    });
}
```

### <a name="use-mvc-without-endpoint-routing"></a>끝점 라우팅 없이 MVC 사용

ASP.NET Core 3.0에서 `UseMvc` 또는 `UseMvcWithDefaultRoute`를 통해 MVC를 사용 하려면 `Startup.ConfigureServices`내에서 명시적인 옵트인를 수행 해야 합니다. MVC는 초기화 하는 동안 권한 부여 및 CORS 미들웨어에 의존할 수 있는지 여부를 알아야 하므로이 작업을 수행 해야 합니다. 앱에서 지원 되지 않는 구성을 사용 하려고 하면 경고를 표시 하는 분석기가 제공 됩니다.

앱에서 레거시 `IRouter` 지원 해야 하는 경우 `Startup.ConfigureServices`에서 다음 방법 중 하나를 사용 하 여 `EnableEndpointRouting`를 사용 하지 않도록 설정 합니다.

```csharp
services.AddMvc(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllers(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddControllersWithViews(options => options.EnableEndpointRouting = false);
```

```csharp
services.AddRazorPages().AddMvcOptions(options => options.EnableEndpointRouting = false);
```

### <a name="health-checks"></a>상태 확인

상태 검사는 끝점 라우팅을 사용 하는 *라우터-웨어* 로 사용할 수 있습니다.

끝점 라우팅을 사용 하 여 상태 검사를 사용 하 `MapHealthChecks`를 추가 합니다. `MapHealthChecks` 메서드는 `UseHealthChecks`와 유사한 인수를 허용 합니다. `UseHealthChecks`에 대해 `MapHealthChecks`를 사용 하는 이점은 권한 부여를 적용 하 고 일치 정책에 대 한 보다 세분화 된 제어를 제공 하는 기능입니다.

다음 예제에서는 `/healthz`의 상태 검사 끝점에 대해 `MapHealthChecks`를 호출 합니다.

```csharp
public void Configure(IApplicationBuilder app)
{
    ...

    app.UseRouting();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapHealthChecks("/healthz", new HealthCheckOptions() { });
    });
}
```

## <a name="hostbuilder-replaces-webhostbuilder"></a>HostBuilder가 WebHostBuilder를 대체 합니다.

ASP.NET Core 3.0 템플릿은 [제네릭 호스트](xref:fundamentals/host/generic-host)를 사용 합니다. 이전 버전은 [웹 호스트](xref:fundamentals/host/web-host)를 사용 했습니다. 다음 코드에서는 클래스 `Program` 생성 된 ASP.NET Core 3.0 템플릿을 보여 줍니다.

[!code-csharp[](22-to-30/samples/Program.cs?name=snippet)]

다음 코드는 ASP.NET Core 2.2 템플릿에서 생성 된 `Program` 클래스를 보여 줍니다.

[!code-csharp[](22-to-30/samples/Program2.2.cs?name=snippet)]

<xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>은 3.0에 유지 되며 앞의 코드 샘플에 표시 된 `webBuilder`의 유형입니다. <xref:Microsoft.AspNetCore.Hosting.WebHostBuilder>는 이후 릴리스에서 더 이상 사용 되지 않으며 `HostBuilder`로 바뀝니다.

`WebHostBuilder`에서 `HostBuilder`로의 가장 중요 한 변경 내용은 [DI (종속성 주입)](xref:fundamentals/dependency-injection)에 있습니다. `HostBuilder`를 사용 하는 경우 `Startup`의 생성자에만 다음을 삽입할 수 있습니다.

* <xref:Microsoft.Extensions.Configuration.IConfiguration>
* `Microsoft.Extensions.Hosting.IHostEnvironment`
* <xref:Microsoft.AspNetCore.Hosting.IWebHostEnvironment>

`HostBuilder` DI 제약 조건:

* DI 컨테이너를 한 번만 작성 하도록 설정 합니다.
* 단일 항목의 여러 인스턴스를 확인 하는 것과 같은 결과 개체 수명 문제를 방지 합니다.

자세한 내용은 [ASP.NET Core 3에서 시작 서비스 주입 방지](https://andrewlock.net/avoiding-startup-service-injection-in-asp-net-core-3/)를 참조 하세요.

## <a name="addauthorization-moved-to-a-different-assembly"></a>AddAuthorization이 다른 어셈블리로 이동 됨

*AspNetCore*의 ASP.NET Core 2.2 및 lower `AddAuthorization` 메서드:

* `AddAuthorizationCore`이름이 바뀌었습니다.
* *AspNetCore*로 이동 되었습니다 .입니다.

*AspNetCore* 및 *AspNetCore* 를 모두 사용 하는 앱은 영향을 받지 않습니다.

*AspNetCore* 를 사용 하지 않는 앱은 다음 중 하나를 수행 해야 합니다.

* *AspNetCore*에 대 한 참조를 추가 합니다. 이 접근 방식은 대부분의 앱에서 작동 하므로 모두 필요 합니다.
* `AddAuthorizationCore` 사용으로 전환

자세한 내용은 [다른 어셈블리 #386에 있는 `AddAuthorization(o =>`의 주요 변경 내용) 오버 로드](https://github.com/aspnet/Announcements/issues/386)를 참조 하세요.

## <a name="identity-ui"></a>Id UI

ASP.NET Core 3.0에 대 한 id UI 업데이트:

* [AspNetCore](https://nuget.org/packages/Microsoft.AspNetCore.Identity.UI)에 패키지 참조를 추가 합니다.
* Razor Pages 사용 하지 않는 앱은 `MapRazorPages`를 호출 해야 합니다. 이 문서의 [Razor Pages](#razor-pages) 를 참조 하세요.
* 부트스트랩 4는 기본 UI 프레임 워크입니다. `IdentityUIFrameworkVersion` 프로젝트 속성을 설정 하 여 기본값을 변경 합니다. 자세한 내용은 [이 GitHub 공지](https://github.com/aspnet/Announcements/issues/380)를 참조 하세요.

## SignalR

SignalR JavaScript 클라이언트가 `@aspnet/signalr`에서 `@microsoft/signalr`로 변경 되었습니다. 이 변경 내용에 반응 하려면 *package. json* 파일, `require` 문 및 ECMAScript `import` 문에서 참조를 변경 합니다.

### <a name="systemtextjson-is-the-default-protocol"></a>System.object는 기본 프로토콜입니다.

이제 `System.Text.Json`은 클라이언트와 서버 모두에서 사용 되는 기본 허브 프로토콜입니다.

`Startup.ConfigureServices`에서 `AddJsonProtocol`를 호출 하 여 serializer 옵션을 설정 합니다.

**서버인**

```csharp
services.AddSignalR(...)
        .AddJsonProtocol(options =>
        {
            options.PayloadSerializerOptions.WriteIndented = false;
        })
```

**클라이언트:**

```csharp
new HubConnectionBuilder()
    .WithUrl("/chatHub")
    .AddJsonProtocol(options =>
    {
        options.PayloadSerializerOptions.WriteIndented = false;
    })
    .Build();
```

### <a name="switch-to-newtonsoftjson"></a>Newtonsoft.json로 전환 합니다.

`System.Text.Json`에서 지원 되지 않는 `Newtonsoft.Json` 기능을 사용 하는 경우 `Newtonsoft.Json`로 다시 전환할 수 있습니다.

1. AspNetCoreSignalR를 설치 합니다. [ NewtonsoftJson](https://www.nuget.org/packages/Microsoft.AspNetCore.SignalR.Protocols.NewtonsoftJson) NuGet 패키지.
1. 클라이언트에서 `AddNewtonsoftJsonProtocol` 메서드 호출을 `HubConnectionBuilder` 인스턴스에 연결 합니다.

    ```csharp
    new HubConnectionBuilder()
        .WithUrl("/chatHub")
        .AddNewtonsoftJsonProtocol(...)
        .Build();
    ```

1. 서버에서 `AddNewtonsoftJsonProtocol` 메서드 호출을 `Startup.ConfigureServices`의 `AddSignalR` 메서드 호출에 연결 합니다.

    ```csharp
    services.AddSignalR()
        .AddNewtonsoftJsonProtocol(...);
    ```

## <a name="opt-in-to-runtime-compilation"></a>런타임 컴파일 옵트인 (Opt in)

ASP.NET Core 3.0 이전에는 뷰의 런타임 컴파일이 프레임 워크의 암시적 기능 이었습니다. 런타임 컴파일을 통해 뷰의 빌드 시간 컴파일을 보완 합니다. 이를 통해 프레임 워크는 전체 앱을 다시 빌드하지 않고도 파일이 수정 될 때 Razor 뷰와 페이지 (*cshtml* 파일)를 컴파일할 수 있습니다. 이 기능은 IDE에서 빠른 편집을 수행 하 고 브라우저를 새로 고쳐 변경 내용을 확인 하는 시나리오를 지원 합니다.

ASP.NET Core 3.0에서 런타임 컴파일은 옵트인 시나리오입니다. 빌드 시간 컴파일은 기본적으로 사용 하도록 설정 된 보기 컴파일의 유일한 메커니즘입니다. 런타임은 파일의 변경 내용을 검색할 때 프로젝트를 다시 빌드하기 위해 Visual Studio 또는 [dotnet watch를 사용](xref:tutorials/dotnet-watch) 하 여 *Visual Studio Code 합니다.* Visual Studio에서 실행 되는 프로젝트의 *.cs*, *cshtml*또는 *Razor* 파일 (<kbd>Ctrl + f5</kbd>)에 대 한 변경 내용이 있지만 디버깅 되지 않습니다 (<kbd>F5</kbd>). 프로젝트의 재컴파일을 트리거합니다.

ASP.NET Core 3.0 프로젝트에서 런타임 컴파일을 사용 하도록 설정 하려면

1. [Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.Razor.RuntimeCompilation) NuGet 패키지를 설치합니다.
1. `AddRazorRuntimeCompilation`를 호출 하 `Startup.ConfigureServices`를 업데이트 합니다.

    ASP.NET Core MVC의 경우 다음 코드를 사용 합니다.

    ```csharp
    services.AddControllersWithViews()
        .AddRazorRuntimeCompilation(...);
    ```
 
    ASP.NET Core Razor Pages의 경우 다음 코드를 사용 합니다.
 
    ```csharp
    services.AddRazorPages()
        .AddRazorRuntimeCompilation(...);
    ```
 
https://github.com/aspnet/samples/tree/master/samples/aspnetcore/mvc/runtimecompilation 샘플에서는 개발 환경에서 조건부로 런타임 컴파일을 사용 하도록 설정 하는 예제를 보여 줍니다.

Razor 파일 컴파일에 대 한 자세한 내용은 <xref:mvc/views/view-compilation>를 참조 하세요.

## <a name="migrate-libraries-via-multi-targeting"></a>다중 대상을 통해 라이브러리 마이그레이션

라이브러리는 여러 버전의 ASP.NET Core을 지원 해야 하는 경우가 많습니다. 이전 버전의 ASP.NET Core에 대해 컴파일된 대부분의 라이브러리는 문제 없이 계속 작동 해야 합니다. 다음 조건에서는 앱을 교차 컴파일해야 합니다.

* 라이브러리는 이진이 [변경](#breaking-api-changes)된 기능을 사용 합니다.
* 라이브러리는 ASP.NET Core 3.0의 새로운 기능을 활용 하려고 합니다. 

예를 들어 다음과 같은 가치를 제공해야 합니다.

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFrameworks>netcoreapp3.0;netstandard2.0</TargetFrameworks>
  </PropertyGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netcoreapp3.0'">
    <FrameworkReference Include="Microsoft.AspNetCore.App" />
  </ItemGroup>

  <ItemGroup Condition="'$(TargetFramework)' == 'netstandard2.0'">
    <PackageReference Include="Microsoft.AspNetCore" Version="2.1.0" />
  </ItemGroup>
</Project>
```

`#ifdefs`를 사용 하 여 ASP.NET Core 3.0 특정 Api를 사용 하도록 설정 합니다.

```csharp
var webRootFileProvider =
#if NETCOREAPP3_0
    GetRequiredService<IWebHostEnvironment>().WebRootFileProvider;
#elif NETSTANDARD2_0
    GetRequiredService<IHostingEnvironment>().WebRootFileProvider;
#else
#error unknown target framework
#endif
```

### <a name="publish"></a>게시

프로젝트 디렉터리에서 *bin* 및 *obj* 폴더를 삭제 합니다.

## <a name="testserver"></a>TestServer

<xref:Microsoft.AspNetCore.TestHost.TestServer>를 [일반 호스트](xref:fundamentals/host/web-host)와 직접 사용 하는 앱의 경우 <xref:Microsoft.Extensions.Hosting.GenericHostWebHostBuilderExtensions.ConfigureWebHost%2A>의 <xref:Microsoft.AspNetCore.Hosting.IWebHostBuilder>에 `TestServer`를 만듭니다.

```csharp
[Fact]
public async Task GenericCreateAndStartHost_GetTestServer()
{
    using var host = await new HostBuilder()
        .ConfigureWebHost(webBuilder =>
        {
            webBuilder
                .UseTestServer()
                .Configure(app => { });
        })
    .StartAsync();

    var response = await host.GetTestServer().CreateClient().GetAsync("/");

    Assert.Equal(HttpStatusCode.NotFound, response.StatusCode);
}
```

<a name="break"></a>

## <a name="breaking-api-changes"></a>API 변경 내용 중단

주요 변경 내용 검토:

* [ASP.NET Core 3.0 릴리스의 전체 주요 변경 내용 목록](https://github.com/aspnet/Announcements/issues?page=1&q=is%3Aissue+is%3Aopen+label%3A%22Breaking+change%22+label%3A3.0.0)
* [위조 방지, CORS, 진단, MVC 및 라우팅을 방지 하기 위해 API 변경을 중단](https://github.com/aspnet/Announcements/issues/387)합니다. 이 목록에는 호환성 스위치에 대한 주요 변경 내용이 포함되어 있습니다.
* .NET Core, ASP.NET Core 및 Entity Framework Core 전체에서 2.2-3.0의 주요 변경 내용에 대 한 요약은 [버전 2.2에서 3.0로 마이그레이션에 대 한 주요 변경 내용](/dotnet/core/compatibility/2.2-3.0)을 참조 하세요.

## <a name="net-core-30-on-azure-app-service"></a>Azure App Service의 .NET Core 3.0

Azure App Service에 대 한 .NET Core 롤아웃에 대 한 자세한 내용은 [App Service의 공식 .Net core](https://aspnetcoreon.azurewebsites.net/) 웹 사이트를 참조 하세요. Azure App Service에서 .NET Core 3.0을 사용할 수 있을 때까지 [Azure App Service에 ASP.NET Core preview 릴리스 배포](xref:host-and-deploy/azure-apps/index#deploy-aspnet-core-preview-release-to-azure-app-service)의 지침을 따르세요.
AddAuthorization이 다른 어셈블리로 이동 됨
