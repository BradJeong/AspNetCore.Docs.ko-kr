---
title: ASP.NET Core에서 컨트롤러 논리 테스트
author: ardalis
description: ASP.NET Core에서 Moq 및 xUnit로 컨트롤러 논리를 테스트하는 방법을 알아봅니다.
ms.author: riande
ms.date: 10/14/2016
uid: mvc/controllers/testing
ms.openlocfilehash: d0b2a25d00187c088671be147844aa892f824c6e
ms.sourcegitcommit: 64c2ca86fff445944b155635918126165ee0f8aa
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 08/18/2018
ms.locfileid: "41751535"
---
# <a name="test-controller-logic-in-aspnet-core"></a><span data-ttu-id="71048-103">ASP.NET Core에서 컨트롤러 논리 테스트</span><span class="sxs-lookup"><span data-stu-id="71048-103">Test controller logic in ASP.NET Core</span></span>

<span data-ttu-id="71048-104">작성자: [Steve Smith](https://ardalis.com/)</span><span class="sxs-lookup"><span data-stu-id="71048-104">By [Steve Smith](https://ardalis.com/)</span></span>

<span data-ttu-id="71048-105">컨트롤러는 모든 ASP.NET Core MVC 응용 프로그램의 핵심 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="71048-105">Controllers are a central part of any ASP.NET Core MVC application.</span></span> <span data-ttu-id="71048-106">따라서 앱에서 의도한 대로 동작한다고 확신할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="71048-106">As such, you should have confidence they behave as intended for your app.</span></span> <span data-ttu-id="71048-107">자동화된 테스트를 통해 이러한 확신을 얻고 오류가 발생하기 전에 미리 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="71048-107">Automated tests can provide you with this confidence and can detect errors before they reach production.</span></span> <span data-ttu-id="71048-108">컨트롤러 내에 불필요한 책임을 지우는 것을 피하고 테스트의 초점을 컨트롤러 책임으로 집중하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="71048-108">It's important to avoid placing unnecessary responsibilities within your controllers and ensure your tests focus only on controller responsibilities.</span></span>

<span data-ttu-id="71048-109">컨트롤러 논리는 최소화되어야 하고 비즈니스 논리나 인프라 문제(예: 데이터 액세스)에 집중하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="71048-109">Controller logic should be minimal and not be focused on business logic or infrastructure concerns (for example, data access).</span></span> <span data-ttu-id="71048-110">프레임워크가 아닌 컨트롤러 논리를 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="71048-110">Test controller logic, not the framework.</span></span> <span data-ttu-id="71048-111">유효한 입력 또는 잘못된 입력을 통해 컨트롤러의 *동작* 방식을 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="71048-111">Test how the controller *behaves* based on valid or invalid inputs.</span></span> <span data-ttu-id="71048-112">컨트롤러가 수행하는 비즈니스 작업의 결과를 바탕으로 컨트롤러 응답을 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="71048-112">Test controller responses based on the result of the business operation it performs.</span></span>

<span data-ttu-id="71048-113">컨트롤러의 일반적인 책임:</span><span class="sxs-lookup"><span data-stu-id="71048-113">Typical controller responsibilities:</span></span>

* <span data-ttu-id="71048-114">`ModelState.IsValid`를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="71048-114">Verify `ModelState.IsValid`.</span></span>
* <span data-ttu-id="71048-115">`ModelState`가 올바르지 않으면 오류 응답을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="71048-115">Return an error response if `ModelState` is invalid.</span></span>
* <span data-ttu-id="71048-116">지속성 저장소에서 비즈니스 엔터티를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="71048-116">Retrieve a business entity from persistence.</span></span>
* <span data-ttu-id="71048-117">비즈니스 엔터티에서 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="71048-117">Perform an action on the business entity.</span></span>
* <span data-ttu-id="71048-118">보관할 비즈니스 엔터티를 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="71048-118">Save the business entity to persistence.</span></span>
* <span data-ttu-id="71048-119">적절한 `IActionResult`를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="71048-119">Return an appropriate `IActionResult`.</span></span>

<span data-ttu-id="71048-120">[예제 코드 살펴보기 및 다운로드](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/testing/sample)([다운로드 방법](xref:tutorials/index#how-to-download-a-sample))</span><span class="sxs-lookup"><span data-stu-id="71048-120">[View or download sample code](https://github.com/aspnet/Docs/tree/master/aspnetcore/mvc/controllers/testing/sample) ([how to download](xref:tutorials/index#how-to-download-a-sample))</span></span>

## <a name="unit-tests-of-controller-logic"></a><span data-ttu-id="71048-121">컨트롤러 논리의 단위 테스트</span><span class="sxs-lookup"><span data-stu-id="71048-121">Unit tests of controller logic</span></span>

<span data-ttu-id="71048-122">[단위 테스트](/dotnet/articles/core/testing/unit-testing-with-dotnet-test)는 인프라 및 종속성으로부터 격리된 상태에서 앱의 일부를 테스트하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="71048-122">[Unit tests](/dotnet/articles/core/testing/unit-testing-with-dotnet-test) involve testing a part of an app in isolation from its infrastructure and dependencies.</span></span> <span data-ttu-id="71048-123">컨트롤러 논리를 단위 테스트하는 경우 단일 작업의 콘텐츠만 테스트되고, 종속성 또는 프레임워크 자체의 동작은 테스트되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="71048-123">When unit testing controller logic, only the contents of a single action is tested, not the behavior of its dependencies or of the framework itself.</span></span> <span data-ttu-id="71048-124">컨트롤러 작업을 단위 테스트할 때에는 동작에만 집중해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="71048-124">As you unit test your controller actions, make sure you focus only on its behavior.</span></span> <span data-ttu-id="71048-125">컨트롤러 단위 테스트는 [필터](xref:mvc/controllers/filters), [라우팅](xref:fundamentals/routing), [모델 바인딩](xref:mvc/models/model-binding) 같은 것들이 필요 없습니다.</span><span class="sxs-lookup"><span data-stu-id="71048-125">A controller unit test avoids things like [filters](xref:mvc/controllers/filters), [routing](xref:fundamentals/routing), or [model binding](xref:mvc/models/model-binding).</span></span> <span data-ttu-id="71048-126">단위 테스트는 하나를 테스트하는 데 집중하기 때문에 일반적으로 작성 방법이 간단하고 신속하게 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="71048-126">By focusing on testing just one thing, unit tests are generally simple to write and quick to run.</span></span> <span data-ttu-id="71048-127">잘 작성된 단위 테스트 집합은 많은 오버헤드 없이 자주 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="71048-127">A well-written set of unit tests can be run frequently without much overhead.</span></span> <span data-ttu-id="71048-128">그러나 단위 테스트는 구성 요소 간의 상호 작용 문제를 검색하지 않습니다. 이 문제는 [통합 테스트](xref:test/integration-tests)의 목적입니다.</span><span class="sxs-lookup"><span data-stu-id="71048-128">However, unit tests don't detect issues in the interaction between components, which is the purpose of [integration tests](xref:test/integration-tests).</span></span>

<span data-ttu-id="71048-129">사용자 지정 필터 및 경로를 작성할 때 특정 컨트롤러 작업에 대한 테스트의 일부가 아닌 별도로 단위 테스트를 수행해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="71048-129">If you're writing custom filters and routes, you should unit test them in isolation, not as part of your tests on a particular controller action.</span></span>

> [!TIP]
> <span data-ttu-id="71048-130">[Visual Studio를 사용하여 단위 테스트를 만들고 실행](/visualstudio/test/unit-test-your-code)</span><span class="sxs-lookup"><span data-stu-id="71048-130">[Create and run unit tests with Visual Studio](/visualstudio/test/unit-test-your-code).</span></span>

<span data-ttu-id="71048-131">단위 테스트를 시연하려면 다음 컨트롤러를 검토합니다.</span><span class="sxs-lookup"><span data-stu-id="71048-131">To demonstrate unit testing, review the following controller.</span></span> <span data-ttu-id="71048-132">이 컨트롤러는 브레인스토밍 세션 목록을 표시하며 POST를 사용하여 새로운 브레인스토밍 세션을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="71048-132">It displays a list of brainstorming sessions and allows new brainstorming sessions to be created with a POST:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/src/TestingControllersSample/Controllers/HomeController.cs?highlight=12,16,21,42,43)]

<span data-ttu-id="71048-133">이 컨트롤러는 [명시적 종속성 원칙](http://deviq.com/explicit-dependencies-principle/)을 따르며, `IBrainstormSessionRepository` 인스턴스를 제공하는 종속성 주입을 예상합니다.</span><span class="sxs-lookup"><span data-stu-id="71048-133">The controller is following the [explicit dependencies principle](http://deviq.com/explicit-dependencies-principle/), expecting dependency injection to provide it with an instance of `IBrainstormSessionRepository`.</span></span> <span data-ttu-id="71048-134">따라서 [Moq](https://www.nuget.org/packages/Moq/) 같은 모의 개체 프레임워크를 사용하여 매우 간편하게 테스트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="71048-134">This makes it fairly easy to test using a mock object framework, like [Moq](https://www.nuget.org/packages/Moq/).</span></span> <span data-ttu-id="71048-135">`HTTP GET Index` 메서드는 반복 또는 분기가 없으며 한 가지 메서드만 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="71048-135">The `HTTP GET Index` method has no looping or branching and only calls one method.</span></span> <span data-ttu-id="71048-136">이 `Index` 메서드를 테스트하려면 리포지토리의 `List` 메서드에서 `ViewModel`를 사용하여 `ViewResult`가 반환되는지 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="71048-136">To test this `Index` method, we need to verify that a `ViewResult` is returned, with a `ViewModel` from the repository's `List` method.</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/HomeControllerTests.cs?highlight=17-18&range=1-33,76-95)]

<span data-ttu-id="71048-137">위에서 나온 `HomeController` `HTTP POST Index` 메서드는 다음을 확인해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="71048-137">The `HomeController` `HTTP POST Index` method (shown above) should verify:</span></span>

* <span data-ttu-id="71048-138">`ModelState.IsValid`가 `false`이면 작업 메서드는 적절한 데이터와 함께 잘못된 요청 `ViewResult`를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="71048-138">The action method returns a Bad Request `ViewResult` with the appropriate data when `ModelState.IsValid` is `false`.</span></span>

* <span data-ttu-id="71048-139">`ModelState.IsValid`가 true이면 리포지토리의 `Add` 메서드가 호출되고 올바른 인수와 함께 `RedirectToActionResult`가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="71048-139">The `Add` method on the repository is called and a `RedirectToActionResult` is returned with the correct arguments when `ModelState.IsValid` is true.</span></span>

<span data-ttu-id="71048-140">아래의 첫 번째 테스트처럼 `AddModelError`로 오류를 추가하여 잘못된 모델 상태를 테스트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="71048-140">Invalid model state can be tested by adding errors using `AddModelError` as shown in the first test below.</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/HomeControllerTests.cs?highlight=8,15-16,37-39&range=35-75)]

<span data-ttu-id="71048-141">첫 번째 테스트는 `ModelState`가 잘못된 경우 `GET` 요청과 마찬가지로 동일한 `ViewResult`가 반환되는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="71048-141">The first test confirms when `ModelState` isn't valid, the same `ViewResult` is returned as for a `GET` request.</span></span> <span data-ttu-id="71048-142">이 테스트는 잘못된 모델을 전달하려고 시도하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="71048-142">Note that the test doesn't attempt to pass in an invalid model.</span></span> <span data-ttu-id="71048-143">모델 바인딩이 실행되고 있지 않으므로([통합 테스트](xref:test/integration-tests)에서 연습 모델 바인딩을 사용하겠지만) 어떤 방법으로도 작동하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="71048-143">That wouldn't work anyway since model binding isn't running (though an [integration test](xref:test/integration-tests) would use exercise model binding).</span></span> <span data-ttu-id="71048-144">이 예에서는 모델 바인딩을 테스트하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="71048-144">In this case, model binding isn't being tested.</span></span> <span data-ttu-id="71048-145">이러한 단위 테스트는 작업 메서드의 코드에서 하는 일만 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="71048-145">These unit tests are only testing what the code in the action method does.</span></span>

<span data-ttu-id="71048-146">두 번째 테스트는 `ModelState`가 잘못된 경우 새 `BrainstormSession`이 추가되는지(리포지토리를 통해), 메서드가 예상된 속성과 함께 `RedirectToActionResult`를 반환하는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="71048-146">The second test verifies that when `ModelState` is valid, a new `BrainstormSession` is added (via the repository), and the method returns a `RedirectToActionResult` with the expected properties.</span></span> <span data-ttu-id="71048-147">호출되지 않은 모의 호출은 일반적으로 무시되지만, 설정 호출의 끝부분에서 `Verifiable`을 호출하면 테스트에서 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="71048-147">Mocked calls that aren't called are normally ignored, but calling `Verifiable` at the end of the setup call allows it to be verified in the test.</span></span> <span data-ttu-id="71048-148">이것은 `mockRepo.Verify` 호출을 통해 수행되며, 예상된 메서드가 호출되지 않으면 테스트가 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="71048-148">This is done with the call to `mockRepo.Verify`, which will fail the test if the expected method wasn't called.</span></span>

> [!NOTE]
> <span data-ttu-id="71048-149">이 샘플에 사용된 Moq 라이브러리를 사용하면 확인 가능한 또는 "엄격한" 모의 개체를 확인 불가능한 모의 개체("느슨한" 모의 개체 또는 스텁이라고도 함)와 손쉽게 혼합할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="71048-149">The Moq library used in this sample makes it easy to mix verifiable, or "strict", mocks with non-verifiable mocks (also called "loose" mocks or stubs).</span></span> <span data-ttu-id="71048-150">[Moq를 사용하여 모의 동작 사용자 지정](https://github.com/Moq/moq4/wiki/Quickstart#customizing-mock-behavior)에 대해 자세히 알아보세요.</span><span class="sxs-lookup"><span data-stu-id="71048-150">Learn more about [customizing Mock behavior with Moq](https://github.com/Moq/moq4/wiki/Quickstart#customizing-mock-behavior).</span></span>

<span data-ttu-id="71048-151">앱의 다른 컨트롤러는 특정 브레인스토밍 세션과 관련된 정보를 표시합니다.</span><span class="sxs-lookup"><span data-stu-id="71048-151">Another controller in the app displays information related to a particular brainstorming session.</span></span> <span data-ttu-id="71048-152">잘못된 id 값을 처리하는 일부 논리를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="71048-152">It includes some logic to deal with invalid id values:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/src/TestingControllersSample/Controllers/SessionController.cs?highlight=19,20,21,22,25,26,27,28)]

<span data-ttu-id="71048-153">컨트롤러 작업에는 테스트할 사례가 각 `return` 문에 하나씩, 총 세 개 있습니다.</span><span class="sxs-lookup"><span data-stu-id="71048-153">The controller action has three cases to test, one for each `return` statement:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/SessionControllerTests.cs?highlight=27,28,29,46,47,64,65,66,67,68)]

<span data-ttu-id="71048-154">앱에서는 기능을 웹 API(브레인스토밍 세션과 관련된 아이디어 목록 및 세션에 새 아이디어를 추가하기 위한 메서드)로 노출합니다.</span><span class="sxs-lookup"><span data-stu-id="71048-154">The app exposes functionality as a web API (a list of ideas associated with a brainstorming session and a method for adding new ideas to a session):</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/src/TestingControllersSample/Api/IdeasController.cs?highlight=21,22,27,30,31,32,33,34,35,36,41,42,46,52,65)]

<span data-ttu-id="71048-155">`ForSession` 메서드는 `IdeaDTO` 형식 목록을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="71048-155">The `ForSession` method returns a list of `IdeaDTO` types.</span></span> <span data-ttu-id="71048-156">API 호출을 통해 직접 비즈니스 도메인 엔터티를 반환하지 마세요. API 호출은 API 클라이언트에서 요구하는 것보다 더 많은 데이터를 포함하고 앱의 내부 도메인 모델을 외부에 노출되는 API와 불필요하게 연결하는 경우가 자주 있기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="71048-156">Avoid returning your business domain entities directly via API calls, since frequently they include more data than the API client requires, and they unnecessarily couple your app's internal domain model with the API you expose externally.</span></span> <span data-ttu-id="71048-157">도메인 엔터티와 유선으로 반환할 형식 간의 매핑은 수동으로(여기 보이는 것처럼 LINQ `Select` 사용) 또는 [AutoMapper](https://github.com/AutoMapper/AutoMapper) 같은 라이브러리를 사용하여 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="71048-157">Mapping between domain entities and the types you will return over the wire can be done manually (using a LINQ `Select` as shown here) or using a library like [AutoMapper](https://github.com/AutoMapper/AutoMapper).</span></span>

<span data-ttu-id="71048-158">`Create` 및 `ForSession` API 메서드에 대한 단위 테스트:</span><span class="sxs-lookup"><span data-stu-id="71048-158">The unit tests for the `Create` and `ForSession` API methods:</span></span>

[!code-csharp[](testing/sample/TestingControllersSample/tests/TestingControllersSample.Tests/UnitTests/ApiIdeasControllerTests.cs?highlight=18,23,29,33,38-39,43,50,58-59,68-70,76-78&range=1-83,121-135)]

<span data-ttu-id="71048-159">앞서 언급했듯이, `ModelState`가 유효하지 않을 때 메서드의 동작을 테스트하려면 테스트의 일부로 컨트롤러에 모델 오류를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="71048-159">As stated previously, to test the behavior of the method when `ModelState` is invalid, add a model error to the controller as part of the test.</span></span> <span data-ttu-id="71048-160">단위 테스트에서 모델 유효성 검사 또는 모델 바인딩을 테스트하지 말고, 특정 `ModelState` 값이 나타나면 작업 메서드의 동작만 테스트하세요.</span><span class="sxs-lookup"><span data-stu-id="71048-160">Don't try to test model validation or model binding in your unit tests - just test your action method's behavior when confronted with a particular `ModelState` value.</span></span>

<span data-ttu-id="71048-161">두 번째 테스트는 null을 반환하는 리포지토리를 사용하므로 모의 리포지토리가 null을 반환하도록 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="71048-161">The second test depends on the repository returning null, so the mock repository is configured to return null.</span></span> <span data-ttu-id="71048-162">테스트 데이터베이스를 만들고(메모리 내부에 또는 다른 위치에) 이 결과를 반환하는 쿼리를 작성할 필요가 없습니다. 다음과 같이 단일 명령문으로 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="71048-162">There's no need to create a test database (in memory or otherwise) and construct a query that will return this result - it can be done in a single statement as shown.</span></span>

<span data-ttu-id="71048-163">마지막 테스트는 리포지토리의 `Update` 메서드가 호출되는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="71048-163">The last test verifies that the repository's `Update` method is called.</span></span> <span data-ttu-id="71048-164">앞에서 살펴본 것처럼, `Verifiable`을 통해 모의 개체가 호출된 후 확인 가능한 메서드가 실행되었는지 확인하기 위해 모의 리포지토리의 `Verify` 메서드가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="71048-164">As we did previously, the mock is called with `Verifiable` and then the mocked repository's `Verify` method is called to confirm the verifiable method was executed.</span></span> <span data-ttu-id="71048-165">`Update` 메서드가 데이터를 저장하도록 보장하는 것은 단위 테스트의 책임이 아니며, 통합 테스트로 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="71048-165">It's not a unit test responsibility to ensure that the `Update` method saved the data; that can be done with an integration test.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="71048-166">추가 자료</span><span class="sxs-lookup"><span data-stu-id="71048-166">Additional resources</span></span>

* <xref:test/integration-tests>
