---
title: "하위 키 파생 및 인증 된 암호화"
author: rick-anderson
description: "이 문서에서는 ASP.NET Core 데이터 보호의 구현 세부 정보 파생을 하위 키와 인증 암호화에 설명 합니다."
keywords: "데이터 보호, 하위 키 파생을 ASP.NET Core 인증 암호화"
ms.author: riande
manager: wpickett
ms.date: 10/14/2016
ms.topic: article
ms.assetid: 34bb58a3-5a9a-41e5-b090-08f75b4bbefa
ms.technology: aspnet
ms.prod: asp.net-core
uid: security/data-protection/implementation/subkeyderivation
ms.openlocfilehash: 3eb27b8a6d04074662bf619a09fd867252624209
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/10/2017
---
# <a name="subkey-derivation-and-authenticated-encryption"></a><span data-ttu-id="23eb1-104">하위 키 파생 및 인증 된 암호화</span><span class="sxs-lookup"><span data-stu-id="23eb1-104">Subkey Derivation and Authenticated Encryption</span></span>

<a name="data-protection-implementation-subkey-derivation"></a>

<span data-ttu-id="23eb1-105">키 링에서 대부분의 키 엔트로피 형태의 되 고 나머지 "CBC 모드 암호화 + HMAC 유효성 검사" 없다는 알고리즘 정보가 더 또는 "GCM 암호화 + 유효성 검사"입니다.</span><span class="sxs-lookup"><span data-stu-id="23eb1-105">Most keys in the key ring will contain some form of entropy and will have algorithmic information stating "CBC-mode encryption + HMAC validation" or "GCM encryption + validation".</span></span> <span data-ttu-id="23eb1-106">이러한 경우이 키에 대 한 마스터 키 자료가 (또는 KM)로 포함 된 엔트로피 이라고 하 고 실제 암호화 작업에 대해 사용할 키를 파생 하는 키 파생 기능을 수행 했습니다.</span><span class="sxs-lookup"><span data-stu-id="23eb1-106">In these cases, we refer to the embedded entropy as the master keying material (or KM) for this key, and we perform a key derivation function to derive the keys that will be used for the actual cryptographic operations.</span></span>

> [!NOTE]
> <span data-ttu-id="23eb1-107">키가 추상이 고 아래와 같이 사용자 지정 구현을 동작 하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="23eb1-107">Keys are abstract, and a custom implementation might not behave as below.</span></span> <span data-ttu-id="23eb1-108">키의 자체 구현을 제공 하는 경우 `IAuthenticatedEncryptor` 우리의 기본 제공 팩터리 중 하나를 사용 하는 대신이 섹션에 설명 된 메커니즘 적용 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="23eb1-108">If the key provides its own implementation of `IAuthenticatedEncryptor` rather than using one of our built-in factories, the mechanism described in this section no longer applies.</span></span>

<a name="data-protection-implementation-subkey-derivation-aad"></a>

## <a name="additional-authenticated-data-and-subkey-derivation"></a><span data-ttu-id="23eb1-109">추가 인증 된 데이터 및 하위 키 파생</span><span class="sxs-lookup"><span data-stu-id="23eb1-109">Additional authenticated data and subkey derivation</span></span>

<span data-ttu-id="23eb1-110">`IAuthenticatedEncryptor` 인터페이스 모든 인증 된 암호화 작업에 대 한 핵심 인터페이스로 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="23eb1-110">The `IAuthenticatedEncryptor` interface serves as the core interface for all authenticated encryption operations.</span></span> <span data-ttu-id="23eb1-111">해당 `Encrypt` 메서드는 두 개의 버퍼: 일반 텍스트 및 additionalAuthenticatedData (AAD).</span><span class="sxs-lookup"><span data-stu-id="23eb1-111">Its `Encrypt` method takes two buffers: plaintext and additionalAuthenticatedData (AAD).</span></span> <span data-ttu-id="23eb1-112">일반 텍스트 콘텐츠 흐름에 대 한 호출을 변경 하지 않고 `IDataProtector.Protect`, 하지만 AAD 시스템에서 생성 하 고 세 가지 구성 요소로 이루어져 있습니다.</span><span class="sxs-lookup"><span data-stu-id="23eb1-112">The plaintext contents flow unchanged the call to `IDataProtector.Protect`, but the AAD is generated by the system and consists of three components:</span></span>

1. <span data-ttu-id="23eb1-113">32 비트 매직 헤더 09 F0 C9 F0 데이터 보호 시스템의이 버전을 식별 하는입니다.</span><span class="sxs-lookup"><span data-stu-id="23eb1-113">The 32-bit magic header 09 F0 C9 F0 that identifies this version of the data protection system.</span></span>

2. <span data-ttu-id="23eb1-114">128 비트 키 id입니다.</span><span class="sxs-lookup"><span data-stu-id="23eb1-114">The 128-bit key id.</span></span>

3. <span data-ttu-id="23eb1-115">만든 목적 체인에서 구성 되는 가변 길이 문자열의 `IDataProtector` 이 작업을 수행 하는 합니다.</span><span class="sxs-lookup"><span data-stu-id="23eb1-115">A variable-length string formed from the purpose chain that created the `IDataProtector` that is performing this operation.</span></span>

<span data-ttu-id="23eb1-116">AAD 세 구성 요소 모두의 튜플을 대 한 고유 이기 때문에 새에서 키를 파생 KM KM 자체 모든 페이지에서 암호화 작업을 사용 하는 대신 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="23eb1-116">Because the AAD is unique for the tuple of all three components, we can use it to derive new keys from KM instead of using KM itself in all of our cryptographic operations.</span></span> <span data-ttu-id="23eb1-117">호출할 때마다 `IAuthenticatedEncryptor.Encrypt`, 다음 키 파생 프로세스가 수행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="23eb1-117">For every call to `IAuthenticatedEncryptor.Encrypt`, the following key derivation process takes place:</span></span>

<span data-ttu-id="23eb1-118">(K_E, K_H) SP800_108_CTR_HMACSHA512 = (K_M, AAD contextHeader | | keyModifier)</span><span class="sxs-lookup"><span data-stu-id="23eb1-118">( K_E, K_H ) = SP800_108_CTR_HMACSHA512(K_M, AAD, contextHeader || keyModifier)</span></span>

<span data-ttu-id="23eb1-119">NIST SP800 108 KDF 카운터 모드로 전화를 걸고 여기 (참조 [NIST SP800-108](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), 초 5.1)는 다음 매개 변수:</span><span class="sxs-lookup"><span data-stu-id="23eb1-119">Here, we're calling the NIST SP800-108 KDF in Counter Mode (see [NIST SP800-108](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec. 5.1) with the following parameters:</span></span>

* <span data-ttu-id="23eb1-120">키 파생 키 (KDK) K_M =</span><span class="sxs-lookup"><span data-stu-id="23eb1-120">Key derivation key (KDK) = K_M</span></span>

* <span data-ttu-id="23eb1-121">PRF HMACSHA512 =</span><span class="sxs-lookup"><span data-stu-id="23eb1-121">PRF = HMACSHA512</span></span>

* <span data-ttu-id="23eb1-122">레이블 additionalAuthenticatedData =</span><span class="sxs-lookup"><span data-stu-id="23eb1-122">label = additionalAuthenticatedData</span></span>

* <span data-ttu-id="23eb1-123">상황에 맞는 contextHeader = | | keyModifier</span><span class="sxs-lookup"><span data-stu-id="23eb1-123">context = contextHeader || keyModifier</span></span>

<span data-ttu-id="23eb1-124">컨텍스트 헤더의 가변 길이 이며 기본적으로 역할을 K_E 및 K_H를 파생 하는에서는 알고리즘의 손도장을 합니다.</span><span class="sxs-lookup"><span data-stu-id="23eb1-124">The context header is of variable length and essentially serves as a thumbprint of the algorithms for which we're deriving K_E and K_H.</span></span> <span data-ttu-id="23eb1-125">키 한정자는 각 호출에 대해 임의로 생성 된 128 비트 문자열 `Encrypt` 을 확률 KE와 KH는 고유이 특정 인증 암호화 작업에 대 한 다른 모든 입력 KDF에는 상수 하는 경우에 과도 하 게 많아지지를 보장 하 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="23eb1-125">The key modifier is a 128-bit string randomly generated for each call to `Encrypt` and serves to ensure with overwhelming probability that KE and KH are unique for this specific authentication encryption operation, even if all other input to the KDF is constant.</span></span>

<span data-ttu-id="23eb1-126">CBC 모드 암호화 + HMAC 유효성 검사 작업에 대 한 | K_E | 블록 대칭 암호화 키의 길이 및 | K_H | HMAC 루틴의 다이제스트 크기가입니다.</span><span class="sxs-lookup"><span data-stu-id="23eb1-126">For CBC-mode encryption + HMAC validation operations, | K_E | is the length of the symmetric block cipher key, and | K_H | is the digest size of the HMAC routine.</span></span> <span data-ttu-id="23eb1-127">GCM 암호화에 대 한 유효성 검사 작업 + | K_H | = 0.</span><span class="sxs-lookup"><span data-stu-id="23eb1-127">For GCM encryption + validation operations, | K_H | = 0.</span></span>

## <a name="cbc-mode-encryption--hmac-validation"></a><span data-ttu-id="23eb1-128">CBC 모드 암호화 + HMAC 유효성 검사</span><span class="sxs-lookup"><span data-stu-id="23eb1-128">CBC-mode encryption + HMAC validation</span></span>

<span data-ttu-id="23eb1-129">K_E 위 메커니즘을 통해 생성 되 면 임의 초기화 벡터를 생성 했습니다 고 일반 텍스트를 암호화 하는 대칭 블록 암호화 알고리즘을 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="23eb1-129">Once K_E is generated via the above mechanism, we generate a random initialization vector and run the symmetric block cipher algorithm to encipher the plaintext.</span></span> <span data-ttu-id="23eb1-130">초기화 벡터 및 암호화 텍스트 K_H MAC을 생성 하기 위해 키를 사용 하 여 초기화 HMAC 루틴을 통해 다음 실행</span><span class="sxs-lookup"><span data-stu-id="23eb1-130">The initialization vector and ciphertext are then run through the HMAC routine initialized with the key K_H to produce the MAC.</span></span> <span data-ttu-id="23eb1-131">이 프로세스와 반환 값은 아래 그래픽으로 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="23eb1-131">This process and the return value is represented graphically below.</span></span>

![CBC 모드 프로세스 및 반환](subkeyderivation/_static/cbcprocess.png)

<span data-ttu-id="23eb1-133">*출력: keyModifier = | | iv | | E_cbc (K_E, iv, 데이터) | | HMAC (K_H, iv | | E_cbc (K_E, iv, 데이터))*</span><span class="sxs-lookup"><span data-stu-id="23eb1-133">*output:= keyModifier || iv || E_cbc (K_E,iv,data) || HMAC(K_H, iv || E_cbc (K_E,iv,data))*</span></span>

> [!NOTE]
> <span data-ttu-id="23eb1-134">`IDataProtector.Protect` 구현 됩니다 [매직 머리글과 키 id 앞에 추가](authenticated-encryption-details.md) 를 호출자에 게 반환 하기 전에 출력 합니다.</span><span class="sxs-lookup"><span data-stu-id="23eb1-134">The `IDataProtector.Protect` implementation will [prepend the magic header and key id](authenticated-encryption-details.md) to output before returning it to the caller.</span></span> <span data-ttu-id="23eb1-135">매직 머리글과 키 id는 암시적으로 하기 때문에 속하지 [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), 키 한정자는 KDF에 입력으로 제공 됩니다, 때문에이 경우 반환 된 마지막 페이로드는 모든 단일 바이트가 MAC에서 인증</span><span class="sxs-lookup"><span data-stu-id="23eb1-135">Because the magic header and key id are implicitly part of [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), and because the key modifier is fed as input to the KDF, this means that every single byte of the final returned payload is authenticated by the MAC.</span></span>

## <a name="galoiscounter-mode-encryption--validation"></a><span data-ttu-id="23eb1-136">Galois/카운터 모드 암호화 + 유효성 검사</span><span class="sxs-lookup"><span data-stu-id="23eb1-136">Galois/Counter Mode encryption + validation</span></span>

<span data-ttu-id="23eb1-137">K_E 위 메커니즘을 통해 생성 되 면 임의 96 비트 nonce를 생성 했습니다 고을 일반 텍스트를 암호화 하 고 128 비트 인증 태그가 생성 블록 대칭 암호화 알고리즘을 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="23eb1-137">Once K_E is generated via the above mechanism, we generate a random 96-bit nonce and run the symmetric block cipher algorithm to encipher the plaintext and produce the 128-bit authentication tag.</span></span>

![GCM 모드 프로세스 및 반환](subkeyderivation/_static/galoisprocess.png)

<span data-ttu-id="23eb1-139">*출력: keyModifier = | | nonce | | E_gcm (nonce, 데이터, K_E) | | authTag*</span><span class="sxs-lookup"><span data-stu-id="23eb1-139">*output := keyModifier || nonce || E_gcm (K_E,nonce,data) || authTag*</span></span>

> [!NOTE]
> <span data-ttu-id="23eb1-140">GCM AAD의 개념을 고유 하 게 지 원하는 경우에에서는 여전히 저장 AAD 원래 KDF에만 해당 AAD 매개 변수에 대 한 GCM에 빈 문자열을 전달 하 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="23eb1-140">Even though GCM natively supports the concept of AAD, we're still feeding AAD only to the original KDF, opting to pass an empty string into GCM for its AAD parameter.</span></span> <span data-ttu-id="23eb1-141">그 이유는 두 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="23eb1-141">The reason for this is two-fold.</span></span> <span data-ttu-id="23eb1-142">첫째, [민첩성을 지원 하기 위해](context-headers.md#data-protection-implementation-context-headers) K_M를 사용 하 여 암호화 키로 직접 하려고 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="23eb1-142">First, [to support agility](context-headers.md#data-protection-implementation-context-headers) we never want to use K_M directly as the encryption key.</span></span> <span data-ttu-id="23eb1-143">또한 GCM 해당 입력에 대해 매우 엄격한 고유성 요구 사항을 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="23eb1-143">Additionally, GCM imposes very strict uniqueness requirements on its inputs.</span></span> <span data-ttu-id="23eb1-144">GCM 암호화 루틴의 두 개에서 호출 된 적이 또는 더 분명 가능성 (키, nonce) 동일한 입력된 데이터 집합 2 쌍을 초과할 수 없습니다 ^32입니다.</span><span class="sxs-lookup"><span data-stu-id="23eb1-144">The probability that the GCM encryption routine is ever invoked on two or more distinct sets of input data with the same (key, nonce) pair must not exceed 2^32.</span></span> <span data-ttu-id="23eb1-145">2 개 이상의 수행할 수 없습니다. 여기서 K_E를 해결 하는 경우 ^32 암호화 작업 전에 2의 위반을 실행 했습니다 ^-32를 제한 합니다.</span><span class="sxs-lookup"><span data-stu-id="23eb1-145">If we fix K_E we cannot perform more than 2^32 encryption operations before we run afoul of the 2^-32 limit.</span></span> <span data-ttu-id="23eb1-146">이 처럼 매우 많은 수의 작업, 보이지만 트래픽이 많은 웹 서버는 단순한 일 전 부터는 이러한 키에 대 한 일반적인 수명 범위 내에 4 십억 요청을 통해 넣을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="23eb1-146">This might seem like a very large number of operations, but a high-traffic web server can go through 4 billion requests in mere days, well within the normal lifetime for these keys.</span></span> <span data-ttu-id="23eb1-147">값 2의 준수할 수 ^-32 확률도 계속 해 서 128 비트 키 한정자와 근본적으로 지정 된 모든 K_M에 대 한 사용 가능한 작업 수를 확장 하는 96 비트 nonce를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="23eb1-147">To stay compliant of the 2^-32 probability limit, we continue to use a 128-bit key modifier and 96-bit nonce, which radically extends the usable operation count for any given K_M.</span></span> <span data-ttu-id="23eb1-148">CBC 및 GCM 작업 사이의 KDF 코드 경로 공유 하겠습니다 디자인을 간소화 하 고 없기 때문에 KDF에서 AAD 이미 것으로 간주 GCM 루틴에 전달할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="23eb1-148">For simplicity of design we share the KDF code path between CBC and GCM operations, and since AAD is already considered in the KDF there is no need to forward it to the GCM routine.</span></span>
