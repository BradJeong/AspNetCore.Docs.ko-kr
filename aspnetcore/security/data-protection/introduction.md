---
title: "데이터 보호 소개"
author: rick-anderson
description: "이 문서는 데이터 보호의 개념을 소개 하 고 관련 된 ASP.NET Core Api의 디자인 원칙에 간략하게 설명 합니다."
manager: wpickett
ms.author: riande
ms.date: 10/14/2016
ms.prod: asp.net-core
ms.technology: aspnet
ms.topic: article
uid: security/data-protection/introduction
ms.openlocfilehash: acd38679390b92705703111b72816f1a5d3ba848
ms.sourcegitcommit: a510f38930abc84c4b302029d019a34dfe76823b
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 01/30/2018
---
# <a name="introduction-to-data-protection"></a><span data-ttu-id="358d3-103">데이터 보호 소개</span><span class="sxs-lookup"><span data-stu-id="358d3-103">Introduction to Data Protection</span></span>

<span data-ttu-id="358d3-104">웹 응용 프로그램은 종종 보안이 중요 한 데이터를 저장 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-104">Web applications often need to store security-sensitive data.</span></span> <span data-ttu-id="358d3-105">Windows 데스크톱 응용 프로그램에 대 한 DPAPI를 제공 하지만 웹 응용 프로그램에 적합 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-105">Windows provides DPAPI for desktop applications but this is unsuitable for web applications.</span></span> <span data-ttu-id="358d3-106">ASP.NET Core 데이터 보호 스택의 개발자 키 관리 및 회전을 포함 한 데이터를 보호 사용할 수 있는 간단 하 고 사용 하기 쉬운 암호화 API를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-106">The ASP.NET Core data protection stack provide a simple, easy to use cryptographic API a developer can use to protect data, including key management and rotation.</span></span>

<span data-ttu-id="358d3-107">ASP.NET Core 데이터 보호 스택의 장기적으로 대체도 충족 하도록 디자인 되었습니다는 <machineKey> asp.net에서 요소 1.x-4.x 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-107">The ASP.NET Core data protection stack is designed to serve as the long-term replacement for the <machineKey> element in ASP.NET 1.x - 4.x.</span></span> <span data-ttu-id="358d3-108">사용 사례 최신 응용 프로그램 발생할 가능성이 높습니다. 대부분에 기본적으로 솔루션을 제공 하면서 다양 한 이전 암호화 스택의 단점을 해결 하기 위해 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-108">It was designed to address many of the shortcomings of the old cryptographic stack while providing an out-of-the-box solution for the majority of use cases modern applications are likely to encounter.</span></span>

## <a name="problem-statement"></a><span data-ttu-id="358d3-109">문제 설명</span><span class="sxs-lookup"><span data-stu-id="358d3-109">Problem statement</span></span>

<span data-ttu-id="358d3-110">전체 문제 설명 단일 문장에 간결 하 게 정의할 수 있습니다: 나중에 검색에 대 한 신뢰할 수 있는 정보를 유지 해야 하지만 지 속성 메커니즘이 신뢰 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-110">The overall problem statement can be succinctly stated in a single sentence: I need to persist trusted information for later retrieval, but I don't trust the persistence mechanism.</span></span> <span data-ttu-id="358d3-111">웹 측면에서이 수로 작성할 수 "싶습니다 신뢰할 수 없는 클라이언트를 통해 왕복 신뢰할 수 있는 상태로."</span><span class="sxs-lookup"><span data-stu-id="358d3-111">In web terms, this might be written as "I need to round-trip trusted state via an untrusted client."</span></span>

<span data-ttu-id="358d3-112">이 정규 예제는 인증 쿠키 또는 bearer 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-112">The canonical example of this is an authentication cookie or bearer token.</span></span> <span data-ttu-id="358d3-113">서버 생성 하는 "I am Groot 및 xyz 권한이" 토큰 되며 클라이언트에 전달 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-113">The server generates an "I am Groot and have xyz permissions" token and hands it to the client.</span></span> <span data-ttu-id="358d3-114">미래의 특정 날짜에서 클라이언트는 서버에 다시 해당 토큰을 제시 합니다 되었지만 서버 몇 가지 종류의 보증 클라이언트 토큰을 위조 되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-114">At some future date the client will present that token back to the server, but the server needs some kind of assurance that the client hasn't forged the token.</span></span> <span data-ttu-id="358d3-115">따라서 첫 번째 요구 사항: 신뢰성 (규칙 하위</span><span class="sxs-lookup"><span data-stu-id="358d3-115">Thus the first requirement: authenticity (a.k.a.</span></span> <span data-ttu-id="358d3-116">무결성, 변조 방지)입니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-116">integrity, tamper-proofing).</span></span>

<span data-ttu-id="358d3-117">지속된 상태 서버에서 신뢰할 수, 이후 예상이 상태는 운영 환경과 관련 된 정보를 포함 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-117">Since the persisted state is trusted by the server, we anticipate that this state might contain information that's specific to the operating environment.</span></span> <span data-ttu-id="358d3-118">파일 경로, 사용 권한, 핸들 또는 다른 간접 참조의 형식 또는 다른 서버 관련 데이터가 몇 가지 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-118">This could be in the form of a file path, a permission, a handle or other indirect reference, or some other piece of server-specific data.</span></span> <span data-ttu-id="358d3-119">이러한 정보 일반적으로 공개 되지 않아야 신뢰할 수 없는 클라이언트를 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-119">Such information should generally not be disclosed to an untrusted client.</span></span> <span data-ttu-id="358d3-120">따라서 두 번째 요구 사항: 기밀 유지 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-120">Thus the second requirement: confidentiality.</span></span>

<span data-ttu-id="358d3-121">마지막으로, 최신 응용 프로그램은 구성 요소화, 개괄적 이므로 개별 구성 요소는 시스템의 다른 구성 요소에 관계 없이이 시스템을 활용 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-121">Finally, since modern applications are componentized, what we've seen is that individual components will want to take advantage of this system without regard to other components in the system.</span></span> <span data-ttu-id="358d3-122">예를 들어, 전달자 토큰 구성 요소를이 스택에 사용 하는 경우 사용할 수 있는 동일한 스택을 앤티 CSRF 메커니즘에서 문제 없이 작동 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-122">For instance, if a bearer token component is using this stack, it should operate without interference from an anti-CSRF mechanism that might also be using the same stack.</span></span> <span data-ttu-id="358d3-123">따라서 최종 요구 사항: 격리 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-123">Thus the final requirement: isolation.</span></span>

<span data-ttu-id="358d3-124">가능해 집니다 추가 제약 조건 요구 사항 범위를 좁히려면 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-124">We can provide further constraints in order to narrow the scope of our requirements.</span></span> <span data-ttu-id="358d3-125">암호화 시스템 내에서 작동 하는 모든 서비스는 동일 하 게 신뢰할 수 있도록 하 고 데이터를 생성 하거나 우리의 직접 제어를 받는 서비스 외부에서 사용 된 필요 하지 않습니다 가정 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-125">We assume that all services operating within the cryptosystem are equally trusted and that the data doesn't need to be generated or consumed outside of the services under our direct control.</span></span> <span data-ttu-id="358d3-126">또한 작업은 가능한 한 빠르게 각 요청 웹 서비스에 한 번 이상 암호화는 시스템을 통해 이동할 수 있으므로 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-126">Furthermore, we require that operations are as fast as possible since each request to the web service might go through the cryptosystem one or more times.</span></span> <span data-ttu-id="358d3-127">이로써 대칭 암호화 시나리오에 대 한 이상적인 며 등 필요한에 한 번까지 비대칭 암호화 할인 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-127">This makes symmetric cryptography ideal for our scenario, and we can discount asymmetric cryptography until such a time that it's needed.</span></span>

## <a name="design-philosophy"></a><span data-ttu-id="358d3-128">디자인 원칙</span><span class="sxs-lookup"><span data-stu-id="358d3-128">Design philosophy</span></span>

<span data-ttu-id="358d3-129">기존 스택에 문제를 식별 하 여을 시작 했습니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-129">We started by identifying problems with the existing stack.</span></span> <span data-ttu-id="358d3-130">했습니다, 서버가 기존 솔루션의 가로 조사 म 고 없는 기존 솔루션에 매우 둡니다 기능에 완료 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-130">Once we had that, we surveyed the landscape of existing solutions and concluded that no existing solution quite had the capabilities we sought.</span></span> <span data-ttu-id="358d3-131">몇 가지 원칙에 따라 솔루션을 다음 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-131">We then engineered a solution based on several guiding principles.</span></span>

* <span data-ttu-id="358d3-132">시스템 구성의 단순성을 제공 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-132">The system should offer simplicity of configuration.</span></span> <span data-ttu-id="358d3-133">이상적으로 시스템은 구성이 필요 없는 개발자가 실행 중인 정확 수 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-133">Ideally the system would be zero-configuration and developers could hit the ground running.</span></span> <span data-ttu-id="358d3-134">개발자가 특정 측면 (예: 키 저장소)를 구성 해야 하는 경우에서 고려 간단한 특정 구성을 제공 하기 위해 지정 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-134">In situations where developers need to configure a specific aspect (such as the key repository), consideration should be given to making those specific configurations simple.</span></span>

* <span data-ttu-id="358d3-135">단순 소비자 용 API를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-135">Offer a simple consumer-facing API.</span></span> <span data-ttu-id="358d3-136">Api를 잘못 사용 하기 쉽고를 잘못 사용 하기 어려운 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-136">The APIs should be easy to use correctly and difficult to use incorrectly.</span></span>

* <span data-ttu-id="358d3-137">개발자는 키 관리 원칙 배울 하지 않아야 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-137">Developers shouldn't learn key management principles.</span></span> <span data-ttu-id="358d3-138">알고리즘 선택 및 개발자의를 대신 하 여 키 수명 시스템이 처리 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-138">The system should handle algorithm selection and key lifetime on the developer's behalf.</span></span> <span data-ttu-id="358d3-139">이상적으로 개발자 원시 키 자료에 액세스를 권한이 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-139">Ideally the developer should never even have access to the raw key material.</span></span>

* <span data-ttu-id="358d3-140">가능 하면 저장 된 상태의 키를 보호 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-140">Keys should be protected at rest when possible.</span></span> <span data-ttu-id="358d3-141">시스템에서는 적절 한 기본 보호 메커니즘을 파악 하 고 자동으로 적용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-141">The system should figure out an appropriate default protection mechanism and apply it automatically.</span></span>

<span data-ttu-id="358d3-142">이러한 원칙을 염두 우리는 간단한 개발 [사용 하기 쉬운](using-data-protection.md) 데이터 보호 스택의 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-142">With these principles in mind we developed a simple, [easy to use](using-data-protection.md) data protection stack.</span></span>

<span data-ttu-id="358d3-143">ASP.NET Core 데이터 보호 Api는 주로 없습니다 기밀 페이로드의 무한 지 속성.</span><span class="sxs-lookup"><span data-stu-id="358d3-143">The ASP.NET Core data protection APIs are not primarily intended for indefinite persistence of confidential payloads.</span></span> <span data-ttu-id="358d3-144">와 같은 다른 기술은 [Windows CNG DPAPI](https://msdn.microsoft.com/library/windows/desktop/hh706794%28v=vs.85%29.aspx) 및 [Azure 권한 관리](https://docs.microsoft.com/rights-management/) 무한 저장소 시나리오에 보다 적합 한까지 강력한 키 관리 기능을 갖습니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-144">Other technologies like [Windows CNG DPAPI](https://msdn.microsoft.com/library/windows/desktop/hh706794%28v=vs.85%29.aspx) and [Azure Rights Management](https://docs.microsoft.com/rights-management/) are more suited to the scenario of indefinite storage, and they have correspondingly strong key management capabilities.</span></span> <span data-ttu-id="358d3-145">즉, 개발자는 ASP.NET Core 데이터 보호 Api를 사용 하 여 기밀 데이터의 장기 보호에 대 한 일은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-145">That said, there's nothing prohibiting a developer from using the ASP.NET Core data protection APIs for long-term protection of confidential data.</span></span>

## <a name="audience"></a><span data-ttu-id="358d3-146">대상 사용자</span><span class="sxs-lookup"><span data-stu-id="358d3-146">Audience</span></span>

<span data-ttu-id="358d3-147">데이터 보호 시스템 주 다섯 개의 패키지로으로 구분 됩니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-147">The data protection system is divided into five main packages.</span></span> <span data-ttu-id="358d3-148">이러한 Api의 다양 한 측면에는 세 가지 주요 대상; 대상</span><span class="sxs-lookup"><span data-stu-id="358d3-148">Various aspects of these APIs target three main audiences;</span></span>

1. <span data-ttu-id="358d3-149">[소비자 Api 개요](consumer-apis/overview.md) 대상 프레임 워크 및 응용 프로그램 개발자.</span><span class="sxs-lookup"><span data-stu-id="358d3-149">The [Consumer APIs Overview](consumer-apis/overview.md) target application and framework developers.</span></span>

   <span data-ttu-id="358d3-150">"싶지 스택 작동 하는 방법에 대 한 또는 구성 된 방식에 대 한 자세한 내용을 알아보려면 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-150">"I don't want to learn about how the stack operates or about how it's configured.</span></span> <span data-ttu-id="358d3-151">단순히 하겠습니다 일부로 작업을 수행에 단순한 방식으로 가능한 Api를 사용 하 여 성공적으로 확률이 높은. "</span><span class="sxs-lookup"><span data-stu-id="358d3-151">I simply want to perform some operation in as simple a manner as possible with high probability of using the APIs successfully."</span></span>

2. <span data-ttu-id="358d3-152">[구성 Api](configuration/overview.md) 응용 프로그램 개발자 및 시스템 관리자가 대상으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-152">The [configuration APIs](configuration/overview.md) target application developers and system administrators.</span></span>

   <span data-ttu-id="358d3-153">"기본이 아닌 경로 또는 설정 내 환경 필요 함을 데이터 보호 시스템에 알려 하고자 합니다."</span><span class="sxs-lookup"><span data-stu-id="358d3-153">"I need to tell the data protection system that my environment requires non-default paths or settings."</span></span>

3. <span data-ttu-id="358d3-154">확장성 개발자는 Api 대상 사용자 지정 정책을 구현 하는 일을 담당 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-154">The extensibility APIs target developers in charge of implementing custom policy.</span></span> <span data-ttu-id="358d3-155">이러한 Api에 드문 경우로 제한 되 고 개발자가 인식 하는 보안을 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-155">Usage of these APIs would be limited to rare situations and experienced, security aware developers.</span></span>

   <span data-ttu-id="358d3-156">"하고자 실제로 고유 동작 요구 사항을 때문에 시스템 내에서 전체 구성 요소를 대체 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-156">"I need to replace an entire component within the system because I have truly unique behavioral requirements.</span></span> <span data-ttu-id="358d3-157">하겠습니다 내 요구 사항을 충족 하는 플러그 인을 작성 하기 위해 API 화면의 프로토콜과 사용 하지 않는 부분에 알아보려면. "</span><span class="sxs-lookup"><span data-stu-id="358d3-157">I am willing to learn uncommonly-used parts of the API surface in order to build a plugin that fulfills my requirements."</span></span>

## <a name="package-layout"></a><span data-ttu-id="358d3-158">패키지 레이아웃</span><span class="sxs-lookup"><span data-stu-id="358d3-158">Package Layout</span></span>

<span data-ttu-id="358d3-159">데이터 보호 스택의 다섯 개의 패키지로 구성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-159">The data protection stack consists of five packages.</span></span>

* <span data-ttu-id="358d3-160">Microsoft.AspNetCore.DataProtection.Abstractions 기본 IDataProtectionProvider 및 IDataProtector 인터페이스를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-160">Microsoft.AspNetCore.DataProtection.Abstractions contains the basic IDataProtectionProvider and IDataProtector interfaces.</span></span> <span data-ttu-id="358d3-161">또한 이러한 형식 (예: 오버 로드의 IDataProtector.Protect) 작업을 지원할 수 있는 유용한 확장 메서드를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-161">It also contains useful extension methods that can assist working with these types (e.g., overloads of IDataProtector.Protect).</span></span> <span data-ttu-id="358d3-162">자세한 내용은 소비자 인터페이스 단원을 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="358d3-162">See the consumer interfaces section for more information.</span></span> <span data-ttu-id="358d3-163">다른 사람에 게는 데이터 보호 시스템 인스턴스화를 담당 하는 경우 단순히 Api를 사용 하는 Microsoft.AspNetCore.DataProtection.Abstractions 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-163">If somebody else is responsible for instantiating the data protection system and you are simply consuming the APIs, you'll want to reference Microsoft.AspNetCore.DataProtection.Abstractions.</span></span>

* <span data-ttu-id="358d3-164">Microsoft.AspNetCore.DataProtection 핵심 암호화 작업, 키 관리, 구성 및 확장성을 포함 하 여 데이터 보호 시스템의 핵심 구현을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-164">Microsoft.AspNetCore.DataProtection contains the core implementation of the data protection system, including the core cryptographic operations, key management, configuration, and extensibility.</span></span> <span data-ttu-id="358d3-165">데이터 보호 시스템 인스턴스화를 담당 하는 경우 (예:에 추가 IServiceCollection)를 수정 하거나 해당 동작을 확장 해야 Microsoft.AspNetCore.DataProtection 참조 또는 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-165">If you're responsible for instantiating the data protection system (e.g., adding it to an IServiceCollection) or modifying or extending its behavior, you'll want to reference Microsoft.AspNetCore.DataProtection.</span></span>

* <span data-ttu-id="358d3-166">Microsoft.AspNetCore.DataProtection.Extensions는 개발자가 유용할 수 있지만 코어 패키지에 속해 있지 않습니다는 추가 Api를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-166">Microsoft.AspNetCore.DataProtection.Extensions contains additional APIs which developers might find useful but which don't belong in the core package.</span></span> <span data-ttu-id="358d3-167">예를 들어,이 패키지는 간단한 "종속성 주입 설치 하지 않고도 특정 키 저장소 디렉터리를 가리키는 시스템 인스턴스화할" API (추가 정보)를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-167">For instance, this package contains a simple "instantiate the system pointing at a specific key storage directory with no dependency injection setup" API (more info).</span></span> <span data-ttu-id="358d3-168">또한 보호 된 페이로드 (추가 정보)의 수명을 제한 하기 위한 확장 메서드를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-168">It also contains extension methods for limiting the lifetime of protected payloads (more info).</span></span>

* <span data-ttu-id="358d3-169">Microsoft.AspNetCore.DataProtection.SystemWeb 리디렉션하려면 기존 ASP.NET 4.x 응용 프로그램에 설치할 수 있습니다는 <machineKey> 대신 새 데이터 보호 스택을 사용 하 여 작업 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-169">Microsoft.AspNetCore.DataProtection.SystemWeb can be installed into an existing ASP.NET 4.x application to redirect its <machineKey> operations to instead use the new data protection stack.</span></span> <span data-ttu-id="358d3-170">참조 [호환성](compatibility/replacing-machinekey.md#compatibility-replacing-machinekey) 자세한 정보에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-170">See [compatibility](compatibility/replacing-machinekey.md#compatibility-replacing-machinekey) for more information.</span></span>

* <span data-ttu-id="358d3-171">Microsoft.AspNetCore.Cryptography.KeyDerivation 루틴 해시 PBKDF2 암호의 구현을 제공 하 고 사용자 암호를 안전 하 게 처리 하는 데 필요한 시스템에서 사용 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-171">Microsoft.AspNetCore.Cryptography.KeyDerivation provides an implementation of the PBKDF2 password hashing routine and can be used by systems which need to handle user passwords securely.</span></span> <span data-ttu-id="358d3-172">참조 [암호 해시](consumer-apis/password-hashing.md) 자세한 정보에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="358d3-172">See [Password Hashing](consumer-apis/password-hashing.md) for more information.</span></span>
