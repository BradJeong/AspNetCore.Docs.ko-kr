---
title: ASP.NET Core에서 라우팅
author: rick-anderson
description: ASP.NET Core 라우팅이 HTTP 요청을 일치시키고 실행 가능 엔드포인트로 디스패치하는 역할을 담당하는 방법을 알아봅니다.
monikerRange: '>= aspnetcore-2.1'
ms.author: riande
ms.custom: mvc
ms.date: 4/1/2020
no-loc:
- Blazor
- Identity
- Let's Encrypt
- Razor
- SignalR
uid: fundamentals/routing
ms.openlocfilehash: 2dd44a561debddac13250174a8e74dd912302d60
ms.sourcegitcommit: 4a9321db7ca4e69074fa08a678dcc91e16215b1e
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/06/2020
ms.locfileid: "82850515"
---
# <a name="routing-in-aspnet-core"></a><span data-ttu-id="f6d02-103">ASP.NET Core에서 라우팅</span><span class="sxs-lookup"><span data-stu-id="f6d02-103">Routing in ASP.NET Core</span></span>

<span data-ttu-id="f6d02-104">작성자: [Ryan Nowak](https://github.com/rynowak), [Kirk Larkin](https://twitter.com/serpent5) 및 [Rick Anderson](https://twitter.com/RickAndMSFT)</span><span class="sxs-lookup"><span data-stu-id="f6d02-104">By [Ryan Nowak](https://github.com/rynowak), [Kirk Larkin](https://twitter.com/serpent5), and [Rick Anderson](https://twitter.com/RickAndMSFT)</span></span>

::: moniker range=">= aspnetcore-3.0"

<span data-ttu-id="f6d02-105">라우팅은 들어오는 HTTP 요청을 일치시켜 앱의 실행 가능 엔드포인트로 디스패치하는 역할을 담당합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-105">Routing is responsible for matching incoming HTTP requests and dispatching those requests to the app's executable endpoints.</span></span> <span data-ttu-id="f6d02-106">[엔드포인트](#endpoint)는 앱의 실행 가능 요청 처리 코드 단위입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-106">[Endpoints](#endpoint) are the app's units of executable request-handling code.</span></span> <span data-ttu-id="f6d02-107">엔드포인트는 앱에서 정의되고 앱 시작 시 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-107">Endpoints are defined in the app and configured when the app starts.</span></span> <span data-ttu-id="f6d02-108">엔드포인트 일치 프로세스는 요청의 URL에서 값을 추출하고 요청 처리를 위해 이 값을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-108">The endpoint matching process can extract values from the request's URL and provide those values for request processing.</span></span> <span data-ttu-id="f6d02-109">또한 라우팅은 앱의 엔드포인트 정보를 사용하여 엔드포인트에 매핑되는 URL을 생성할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-109">Using endpoint information from the app, routing is also able to generate URLs that map to endpoints.</span></span>

<span data-ttu-id="f6d02-110">앱은 다음을 사용하여 라우팅을 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-110">Apps can configure routing using:</span></span>

- <span data-ttu-id="f6d02-111">Controllers</span><span class="sxs-lookup"><span data-stu-id="f6d02-111">Controllers</span></span>
- <span data-ttu-id="f6d02-112">Razor 페이지</span><span class="sxs-lookup"><span data-stu-id="f6d02-112">Razor Pages</span></span>
- <span data-ttu-id="f6d02-113">SignalR</span><span class="sxs-lookup"><span data-stu-id="f6d02-113">SignalR</span></span>
- <span data-ttu-id="f6d02-114">gRPC 서비스</span><span class="sxs-lookup"><span data-stu-id="f6d02-114">gRPC Services</span></span>
- <span data-ttu-id="f6d02-115">[상태 검사](xref:host-and-deploy/health-checks)와 같은 엔드포인트 지원 [미들웨어](xref:fundamentals/middleware/index)</span><span class="sxs-lookup"><span data-stu-id="f6d02-115">Endpoint-enabled [middleware](xref:fundamentals/middleware/index) such as [Health Checks](xref:host-and-deploy/health-checks).</span></span>
- <span data-ttu-id="f6d02-116">라우팅에 등록된 대리자 및 람다</span><span class="sxs-lookup"><span data-stu-id="f6d02-116">Delegates and lambdas registered with routing.</span></span>

<span data-ttu-id="f6d02-117">이 문서에서는 ASP.NET Core 라우팅의 하위 수준 세부 정보를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-117">This document covers low-level details of ASP.NET Core routing.</span></span> <span data-ttu-id="f6d02-118">라우팅을 구성하는 방법은 다음을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-118">For information on configuring routing:</span></span>

* <span data-ttu-id="f6d02-119">컨트롤러의 경우 <xref:mvc/controllers/routing>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-119">For controllers, see <xref:mvc/controllers/routing>.</span></span>
* <span data-ttu-id="f6d02-120">Razor Pages 규칙은 <xref:razor-pages/razor-pages-conventions>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-120">For Razor Pages conventions, see <xref:razor-pages/razor-pages-conventions>.</span></span>

<span data-ttu-id="f6d02-121">이 문서에서 설명하는 엔드포인트 라우팅 시스템은 ASP.NET Core 3.0 이상에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-121">The endpoint routing system described in this document applies to ASP.NET Core 3.0 and later.</span></span> <span data-ttu-id="f6d02-122"><xref:Microsoft.AspNetCore.Routing.IRouter> 기반의 이전 라우팅 시스템에 대한 자세한 내용은 다음 접근 방법 중 하나를 사용하여 ASP.NET Core 2.1 버전을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-122">For information on the previous routing system based on <xref:Microsoft.AspNetCore.Routing.IRouter>, select the ASP.NET Core 2.1 version using one of the following approaches:</span></span>

* <span data-ttu-id="f6d02-123">이전 버전의 버전 선택기</span><span class="sxs-lookup"><span data-stu-id="f6d02-123">The version selector for a previous version.</span></span>
* <span data-ttu-id="f6d02-124">[ASP.NET Core 2.1 라우팅](https://docs.microsoft.com/aspnet/core/fundamentals/routing?view=aspnetcore-2.1) 선택</span><span class="sxs-lookup"><span data-stu-id="f6d02-124">Select [ASP.NET Core 2.1 routing](https://docs.microsoft.com/aspnet/core/fundamentals/routing?view=aspnetcore-2.1).</span></span>

<span data-ttu-id="f6d02-125">[예제 코드 살펴보기 및 다운로드](https://github.com/aspnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/routing/samples/3.x) ([다운로드 방법](xref:index#how-to-download-a-sample))</span><span class="sxs-lookup"><span data-stu-id="f6d02-125">[View or download sample code](https://github.com/aspnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/routing/samples/3.x) ([how to download](xref:index#how-to-download-a-sample))</span></span>

<span data-ttu-id="f6d02-126">이 문서의 다운로드 샘플은 특정 `Startup` 클래스를 통해 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-126">The download samples for this document are enabled by a specific `Startup` class.</span></span> <span data-ttu-id="f6d02-127">특정 샘플을 실행하려면 *Program.cs*를 수정하여 원하는 `Startup` 클래스를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-127">To run a specific sample, modify *Program.cs* to call the desired `Startup` class.</span></span>

## <a name="routing-basics"></a><span data-ttu-id="f6d02-128">라우팅 기본 사항</span><span class="sxs-lookup"><span data-stu-id="f6d02-128">Routing basics</span></span>

<span data-ttu-id="f6d02-129">모든 ASP.NET Core 템플릿에는 생성된 코드에서의 라우팅이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-129">All ASP.NET Core templates include routing in the generated code.</span></span> <span data-ttu-id="f6d02-130">라우팅은 `Startup.Configure`의 [미들웨어](xref:fundamentals/middleware/index) 파이프라인에 등록됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-130">Routing is registered in the [middleware](xref:fundamentals/middleware/index) pipeline in `Startup.Configure`.</span></span>

<span data-ttu-id="f6d02-131">다음 코드에서는 라우팅의 기본 예제를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-131">The following code shows a basic example of routing:</span></span>

[!code-csharp[](routing/samples/3.x/RoutingSample/Startup.cs?name=snippet&highlight=8,10)]

<span data-ttu-id="f6d02-132">라우팅은 <xref:Microsoft.AspNetCore.Builder.EndpointRoutingApplicationBuilderExtensions.UseRouting*> 및 <xref:Microsoft.AspNetCore.Builder.EndpointRoutingApplicationBuilderExtensions.UseEndpoints*>를 통해 등록된 미들웨어 쌍을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-132">Routing uses a pair of middleware, registered by <xref:Microsoft.AspNetCore.Builder.EndpointRoutingApplicationBuilderExtensions.UseRouting*> and <xref:Microsoft.AspNetCore.Builder.EndpointRoutingApplicationBuilderExtensions.UseEndpoints*>:</span></span>

* <span data-ttu-id="f6d02-133">`UseRouting`은 경로 일치를 미들웨어 파이프라인에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-133">`UseRouting` adds route matching to the middleware pipeline.</span></span> <span data-ttu-id="f6d02-134">이 미들웨어는 앱에 정의된 엔드포인트 집합을 확인하고 요청을 기반으로 [가장 일치하는 항목](#urlm)을 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-134">This middleware looks at the set of endpoints defined in the app, and selects the [best match](#urlm) based on the request.</span></span>
* <span data-ttu-id="f6d02-135">`UseEndpoints`는 엔드포인트 실행을 미들웨어 파이프라인에 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-135">`UseEndpoints` adds endpoint execution to the middleware pipeline.</span></span> <span data-ttu-id="f6d02-136">선택한 엔드포인트와 연결된 대리자를 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-136">It runs the delegate associated with the selected endpoint.</span></span>

<span data-ttu-id="f6d02-137">앞의 예제에는 [MapGet](xref:Microsoft.AspNetCore.Builder.EndpointRouteBuilderExtensions.MapGet*) 메서드를 사용하는 단일 ‘라우팅 대상 코드’ 엔드포인트가 포함됩니다  .</span><span class="sxs-lookup"><span data-stu-id="f6d02-137">The preceding example includes a single *route to code* endpoint using the [MapGet](xref:Microsoft.AspNetCore.Builder.EndpointRouteBuilderExtensions.MapGet*) method:</span></span>

* <span data-ttu-id="f6d02-138">HTTP `GET` 요청이 루트 URL `/`로 전송되면 다음과 같이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-138">When an HTTP `GET` request is sent to the root URL `/`:</span></span>
  * <span data-ttu-id="f6d02-139">표시된 요청 대리자가 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-139">The request delegate shown executes.</span></span>
  * <span data-ttu-id="f6d02-140">`Hello World!`가 HTTP 응답에 기록됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-140">`Hello World!` is written to the HTTP response.</span></span> <span data-ttu-id="f6d02-141">기본적으로 루트 URL `/`는 `https://localhost:5001/`입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-141">By default, the root URL `/` is `https://localhost:5001/`.</span></span>
* <span data-ttu-id="f6d02-142">요청 메서드가 `GET`이 아니거나 루트 URL이 `/`가 아니면 일치하는 경로가 없고 HTTP 404가 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-142">If the request method is not `GET` or the root URL is not `/`, no route matches and an HTTP 404 is returned.</span></span>

### <a name="endpoint"></a><span data-ttu-id="f6d02-143">엔드포인트</span><span class="sxs-lookup"><span data-stu-id="f6d02-143">Endpoint</span></span>

<a name="endpoint"></a>

<span data-ttu-id="f6d02-144">`MapGet` 메서드는 **엔드포인트**을 정의하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-144">The `MapGet` method is used to define an **endpoint**.</span></span> <span data-ttu-id="f6d02-145">엔드포인트는 다음과 같을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-145">An endpoint is something that can be:</span></span>

* <span data-ttu-id="f6d02-146">URL 및 HTTP 메서드를 일치시켜 선택됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-146">Selected, by matching the URL and HTTP method.</span></span>
* <span data-ttu-id="f6d02-147">대리자를 실행하여 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-147">Executed, by running the delegate.</span></span>

<span data-ttu-id="f6d02-148">앱에서 일치시키고 실행할 수 있는 엔드포인트는 `UseEndpoints`에서 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-148">Endpoints that can be matched and executed by the app are configured in `UseEndpoints`.</span></span> <span data-ttu-id="f6d02-149">예를 들어 <xref:Microsoft.AspNetCore.Builder.EndpointRouteBuilderExtensions.MapGet*>, <xref:Microsoft.AspNetCore.Builder.EndpointRouteBuilderExtensions.MapPost*> 및 [이들과 유사한 메서드](xref:Microsoft.AspNetCore.Builder.EndpointRouteBuilderExtensions)는 요청 대리자를 라우팅 시스템에 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-149">For example, <xref:Microsoft.AspNetCore.Builder.EndpointRouteBuilderExtensions.MapGet*>, <xref:Microsoft.AspNetCore.Builder.EndpointRouteBuilderExtensions.MapPost*>, and [similar methods](xref:Microsoft.AspNetCore.Builder.EndpointRouteBuilderExtensions) connect request delegates to the routing system.</span></span>
<span data-ttu-id="f6d02-150">ASP.NET Core Framework 기능을 라우팅 시스템에 연결하는 데 다음과 같은 추가 메서드를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-150">Additional methods can be used to connect ASP.NET Core framework features to the routing system:</span></span>
- [<span data-ttu-id="f6d02-151">Razor Pages의 MapRazorPages</span><span class="sxs-lookup"><span data-stu-id="f6d02-151">MapRazorPages for Razor Pages</span></span>](xref:Microsoft.AspNetCore.Builder.RazorPagesEndpointRouteBuilderExtensions.MapRazorPages*)
- [<span data-ttu-id="f6d02-152">컨트롤러의 MapControllers</span><span class="sxs-lookup"><span data-stu-id="f6d02-152">MapControllers for controllers</span></span>](xref:Microsoft.AspNetCore.Builder.ControllerEndpointRouteBuilderExtensions.MapControllers*)
- [<span data-ttu-id="f6d02-153">SignalR의 MapHub\<THub></span><span class="sxs-lookup"><span data-stu-id="f6d02-153">MapHub\<THub> for SignalR</span></span>](xref:Microsoft.AspNetCore.SignalR.HubRouteBuilder.MapHub*) 
- [<span data-ttu-id="f6d02-154">gRPC의 MapGrpcService\<TService></span><span class="sxs-lookup"><span data-stu-id="f6d02-154">MapGrpcService\<TService> for gRPC</span></span>](xref:grpc/aspnetcore)

<span data-ttu-id="f6d02-155">다음 예제에서는 더 복잡한 경로 템플릿을 사용한 라우팅을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-155">The following example shows routing with a more sophisticated route template:</span></span>

[!code-csharp[](routing/samples/3.x/RoutingSample/RouteTemplateStartup.cs?name=snippet)]

<span data-ttu-id="f6d02-156">`/hello/{name:alpha}` 문자열은 **경로 템플릿**이며</span><span class="sxs-lookup"><span data-stu-id="f6d02-156">The string `/hello/{name:alpha}` is a **route template**.</span></span> <span data-ttu-id="f6d02-157">엔드포인트가 일치되는 방식을 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-157">It is used to configure how the endpoint is matched.</span></span> <span data-ttu-id="f6d02-158">이 경우 템플릿은 다음과 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-158">In this case, the template matches:</span></span>

* <span data-ttu-id="f6d02-159">`/hello/Ryan`과 같은 URL</span><span class="sxs-lookup"><span data-stu-id="f6d02-159">A URL like `/hello/Ryan`</span></span>
* <span data-ttu-id="f6d02-160">`/hello/`로 시작하고 그 다음에 시퀀스 영문자가 오는 URL 경로.</span><span class="sxs-lookup"><span data-stu-id="f6d02-160">Any URL path that begins with `/hello/` followed by a sequence of alphabetic characters.</span></span>  <span data-ttu-id="f6d02-161">`:alpha`는 영문자와만 일치하는 경로 제약 조건을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-161">`:alpha` applies a route constraint that matches only alphabetic characters.</span></span> <span data-ttu-id="f6d02-162">[경로 제약 조건](#route-constraint-reference)은 이 문서의 뒷부분에 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-162">[Route constraints](#route-constraint-reference) are explained later in this document.</span></span>

<span data-ttu-id="f6d02-163">URL 경로의 두 번째 세그먼트 `{name:alpha}`는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-163">The second segment of the URL path, `{name:alpha}`:</span></span>

* <span data-ttu-id="f6d02-164">`name` 매개 변수에 바인딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-164">Is bound to the `name` parameter.</span></span>
* <span data-ttu-id="f6d02-165">[HttpRequest.RouteValues](xref:Microsoft.AspNetCore.Http.HttpRequest.RouteValues*)에 캡처되고 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-165">Is captured and stored in [HttpRequest.RouteValues](xref:Microsoft.AspNetCore.Http.HttpRequest.RouteValues*).</span></span>

<span data-ttu-id="f6d02-166">이 문서에서 설명하는 엔드포인트는 라우팅 시스템은 ASP.NET Core 3.0의 새로운 기능입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-166">The endpoint routing system described in this document is new as of ASP.NET Core 3.0.</span></span> <span data-ttu-id="f6d02-167">그러나 모든 버전의 ASP.NET Core에서 동일한 경로 템플릿 기능 및 경로 제약 조건 집합을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-167">However, all versions of ASP.NET Core support the same set of route template features and route constraints.</span></span>

<span data-ttu-id="f6d02-168">다음 예제에서는 [상태 검사](xref:host-and-deploy/health-checks) 및 권한 부여를 사용한 라우팅을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-168">The following example shows routing with [health checks](xref:host-and-deploy/health-checks) and authorization:</span></span>

[!code-csharp[](routing/samples/3.x/RoutingSample/AuthorizationStartup.cs?name=snippet)]

[!INCLUDE[request localized comments](~/includes/code-comments-loc.md)]

<span data-ttu-id="f6d02-169">앞의 예제에서는 다음을 수행하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-169">The preceding example demonstrates how:</span></span>

* <span data-ttu-id="f6d02-170">권한 부여 미들웨어를 라우팅에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-170">The authorization middleware can be used with routing.</span></span>
* <span data-ttu-id="f6d02-171">엔드포인트를 사용하여 권한 부여 동작을 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-171">Endpoints can be used to configure authorization behavior.</span></span>

<span data-ttu-id="f6d02-172"><xref:Microsoft.AspNetCore.Builder.HealthCheckEndpointRouteBuilderExtensions.MapHealthChecks*> 호출은 상태 검사 엔드포인트를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-172">The <xref:Microsoft.AspNetCore.Builder.HealthCheckEndpointRouteBuilderExtensions.MapHealthChecks*> call adds a health check endpoint.</span></span> <span data-ttu-id="f6d02-173">이 호출에 <xref:Microsoft.AspNetCore.Builder.AuthorizationEndpointConventionBuilderExtensions.RequireAuthorization*>을 연결하면 권한 부여 정책이 엔드포인트에 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-173">Chaining <xref:Microsoft.AspNetCore.Builder.AuthorizationEndpointConventionBuilderExtensions.RequireAuthorization*> on to this call attaches an authorization policy to the endpoint.</span></span>

<span data-ttu-id="f6d02-174"><xref:Microsoft.AspNetCore.Builder.AuthAppBuilderExtensions.UseAuthentication*> 및 <xref:Microsoft.AspNetCore.Builder.AuthorizationAppBuilderExtensions.UseAuthorization*>을 호출하면 인증 및 권한 부여 미들웨어가 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-174">Calling <xref:Microsoft.AspNetCore.Builder.AuthAppBuilderExtensions.UseAuthentication*> and <xref:Microsoft.AspNetCore.Builder.AuthorizationAppBuilderExtensions.UseAuthorization*> adds the authentication and authorization middleware.</span></span> <span data-ttu-id="f6d02-175">이러한 미들웨어는 <xref:Microsoft.AspNetCore.Builder.EndpointRoutingApplicationBuilderExtensions.UseRouting*>과 `UseEndpoints` 사이에 배치되므로 다음을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-175">These middleware are placed between <xref:Microsoft.AspNetCore.Builder.EndpointRoutingApplicationBuilderExtensions.UseRouting*> and `UseEndpoints` so that they can:</span></span>

* <span data-ttu-id="f6d02-176">`UseRouting`에서 선택된 엔드포인트를 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-176">See which endpoint was selected by `UseRouting`.</span></span>
* <span data-ttu-id="f6d02-177">엔드포인트로 <xref:Microsoft.AspNetCore.Builder.EndpointRoutingApplicationBuilderExtensions.UseEndpoints*>가 디스패치되기 전에 권한 부여 정책을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-177">Apply an authorization policy before <xref:Microsoft.AspNetCore.Builder.EndpointRoutingApplicationBuilderExtensions.UseEndpoints*> dispatches to the endpoint.</span></span>

<a name="metadata"></a>

### <a name="endpoint-metadata"></a><span data-ttu-id="f6d02-178">엔드포인트 메타데이터</span><span class="sxs-lookup"><span data-stu-id="f6d02-178">Endpoint metadata</span></span>

<span data-ttu-id="f6d02-179">앞의 예제에는 두 개의 엔드포인트가 있지만 상태 검사 엔드포인트에만 권한 부여 정책이 연결되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-179">In the preceding example, there are two endpoints, but only the health check endpoint has an authorization policy attached.</span></span> <span data-ttu-id="f6d02-180">요청이 상태 검사 엔드포인트 `/healthz`와 일치하는 경우 권한 부여 확인이 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-180">If the request matches the health check endpoint, `/healthz`, an authorization check is performed.</span></span> <span data-ttu-id="f6d02-181">이는 엔드포인트에 추가 데이터가 연결될 수 있음을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-181">This demonstrates that endpoints can have extra data attached to them.</span></span> <span data-ttu-id="f6d02-182">이러한 추가 데이터를 엔드포인트 **메타데이터**라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-182">This extra data is called endpoint **metadata**:</span></span>

* <span data-ttu-id="f6d02-183">이 메타데이터는 라우팅 인식 미들웨어에서 처리될 수 있으며</span><span class="sxs-lookup"><span data-stu-id="f6d02-183">The metadata can be processed by routing-aware middleware.</span></span>
* <span data-ttu-id="f6d02-184">모든 .NET 형식일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-184">The metadata can be of any .NET type.</span></span>

## <a name="routing-concepts"></a><span data-ttu-id="f6d02-185">라우팅 개념</span><span class="sxs-lookup"><span data-stu-id="f6d02-185">Routing concepts</span></span>

<span data-ttu-id="f6d02-186">라우팅 시스템은 강력한 **엔드포인트** 개념을 추가하여 미들웨어 파이프라인을 기반으로 빌드됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-186">The routing system builds on top of the middleware pipeline by adding the powerful **endpoint** concept.</span></span> <span data-ttu-id="f6d02-187">엔드포인트는 라우팅, 권한 부여 및 ASP.NET Core 시스템 수의 측면에서 서로 다른 앱의 기능 단위를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-187">Endpoints represent units of the app's functionality that are distinct from each other in terms of routing, authorization, and any number of ASP.NET Core's systems.</span></span>

<a name="endpoint"></a>

### <a name="aspnet-core-endpoint-definition"></a><span data-ttu-id="f6d02-188">ASP.NET Core 엔드포인트 정의</span><span class="sxs-lookup"><span data-stu-id="f6d02-188">ASP.NET Core endpoint definition</span></span>

<span data-ttu-id="f6d02-189">ASP.NET Core 엔드포인트는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-189">An ASP.NET Core endpoint is:</span></span>

* <span data-ttu-id="f6d02-190">실행 가능: <xref:Microsoft.AspNetCore.Http.Endpoint.RequestDelegate>가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-190">Executable: Has a <xref:Microsoft.AspNetCore.Http.Endpoint.RequestDelegate>.</span></span>
* <span data-ttu-id="f6d02-191">확장 가능: [메타데이터](xref:Microsoft.AspNetCore.Http.Endpoint.Metadata*) 컬렉션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-191">Extensible: Has a [Metadata](xref:Microsoft.AspNetCore.Http.Endpoint.Metadata*) collection.</span></span>
* <span data-ttu-id="f6d02-192">Selectable: 필요에 따라 [라우팅 정보](xref:Microsoft.AspNetCore.Routing.RouteEndpoint.RoutePattern*)가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-192">Selectable: Optionally, has [routing information](xref:Microsoft.AspNetCore.Routing.RouteEndpoint.RoutePattern*).</span></span>
* <span data-ttu-id="f6d02-193">열거 가능: [DI](xref:fundamentals/dependency-injection)에서 <xref:Microsoft.AspNetCore.Routing.EndpointDataSource>를 검색하여 엔드포인트 컬렉션을 나열할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-193">Enumerable: The collection of endpoints can be listed by retrieving the <xref:Microsoft.AspNetCore.Routing.EndpointDataSource> from [DI](xref:fundamentals/dependency-injection).</span></span>

<span data-ttu-id="f6d02-194">다음 코드에서는 현재 요청과 일치하는 엔드포인트를 검색하고 검사하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-194">The following code shows how to retrieve and inspect the endpoint matching the current request:</span></span>

[!code-csharp[](routing/samples/3.x/RoutingSample/EndpointInspectorStartup.cs?name=snippet)]

<span data-ttu-id="f6d02-195">엔드포인트는 선택된 경우 `HttpContext`에서 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-195">The endpoint, if selected, can be retrieved from the `HttpContext`.</span></span> <span data-ttu-id="f6d02-196">해당 속성을 검사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-196">Its properties can be inspected.</span></span> <span data-ttu-id="f6d02-197">엔드포인트 개체는 변경할 수 없으며 만든 후 수정할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-197">Endpoint objects are immutable and cannot be modified after creation.</span></span> <span data-ttu-id="f6d02-198">가장 일반적인 형식의 엔드포인트는 <xref:Microsoft.AspNetCore.Routing.RouteEndpoint>입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-198">The most common type of endpoint is a <xref:Microsoft.AspNetCore.Routing.RouteEndpoint>.</span></span> <span data-ttu-id="f6d02-199">`RouteEndpoint`에는 라우팅 시스템에서 선택할 수 있는 정보가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-199">`RouteEndpoint` includes information that allows it to be to selected by the routing system.</span></span>

<span data-ttu-id="f6d02-200">앞의 코드에서 [app.Use](xref:Microsoft.AspNetCore.Builder.UseExtensions.Use*)는 인라인 [미들웨어](xref:fundamentals/middleware/index)를 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-200">In the preceding code, [app.Use](xref:Microsoft.AspNetCore.Builder.UseExtensions.Use*) configures an in-line [middleware](xref:fundamentals/middleware/index).</span></span>

<a name="mt"></a>

<span data-ttu-id="f6d02-201">다음 코드에서는 파이프라인에서 `app.Use`가 호출되는 위치에 따라 엔드포인트가 없을 수 있음을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-201">The following code shows that, depending on where `app.Use` is called in the pipeline, there may not be an endpoint:</span></span>

[!code-csharp[](routing/samples/3.x/RoutingSample/MiddlewareFlowStartup.cs?name=snippet)]

<span data-ttu-id="f6d02-202">위의 샘플에서는 엔드포인트가 선택되었는지 아닌지를 표시하는 `Console.WriteLine` 문을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-202">This preceding sample adds `Console.WriteLine` statements that display whether or not an endpoint has been selected.</span></span> <span data-ttu-id="f6d02-203">명확하게 하도록 이 샘플에서는 제공된 `/` 엔드포인트에 표시 이름을 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-203">For clarity, the sample assigns a display name to the provided `/` endpoint.</span></span>

<span data-ttu-id="f6d02-204">`/`의 URL을 사용하여 이 코드를 실행하면 다음이 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-204">Running this code with a URL of `/` displays:</span></span>

```txt
1. Endpoint: (null)
2. Endpoint: Hello
3. Endpoint: Hello
```

<span data-ttu-id="f6d02-205">다른 URL을 사용하여 이 코드를 실행하면 다음이 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-205">Running this code with any other URL displays:</span></span>

```txt
1. Endpoint: (null)
2. Endpoint: (null)
4. Endpoint: (null)
```

<span data-ttu-id="f6d02-206">이 출력은 다음을 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-206">This output demonstrates that:</span></span>

* <span data-ttu-id="f6d02-207">`UseRouting`을 호출하기 전에 엔드포인트는 항상 null입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-207">The endpoint is always null before `UseRouting` is called.</span></span>
* <span data-ttu-id="f6d02-208">일치 항목이 발견되면 `UseRouting`와 <xref:Microsoft.AspNetCore.Builder.EndpointRoutingApplicationBuilderExtensions.UseEndpoints*>사이에서 엔드포인트가 null이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-208">If a match is found, the endpoint is non-null between `UseRouting` and <xref:Microsoft.AspNetCore.Builder.EndpointRoutingApplicationBuilderExtensions.UseEndpoints*>.</span></span>
* <span data-ttu-id="f6d02-209">일치 항목이 발견되면 `UseEndpoints` 미들웨어가 **터미널**입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-209">The `UseEndpoints` middleware is **terminal** when a match is found.</span></span> <span data-ttu-id="f6d02-210">[터미널 미들웨어](#tm)는 이 문서의 뒷부분에 정의되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-210">[Terminal middleware](#tm) is defined later in this document.</span></span>
* <span data-ttu-id="f6d02-211">`UseEndpoints` 뒤의 미들웨어는 일치 항목이 없는 경우에만 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-211">The middleware after `UseEndpoints` execute only when no match is found.</span></span>

<span data-ttu-id="f6d02-212">`UseRouting` 미들웨어는 [SetEndpoint](xref:Microsoft.AspNetCore.Http.EndpointHttpContextExtensions.SetEndpoint*) 메서드를 사용하여 엔드포인트를 현재 컨텍스트에 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-212">The `UseRouting` middleware uses the [SetEndpoint](xref:Microsoft.AspNetCore.Http.EndpointHttpContextExtensions.SetEndpoint*) method to attach the endpoint to the current context.</span></span> <span data-ttu-id="f6d02-213">`UseRouting` 미들웨어를 사용자 지정 논리로 바꾸어도 엔드포인트를 사용하는 이점을 얻을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-213">It's possible to replace the `UseRouting` middleware with custom logic and still get the benefits of using endpoints.</span></span> <span data-ttu-id="f6d02-214">엔드포인트는 미들웨어와 같은 하위 수준 기본 형식이며 라우팅 구현에 결합되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-214">Endpoints are a low-level primitive like middleware, and aren't coupled to the routing implementation.</span></span> <span data-ttu-id="f6d02-215">대부분의 앱에서는 `UseRouting`을 사용자 지정 논리로 바꿀 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-215">Most apps don't need to replace `UseRouting` with custom logic.</span></span>

<span data-ttu-id="f6d02-216">`UseEndpoints` 미들웨어는 `UseRouting` 미들웨어와 함께 사용하기 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-216">The `UseEndpoints` middleware is designed to be used in tandem with the `UseRouting` middleware.</span></span> <span data-ttu-id="f6d02-217">엔드포인트를 실행하는 핵심 논리는 복잡하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-217">The core logic to execute an endpoint isn't complicated.</span></span> <span data-ttu-id="f6d02-218"><xref:Microsoft.AspNetCore.Http.EndpointHttpContextExtensions.GetEndpoint*>를 사용하여 엔드포인트를 검색한 다음 해당 <xref:Microsoft.AspNetCore.Http.Endpoint.RequestDelegate> 속성을 호출하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-218">Use <xref:Microsoft.AspNetCore.Http.EndpointHttpContextExtensions.GetEndpoint*> to retrieve the endpoint, and then invoke its <xref:Microsoft.AspNetCore.Http.Endpoint.RequestDelegate> property.</span></span>

<span data-ttu-id="f6d02-219">다음 코드에서는 미들웨어가 라우팅에 영향을 주거나 반응하는 방식을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-219">The following code demonstrates how middleware can influence or react to routing:</span></span>

[!code-csharp[](routing/samples/3.x/RoutingSample/IntegratedMiddlewareStartup.cs?name=snippet)]

<span data-ttu-id="f6d02-220">앞의 예제에서는 다음과 같은 두 가지 중요한 개념을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-220">The preceding example demonstrates two important concepts:</span></span>

* <span data-ttu-id="f6d02-221">미들웨어는 `UseRouting` 전에 실행되어 라우팅 작동의 기반이 되는 데이터를 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-221">Middleware can run before `UseRouting` to modify the data that routing operates upon.</span></span>
    * <span data-ttu-id="f6d02-222">일반적으로 라우팅 전에 표시되는 미들웨어는 <xref:Microsoft.AspNetCore.Builder.RewriteBuilderExtensions.UseRewriter*>, <xref:Microsoft.AspNetCore.Builder.HttpMethodOverrideExtensions.UseHttpMethodOverride*>또는 <xref:Microsoft.AspNetCore.Builder.UsePathBaseExtensions.UsePathBase*>와 같은 요청의 일부 속성을 수정합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-222">Usually middleware that appears before routing modifies some property of the request, such as <xref:Microsoft.AspNetCore.Builder.RewriteBuilderExtensions.UseRewriter*>, <xref:Microsoft.AspNetCore.Builder.HttpMethodOverrideExtensions.UseHttpMethodOverride*>, or <xref:Microsoft.AspNetCore.Builder.UsePathBaseExtensions.UsePathBase*>.</span></span>
* <span data-ttu-id="f6d02-223">미들웨어는 `UseRouting`과 <xref:Microsoft.AspNetCore.Builder.EndpointRoutingApplicationBuilderExtensions.UseEndpoints*> 사이에서 실행되어 엔드포인트가 실행되기 전에 라우팅의 결과를 처리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-223">Middleware can run between `UseRouting` and <xref:Microsoft.AspNetCore.Builder.EndpointRoutingApplicationBuilderExtensions.UseEndpoints*> to process the results of routing before the endpoint is executed.</span></span>
    * <span data-ttu-id="f6d02-224">`UseRouting`과 `UseEndpoints` 사이에서 실행되는 미들웨어는 다음을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-224">Middleware that runs between `UseRouting` and `UseEndpoints`:</span></span>
      * <span data-ttu-id="f6d02-225">일반적으로 메타데이터를 검사하여 엔드포인트를 이해합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-225">Usually inspects metadata to understand the endpoints.</span></span>
      * <span data-ttu-id="f6d02-226">`UseAuthorization` 및 `UseCors`에서 하는 것처럼 보안 결정을 내리는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-226">Often makes security decisions, as done by `UseAuthorization` and `UseCors`.</span></span>
    * <span data-ttu-id="f6d02-227">미들웨어와 메타데이터를 조합하면 엔드포인트별로 정책을 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-227">The combination of middleware and metadata allows configuring policies per-endpoint.</span></span>

<span data-ttu-id="f6d02-228">위의 코드에서는 엔드포인트별 정책을 지원하는 사용자 지정 미들웨어의 예를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-228">The preceding code shows an example of a custom middleware that supports per-endpoint policies.</span></span> <span data-ttu-id="f6d02-229">이 미들웨어는 중요한 데이터에 대한 액세스의 ‘감사 로그’를 콘솔에 기록합니다. </span><span class="sxs-lookup"><span data-stu-id="f6d02-229">The middleware writes an *audit log* of access to sensitive data to the console.</span></span> <span data-ttu-id="f6d02-230">`AuditPolicyAttribute` 메타데이터를 사용하여 엔드포인트를 ‘감사’하도록 미들웨어를 구성할 수 있습니다. </span><span class="sxs-lookup"><span data-stu-id="f6d02-230">The middleware can be configured to *audit* an endpoint with the `AuditPolicyAttribute` metadata.</span></span> <span data-ttu-id="f6d02-231">이 샘플에서는 중요함으로 표시된 엔드포인트만 감사되는 ‘옵트인 패턴’을 보여 줍니다  .</span><span class="sxs-lookup"><span data-stu-id="f6d02-231">This sample demonstrates an *opt-in* pattern where only endpoints that are marked as sensitive are audited.</span></span> <span data-ttu-id="f6d02-232">예를 들어 이 논리를 역으로 정의하여 안전한 것으로 표시되지 않은 모든 항목을 감사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-232">It's possible to define this logic in reverse, auditing everything that isn't marked as safe, for example.</span></span> <span data-ttu-id="f6d02-233">엔드포인트 메타데이터 시스템은 유연합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-233">The endpoint metadata system is flexible.</span></span> <span data-ttu-id="f6d02-234">이 논리는 사용 사례에 적합한 방식으로 설계할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-234">This logic could be designed in whatever way suits the use case.</span></span>

<span data-ttu-id="f6d02-235">앞의 샘플 코드는 엔드포인트의 기본 개념을 보여 주기 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-235">The preceding sample code is intended to demonstrate the basic concepts of endpoints.</span></span> <span data-ttu-id="f6d02-236">**프로덕션 용도로는 사용하지 않아야 합니다**.</span><span class="sxs-lookup"><span data-stu-id="f6d02-236">**The sample is not intended for production use**.</span></span> <span data-ttu-id="f6d02-237">‘감사 로그’ 미들웨어의 전체 버전은 다음과 같습니다. </span><span class="sxs-lookup"><span data-stu-id="f6d02-237">A more complete version of an *audit log* middleware would:</span></span>

* <span data-ttu-id="f6d02-238">파일이나 데이터베이스에 기록합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-238">Log to a file or database.</span></span>
* <span data-ttu-id="f6d02-239">사용자, IP 주소, 중요한 엔드포인트의 이름 등과 같은 세부 정보를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-239">Include details such as the user, IP address, name of the sensitive endpoint, and more.</span></span>

<span data-ttu-id="f6d02-240">감사 정책 메타데이터 `AuditPolicyAttribute`는 컨트롤러 및 SignalR와 같은 클래스 기반 프레임워크에서 더욱 쉽게 사용할 수 있도록 `Attribute`로 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-240">The audit policy metadata `AuditPolicyAttribute` is defined as an `Attribute` for easier use with class-based frameworks such as controllers and SignalR.</span></span> <span data-ttu-id="f6d02-241">‘라우팅 대상 코드’를 사용하면 다음과 같이  .</span><span class="sxs-lookup"><span data-stu-id="f6d02-241">When using *route to code*:</span></span>

* <span data-ttu-id="f6d02-242">메타데이터가 작성기 API와 연결됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-242">Metadata is attached with a builder API.</span></span>
* <span data-ttu-id="f6d02-243">엔드포인트를 만들 때 해당 메서드 및 클래스의 모든 특성이 클래스 기반 프레임워크에 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-243">Class-based frameworks include all attributes on the corresponding method and class when creating endpoints.</span></span>

<span data-ttu-id="f6d02-244">메타데이터 형식은 인터페이스나 특성으로 정의하는 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-244">The best practices for metadata types are to define them either as interfaces or attributes.</span></span> <span data-ttu-id="f6d02-245">인터페이스 및 특성을 사용하면 코드를 다시 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-245">Interfaces and attributes allow code reuse.</span></span> <span data-ttu-id="f6d02-246">메타데이터 시스템은 유연하며 제한을 적용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-246">The metadata system is flexible and doesn't impose any limitations.</span></span>

<a name="tm"></a>

### <a name="comparing-a-terminal-middleware-and-routing"></a><span data-ttu-id="f6d02-247">터미널 미들웨어와 라우팅 비교</span><span class="sxs-lookup"><span data-stu-id="f6d02-247">Comparing a terminal middleware and routing</span></span>

<span data-ttu-id="f6d02-248">다음 코드 샘플에서는 미들웨어 사용과 라우팅 사용을 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-248">The following code sample contrasts using middleware with using routing:</span></span>

[!code-csharp[](routing/samples/3.x/RoutingSample/TerminalMiddlewareStartup.cs?name=snippet)]

<span data-ttu-id="f6d02-249">`Approach 1:`로 표시된 미들웨어 스타일은 **터미널 미들웨어**입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-249">The style of middleware shown with `Approach 1:` is **terminal middleware**.</span></span> <span data-ttu-id="f6d02-250">일치 작업을 수행하기 때문에 터미널 미들웨어라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-250">It's called terminal middleware because it does a matching operation:</span></span>

* <span data-ttu-id="f6d02-251">위 샘플의 일치 작업은 미들웨어의 `Path == "/"`와 라우팅의 `Path == "/Movie"`입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-251">The matching operation in the preceding sample is `Path == "/"` for the middleware and `Path == "/Movie"` for routing.</span></span>
* <span data-ttu-id="f6d02-252">일치가 성공하면 일부 기능을 실행하고 `next` 미들웨어를 호출하는 대신 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-252">When a match is successful, it executes some functionality and returns, rather than invoking the `next` middleware.</span></span>

<span data-ttu-id="f6d02-253">검색을 종료하고 일부 기능을 실행한 다음 반환하기 때문에 터미널 미들웨어라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-253">It's called terminal middleware because it terminates the search, executes some functionality, and then returns.</span></span>

<span data-ttu-id="f6d02-254">터미널 미들웨어와 라우팅을 비교하면 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-254">Comparing a terminal middleware and routing:</span></span>
* <span data-ttu-id="f6d02-255">두 방법 모두 처리 파이프라인을 종료할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-255">Both approaches allow terminating the processing pipeline:</span></span>
    * <span data-ttu-id="f6d02-256">미들웨어는 `next`를 호출하는 대신 반환하여 파이프라인을 종료합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-256">Middleware terminates the pipeline by returning rather than invoking `next`.</span></span>
    * <span data-ttu-id="f6d02-257">엔드포인트는 항상 터미널입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-257">Endpoints are always terminal.</span></span>
* <span data-ttu-id="f6d02-258">터미널 미들웨어를 사용하면 파이프라인에서 미들웨어를 임의로 위치 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-258">Terminal middleware allows positioning the middleware at an arbitrary place in the pipeline:</span></span>
    * <span data-ttu-id="f6d02-259">엔드포인트는 <xref:Microsoft.AspNetCore.Builder.EndpointRoutingApplicationBuilderExtensions.UseEndpoints*>의 위치에서 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-259">Endpoints execute at the position of <xref:Microsoft.AspNetCore.Builder.EndpointRoutingApplicationBuilderExtensions.UseEndpoints*>.</span></span>
* <span data-ttu-id="f6d02-260">터미널 미들웨어는 임의의 코드를 사용하여 미들웨어가 일치되는 시기를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-260">Terminal middleware allows arbitrary code to determine when the middleware matches:</span></span>
    * <span data-ttu-id="f6d02-261">사용자 지정 경로 일치 코드는 길어져서 올바르게 작성하기 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-261">Custom route matching code can be verbose and difficult to write correctly.</span></span>
    * <span data-ttu-id="f6d02-262">라우팅은 일반적인 앱을 위한 간단한 솔루션을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-262">Routing provides straightforward solutions for typical apps.</span></span> <span data-ttu-id="f6d02-263">앱 대부분에는 사용자 지정 경로 일치 코드가 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-263">Most apps don't require custom route matching code.</span></span>
* <span data-ttu-id="f6d02-264">엔드포인트는 `UseAuthorization` 및 `UseCors` 같은 미들웨어와 상호 작용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-264">Endpoints interface with middleware such as `UseAuthorization` and `UseCors`.</span></span>
    * <span data-ttu-id="f6d02-265">`UseAuthorization` 또는 `UseCors`와 함께 터미널 미들웨어를 사용하려면 권한 부여 시스템을 수동으로 조작해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-265">Using a terminal middleware with `UseAuthorization` or `UseCors` requires manual interfacing with the authorization system.</span></span>

<span data-ttu-id="f6d02-266">[엔드포인트](#endpoint)는 다음 두 가지를 모두 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-266">An [endpoint](#endpoint) defines both:</span></span>

* <span data-ttu-id="f6d02-267">요청을 처리할 대리자</span><span class="sxs-lookup"><span data-stu-id="f6d02-267">A delegate to process requests.</span></span>
* <span data-ttu-id="f6d02-268">임의 메타데이터의 컬렉션.</span><span class="sxs-lookup"><span data-stu-id="f6d02-268">A collection of arbitrary metadata.</span></span> <span data-ttu-id="f6d02-269">메타데이터는 각 엔드포인트에 연결된 정책과 구성에 따라 횡단 관심사(Cross-Cutting Concerns)를 구현하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-269">The metadata is used to implement cross-cutting concerns based on policies and configuration attached to each endpoint.</span></span>

<span data-ttu-id="f6d02-270">터미널 미들웨어는 효과적인 도구이지만 다음이 필요할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-270">Terminal middleware can be an effective tool, but can require:</span></span>

* <span data-ttu-id="f6d02-271">상당한 양의 코딩과 테스트</span><span class="sxs-lookup"><span data-stu-id="f6d02-271">A significant amount of coding and testing.</span></span>
* <span data-ttu-id="f6d02-272">원하는 수준의 유연성을 얻기 위한 다른 시스템과의 수동 통합</span><span class="sxs-lookup"><span data-stu-id="f6d02-272">Manual integration with other systems to achieve the desired level of flexibility.</span></span>

<span data-ttu-id="f6d02-273">터미널 미들웨어를 작성하기 전에 라우팅과 통합하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-273">Consider integrating with routing before writing a terminal middleware.</span></span>

<span data-ttu-id="f6d02-274">[또는](xref:fundamentals/middleware/index#branch-the-middleware-pipeline) <xref:Microsoft.AspNetCore.Builder.MapWhenExtensions.MapWhen*>과 통합되는 기존 터미널 미들웨어는 일반적으로 라우팅 인식 엔드포인트로 전환될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-274">Existing terminal middleware that integrates with [Map](xref:fundamentals/middleware/index#branch-the-middleware-pipeline) or <xref:Microsoft.AspNetCore.Builder.MapWhenExtensions.MapWhen*> can usually be turned into a routing aware endpoint.</span></span> <span data-ttu-id="f6d02-275">[MapHealthChecks](https://github.com/aspnet/AspNetCore/blob/master/src/Middleware/HealthChecks/src/Builder/HealthCheckEndpointRouteBuilderExtensions.cs#L16)는 다음과 같은 라우터 방식의 패턴을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-275">[MapHealthChecks](https://github.com/aspnet/AspNetCore/blob/master/src/Middleware/HealthChecks/src/Builder/HealthCheckEndpointRouteBuilderExtensions.cs#L16) demonstrates the pattern for router-ware:</span></span>
* <span data-ttu-id="f6d02-276"><xref:Microsoft.AspNetCore.Routing.IEndpointRouteBuilder>에 대한 확장 메서드를 작성합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-276">Write an extension method on <xref:Microsoft.AspNetCore.Routing.IEndpointRouteBuilder>.</span></span>
* <span data-ttu-id="f6d02-277"><xref:Microsoft.AspNetCore.Routing.IEndpointRouteBuilder.CreateApplicationBuilder*>를 사용하여 중첩된 미들웨어 파이프라인을 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-277">Create a nested middleware pipeline using <xref:Microsoft.AspNetCore.Routing.IEndpointRouteBuilder.CreateApplicationBuilder*>.</span></span>
* <span data-ttu-id="f6d02-278">새 파이프라인에 미들웨어를 연결합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-278">Attach the middleware to the new pipeline.</span></span> <span data-ttu-id="f6d02-279">이 예제의 경우 <xref:Microsoft.AspNetCore.Builder.HealthCheckApplicationBuilderExtensions.UseHealthChecks*>입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-279">In this case, <xref:Microsoft.AspNetCore.Builder.HealthCheckApplicationBuilderExtensions.UseHealthChecks*>.</span></span>
* <span data-ttu-id="f6d02-280">미들웨어 파이프라인을 <xref:Microsoft.AspNetCore.Http.RequestDelegate>로 <xref:Microsoft.AspNetCore.Builder.IApplicationBuilder.Build*>합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-280"><xref:Microsoft.AspNetCore.Builder.IApplicationBuilder.Build*> the middleware pipeline into a <xref:Microsoft.AspNetCore.Http.RequestDelegate>.</span></span>
* <span data-ttu-id="f6d02-281">`Map`을 호출하고 새 미들웨어 파이프라인을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-281">Call `Map` and provide the new middleware pipeline.</span></span>
* <span data-ttu-id="f6d02-282">확장 메서드의 `Map`에서 제공하는 작성기 개체를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-282">Return the builder object provided by `Map` from the extension method.</span></span>

<span data-ttu-id="f6d02-283">다음 코드에서는 [MapHealthChecks](xref:host-and-deploy/health-checks)를 사용하는 방법을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-283">The following code shows use of [MapHealthChecks](xref:host-and-deploy/health-checks):</span></span>

[!code-csharp[](routing/samples/3.x/RoutingSample/AuthorizationStartup.cs?name=snippet)]

<span data-ttu-id="f6d02-284">앞의 샘플에서는 작성기 개체를 반환하는 것이 중요한 이유를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-284">The preceding sample shows why returning the builder object is important.</span></span> <span data-ttu-id="f6d02-285">작성기 개체를 반환하면 앱 개발자가 엔드포인트의 권한 부여와 같은 정책을 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-285">Returning the builder object allows the app developer to configure policies such as authorization for the endpoint.</span></span> <span data-ttu-id="f6d02-286">이 예제에서는 상태 검사 미들웨어가 권한 부여 시스템과 직접 통합되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-286">In this example, the health checks middleware has no direct integration with the authorization system.</span></span>

<span data-ttu-id="f6d02-287">메타데이터 시스템은 터미널 미들웨어를 사용하는 확장성 작성자에서 발생한 문제에 대응하여 만들어졌습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-287">The metadata system was created in response to the problems encountered by extensibility authors using terminal middleware.</span></span> <span data-ttu-id="f6d02-288">미들웨어마다 권한 부여 시스템과의 고유한 통합을 구현하는 것은 문제가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-288">It's problematic for each middleware to implement its own integration with the authorization system.</span></span>

<a name="urlm"></a>

### <a name="url-matching"></a><span data-ttu-id="f6d02-289">URL 일치</span><span class="sxs-lookup"><span data-stu-id="f6d02-289">URL matching</span></span>

* <span data-ttu-id="f6d02-290">라우팅이 들어오는 요청을 [엔드포인트](#endpoint)와 일치시키는 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-290">Is the process by which routing matches an incoming request to an [endpoint](#endpoint).</span></span>
* <span data-ttu-id="f6d02-291">URL 경로 및 헤더의 데이터를 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-291">Is based on data in the URL path and headers.</span></span>
* <span data-ttu-id="f6d02-292">요청의 모든 데이터를 고려하도록 확장될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-292">Can be extended to consider any data in the request.</span></span>

<span data-ttu-id="f6d02-293">라우팅 미들웨어가 실행되면 `Endpoint`를 설정하여 현재 요청에서 <xref:Microsoft.AspNetCore.Http.HttpContext>의 [요청 기능](xref:fundamentals/request-features)으로 값을 라우팅합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-293">When a routing middleware executes, it sets an `Endpoint` and route values to a [request feature](xref:fundamentals/request-features) on the <xref:Microsoft.AspNetCore.Http.HttpContext> from the current request:</span></span>

* <span data-ttu-id="f6d02-294">[HttpContext.GetEndpoint](<xref:Microsoft.AspNetCore.Http.EndpointHttpContextExtensions.GetEndpoint*>)를 호출하면 엔드포인트를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-294">Calling [HttpContext.GetEndpoint](<xref:Microsoft.AspNetCore.Http.EndpointHttpContextExtensions.GetEndpoint*>) gets the endpoint.</span></span>
* <span data-ttu-id="f6d02-295">`HttpRequest.RouteValues`는 경로 값의 컬렉션을 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-295">`HttpRequest.RouteValues` gets the collection of route values.</span></span>

<span data-ttu-id="f6d02-296">라우팅 미들웨어 뒤에 실행되는 [미들웨어](xref:fundamentals/middleware/index)는 엔드포인트를 검사하고 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-296">[Middleware](xref:fundamentals/middleware/index) running after the routing middleware can inspect the endpoint and take action.</span></span> <span data-ttu-id="f6d02-297">예를 들어 권한 부여 미들웨어는 엔드포인트의 메타데이터 컬렉션에서 권한 부여 정책을 조사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-297">For example, an authorization middleware can interrogate the endpoint's metadata collection for an authorization policy.</span></span> <span data-ttu-id="f6d02-298">요청 처리 파이프라인의 미들웨어가 모두 실행된 후에 선택한 엔드포인트의 대리자가 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-298">After all of the middleware in the request processing pipeline is executed, the selected endpoint's delegate is invoked.</span></span>

<span data-ttu-id="f6d02-299">엔드포인트 라우팅의 라우팅 시스템은 모든 디스패치를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-299">The routing system in endpoint routing is responsible for all dispatching decisions.</span></span> <span data-ttu-id="f6d02-300">미들웨어는 선택된 엔드포인트에 기반으로 하여 정책을 적용하므로 다음이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-300">Because the middleware applies policies based on the selected endpoint, it's important that:</span></span>

* <span data-ttu-id="f6d02-301">디스패치나 보안 정책의 애플리케이션에 영향을 줄 수 있는 모든 결정은 라우팅 시스템 내에서 내려야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-301">Any decision that can affect dispatching or the application of security policies is made inside the routing system.</span></span>

> [!WARNING]
> <span data-ttu-id="f6d02-302">이전 버전과의 호환성을 위해 컨트롤러 또는 Razor Pages 엔드포인트 대리자가 실행되면 [RouteContext RouteData](xref:Microsoft.AspNetCore.Routing.RouteContext.RouteData)의 속성이 지금까지 수행된 요청 처리에 따라 적절한 값으로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-302">For backwards-compatibility, when a Controller or Razor Pages endpoint delegate is executed, the properties of [RouteContext.RouteData](xref:Microsoft.AspNetCore.Routing.RouteContext.RouteData) are set to appropriate values based on the request processing performed thus far.</span></span>
>
> <span data-ttu-id="f6d02-303">`RouteContext` 형식은 이후 릴리스에서 obsolete로 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-303">The `RouteContext` type will be marked obsolete in a future release:</span></span>
>
> * <span data-ttu-id="f6d02-304">`RouteData.Values`를 `HttpRequest.RouteValues`로 마이그레이션합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-304">Migrate `RouteData.Values` to `HttpRequest.RouteValues`.</span></span>
> * <span data-ttu-id="f6d02-305">`RouteData.DataTokens`를 마이그레이션하여 엔드포인트 메타데이터에서 [IDataTokensMetadata](xref:Microsoft.AspNetCore.Routing.IDataTokensMetadata)를 검색합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-305">Migrate `RouteData.DataTokens` to retrieve [IDataTokensMetadata](xref:Microsoft.AspNetCore.Routing.IDataTokensMetadata) from the endpoint metadata.</span></span>

<span data-ttu-id="f6d02-306">URL 일치는 구성 가능한 일련의 단계로 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-306">URL matching operates in a configurable set of phases.</span></span> <span data-ttu-id="f6d02-307">각 단계의 출력은 일치 항목 집합입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-307">In each phase, the output is a set of matches.</span></span> <span data-ttu-id="f6d02-308">일치 항목 집합은 다음 단계에서 더욱 좁혀질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-308">The set of matches can be narrowed down further by the next phase.</span></span> <span data-ttu-id="f6d02-309">라우팅 구현에서는 일치하는 엔드포인트의 처리 순서를 보장하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-309">The routing implementation does not guarantee a processing order for matching endpoints.</span></span> <span data-ttu-id="f6d02-310">기능한 **모든** 일치 항목이 한 번에 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-310">**All** possible matches are processed at once.</span></span> <span data-ttu-id="f6d02-311">URL 일치 단계는 다음 순서로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-311">The URL matching phases occur in the following order.</span></span> <span data-ttu-id="f6d02-312">ASP.NET Core:</span><span class="sxs-lookup"><span data-stu-id="f6d02-312">ASP.NET Core:</span></span>

1. <span data-ttu-id="f6d02-313">엔드포인트와 해당 경로 템플릿 집합에 대한 URL 경로를 처리하여 일치 항목을 **모두** 수집합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-313">Processes the URL path against the set of endpoints and their route templates, collecting **all** of the matches.</span></span>
1. <span data-ttu-id="f6d02-314">앞의 목록을 사용하여 경로 제약 조건이 적용되지 않는 일치 항목을 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-314">Takes the preceding list and removes matches that fail with route constraints applied.</span></span>
1. <span data-ttu-id="f6d02-315">앞의 목록을 사용하여 [MatcherPolicy](xref:Microsoft.AspNetCore.Routing.MatcherPolicy) 인스턴스 집합에서 실패하는 항목을 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-315">Takes the preceding list and removes matches that fail the set of [MatcherPolicy](xref:Microsoft.AspNetCore.Routing.MatcherPolicy) instances.</span></span>
1. <span data-ttu-id="f6d02-316">[EndpointSelector](xref:Microsoft.AspNetCore.Routing.Matching.EndpointSelector)를 사용하여 앞의 목록을 통해 최종 결정을 내립니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-316">Uses the [EndpointSelector](xref:Microsoft.AspNetCore.Routing.Matching.EndpointSelector) to make a final decision from the preceding list.</span></span>

<span data-ttu-id="f6d02-317">엔드포인트 목록의 우선 순위는 다음에 따라 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-317">The list of endpoints is prioritized according to:</span></span>

* <span data-ttu-id="f6d02-318">[RouteEndpoint.Order](xref:Microsoft.AspNetCore.Routing.RouteEndpoint.Order*)</span><span class="sxs-lookup"><span data-stu-id="f6d02-318">The [RouteEndpoint.Order](xref:Microsoft.AspNetCore.Routing.RouteEndpoint.Order*)</span></span>
* <span data-ttu-id="f6d02-319">[경로 템플릿 우선 순위](#rtp)</span><span class="sxs-lookup"><span data-stu-id="f6d02-319">The [route template precedence](#rtp)</span></span>

<span data-ttu-id="f6d02-320"><xref:Microsoft.AspNetCore.Routing.Matching.EndpointSelector>에 도달할 때까지 각 단계에서 일치하는 모든 엔드포인트가 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-320">All matching endpoints are processed in each phase until the <xref:Microsoft.AspNetCore.Routing.Matching.EndpointSelector> is reached.</span></span> <span data-ttu-id="f6d02-321">`EndpointSelector`는 최종 단계이며,</span><span class="sxs-lookup"><span data-stu-id="f6d02-321">The `EndpointSelector` is the final phase.</span></span> <span data-ttu-id="f6d02-322">일치 항목에서 가장 높은 우선 순위 엔드포인트를 가장 일치하는 항목으로 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-322">It chooses the highest priority endpoint from the matches as the best match.</span></span> <span data-ttu-id="f6d02-323">가장 일치하는 항목과 같은 우선 순위의 다른 일치 항목이 있으면 모호한 일치 예외가 throw됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-323">If there are other matches with the same priority as the best match, an ambiguous match exception is thrown.</span></span>

<span data-ttu-id="f6d02-324">경로 우선 순위는 **더 구체적인** 경로 템플릿에 높은 우선 순위가 지정되는 기준에 따라 컴퓨팅됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-324">The route precedence is computed based on a **more specific** route template being given a higher priority.</span></span> <span data-ttu-id="f6d02-325">예를 들어 `/hello` 및 `/{message}` 템플릿을 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-325">For example, consider the templates `/hello` and `/{message}`:</span></span>

* <span data-ttu-id="f6d02-326">둘 다 URL 경로 `/hello`와 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-326">Both match the URL path `/hello`.</span></span>
* <span data-ttu-id="f6d02-327">`/hello`가 더 구체적이므로 우선 순위가 높습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-327">`/hello`  is more specific and therefore higher priority.</span></span>

<span data-ttu-id="f6d02-328">일반적으로 경로 우선 순위는 실제로 사용되는 URL 체계에 가장 일치하는 항목을 선택하는 데 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-328">In general, route precedence does a good job of choosing the best match for the kinds of URL schemes used in practice.</span></span> <span data-ttu-id="f6d02-329">모호성을 방지하는 데 필요한 경우에만 <xref:Microsoft.AspNetCore.Routing.RouteEndpoint.Order>를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-329">Use <xref:Microsoft.AspNetCore.Routing.RouteEndpoint.Order> only when necessary to avoid an ambiguity.</span></span>

<span data-ttu-id="f6d02-330">라우팅에서 제공하는 확장성의 종류 때문에 라우팅 시스템이 모호한 경로를 미리 컴퓨팅할 수는 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-330">Due to the kinds of extensibility provided by routing, it isn't possible for the routing system to compute ahead of time the ambiguous routes.</span></span> <span data-ttu-id="f6d02-331">경로 템플릿 `/{message:alpha}` 및 `/{message:int}`와 같은 예제를 살펴보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-331">Consider an example such as the route templates `/{message:alpha}` and `/{message:int}`:</span></span>

* <span data-ttu-id="f6d02-332">`alpha` 제약 조건은 영문자와만 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-332">The `alpha` constraint matches only alphabetic characters.</span></span>
* <span data-ttu-id="f6d02-333">`int` 제약 조건은 숫자와만 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-333">The `int` constraint matches only numbers.</span></span>
* <span data-ttu-id="f6d02-334">이러한 템플릿은 경로 우선 순위가 동일하지만 둘 다와 일치하는 단일 URL은 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-334">These templates have the same route precedence, but there's no single URL they both match.</span></span>
* <span data-ttu-id="f6d02-335">라우팅 시스템에서 시작 시 모호성 오류를 보고한 경우 이 유효한 사용 사례를 차단합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-335">If the routing system reported an ambiguity error at startup, it would block this valid use case.</span></span>

> [!WARNING]
>
> <span data-ttu-id="f6d02-336"><xref:Microsoft.AspNetCore.Builder.EndpointRoutingApplicationBuilderExtensions.UseEndpoints*> 내의 작업 순서는 라우팅 동작에 영향을 주지 않지만 한 가지 예외가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-336">The order of operations inside <xref:Microsoft.AspNetCore.Builder.EndpointRoutingApplicationBuilderExtensions.UseEndpoints*> doesn't influence the behavior of routing, with one exception.</span></span> <span data-ttu-id="f6d02-337"><xref:Microsoft.AspNetCore.Builder.ControllerEndpointRouteBuilderExtensions.MapControllerRoute*> 및 <xref:Microsoft.AspNetCore.Builder.MvcAreaRouteBuilderExtensions.MapAreaRoute*>는 호출된 순서를 기준으로 해당 엔드포인트에 순서 값을 자동으로 할당합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-337"><xref:Microsoft.AspNetCore.Builder.ControllerEndpointRouteBuilderExtensions.MapControllerRoute*> and <xref:Microsoft.AspNetCore.Builder.MvcAreaRouteBuilderExtensions.MapAreaRoute*> automatically assign an order value to their endpoints based on the order they are invoked.</span></span> <span data-ttu-id="f6d02-338">이는 이전 라우팅 구현과 동일한 보장을 제공하는 라우팅 시스템이 없이 컨트롤러의 오래된 동작을 시뮬레이트합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-338">This simulates long-time behavior of controllers without the routing system providing the same guarantees as older routing implementations.</span></span>
>
> <span data-ttu-id="f6d02-339">라우팅의 레거시 구현에서는 경로가 처리되는 순서에 종속된 라우팅 확장성을 구현할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-339">In the legacy implementation of routing, it's possible to implement routing extensibility that has a dependency on the order in which routes are processed.</span></span> <span data-ttu-id="f6d02-340">ASP.NET Core 3.0 이상의 엔드포인트 라우팅은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-340">Endpoint routing in ASP.NET Core 3.0 and later:</span></span>
> 
> * <span data-ttu-id="f6d02-341">경로 개념이 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-341">Doesn't have a concept of routes.</span></span>
> * <span data-ttu-id="f6d02-342">순서 지정을 보장하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-342">Doesn't provide ordering guarantees.</span></span> <span data-ttu-id="f6d02-343">모든 엔드포인트가 한 번에 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-343">All endpoints are processed at once.</span></span>
>
> <span data-ttu-id="f6d02-344">이 때문에 레거시 라우팅 시스템을 계속 사용하는 경우 [open a GitHub issue for assistance](https://github.com/dotnet/aspnetcore/issues)(지원을 위한 GitHub 문제를 시작)하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-344">If this means you're stuck using the legacy routing system, [open a GitHub issue for assistance](https://github.com/dotnet/aspnetcore/issues).</span></span>

<a name="rtp"></a>

### <a name="route-template-precedence-and-endpoint-selection-order"></a><span data-ttu-id="f6d02-345">경로 템플릿 우선 순위 및 엔드포인트 선택 영역 순서</span><span class="sxs-lookup"><span data-stu-id="f6d02-345">Route template precedence and endpoint selection order</span></span>

<span data-ttu-id="f6d02-346">[경로 템플릿 우선 순위](https://github.com/dotnet/aspnetcore/blob/master/src/Http/Routing/src/Template/RoutePrecedence.cs#L16)는 얼마나 구체적인지를 기준으로 각 경로 템플릿에 값을 할당하는 시스템입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-346">[Route template precedence](https://github.com/dotnet/aspnetcore/blob/master/src/Http/Routing/src/Template/RoutePrecedence.cs#L16) is a system that assigns each route template a value based on how specific it is.</span></span> <span data-ttu-id="f6d02-347">경로 템플릿 우선 순위의 특징은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-347">Route template precedence:</span></span>

* <span data-ttu-id="f6d02-348">일반적인 사례에서 엔드포인트 순서를 조정할 필요가 없게 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-348">Avoids the need to adjust the order of endpoints in common cases.</span></span>
* <span data-ttu-id="f6d02-349">라우팅 동작에 관한 일반적인 기대에 맞추려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-349">Attempts to match the common-sense expectations of routing behavior.</span></span>

<span data-ttu-id="f6d02-350">예를 들어 `/Products/List` 및 `/Products/{id}` 템플릿을 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-350">For example, consider templates `/Products/List` and `/Products/{id}`.</span></span> <span data-ttu-id="f6d02-351">URL 경로 `/Products/List`에 대해 `/Products/List`가 `/Products/{id}`보다 더 잘 일치한다고 합리적으로 가정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-351">It would be reasonable to assume that `/Products/List` is a better match than `/Products/{id}` for the URL path `/Products/List`.</span></span> <span data-ttu-id="f6d02-352">이유는 리터럴 세그먼트 `/List`가 매개 변수 세그먼트 `/{id}`보다 더 우선 순위가 높다고 간주되기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-352">The works because the literal segment `/List` is considered to have better precedence than the parameter segment `/{id}`.</span></span>

<span data-ttu-id="f6d02-353">우선 순위의 작동 방식에 대한 세부 정보는 경로 템플릿이 정의된 방법과 어느 정도 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-353">The details of how precedence works are coupled to how route templates are defined:</span></span>

* <span data-ttu-id="f6d02-354">세그먼트가 더 많은 템플릿은 더 구체적인 것으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-354">Templates with more segments are considered more specific.</span></span>
* <span data-ttu-id="f6d02-355">리터럴 텍스트가 있는 세그먼트가 매개 변수 세그먼트보다 더 구체적인 것으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-355">A segment with literal text is considered more specific than a parameter segment.</span></span>
* <span data-ttu-id="f6d02-356">제약 조건이 있는 매개 변수 세그먼트가 제약 조건이 없는 매개 변수 세그먼트보다 더 구체적인 것으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-356">A parameter segment with a constraint is considered more specific than one without.</span></span>
* <span data-ttu-id="f6d02-357">복잡한 세그먼트는 제약 조건이 있는 매개 변수 세그먼트만큼 구체적인 것으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-357">A complex segment is considered as specific as a parameter segment with a constraint.</span></span>
* <span data-ttu-id="f6d02-358">Catch-all 매개 변수가 가장 덜 구체적입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-358">Catch-all parameters are the least specific.</span></span> <span data-ttu-id="f6d02-359">Catch-all 경로에 관한 중요한 내용은 [경로 템플릿 참조](#rtr)에서 **catch-all**을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-359">See **catch-all** in the [Route template reference](#rtr) for important information on catch-all routes.</span></span>

<span data-ttu-id="f6d02-360">정확한 값 참조는 [source code on GitHub](https://github.com/dotnet/aspnetcore/blob/master/src/Http/Routing/src/Template/RoutePrecedence.cs#L189)(GitHub의 소스 코드)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-360">See the [source code on GitHub](https://github.com/dotnet/aspnetcore/blob/master/src/Http/Routing/src/Template/RoutePrecedence.cs#L189) for a reference of exact values.</span></span>

<a name="lg"></a>

### <a name="url-generation-concepts"></a><span data-ttu-id="f6d02-361">URL 생성 개념</span><span class="sxs-lookup"><span data-stu-id="f6d02-361">URL generation concepts</span></span>

<span data-ttu-id="f6d02-362">URL 생성은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-362">URL generation:</span></span>

* <span data-ttu-id="f6d02-363">라우팅이 경로 값의 집합을 기반으로 하는 URL 경로를 만들 수 있는 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-363">Is the process by which routing can create a URL path based on a set of route values.</span></span>
* <span data-ttu-id="f6d02-364">엔드포인트와 이에 액세스하는 URL을 논리적으로 분리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-364">Allows for a logical separation between endpoints and the URLs that access them.</span></span>

<span data-ttu-id="f6d02-365">엔드포인트 라우팅에는 <xref:Microsoft.AspNetCore.Routing.LinkGenerator> API가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-365">Endpoint routing includes the <xref:Microsoft.AspNetCore.Routing.LinkGenerator> API.</span></span> <span data-ttu-id="f6d02-366">`LinkGenerator`는 [DI](xref:fundamentals/dependency-injection)에서 사용할 수 있는 싱글톤 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-366">`LinkGenerator` is a singleton service available from [DI](xref:fundamentals/dependency-injection).</span></span> <span data-ttu-id="f6d02-367">`LinkGenerator` API는 실행 중인 요청의 컨텍스트 외부에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-367">The `LinkGenerator` API can be used outside of the context of an executing request.</span></span> <span data-ttu-id="f6d02-368">[Mvc.IUrlHelper](xref:Microsoft.AspNetCore.Mvc.IUrlHelper) 및 <xref:Microsoft.AspNetCore.Mvc.IUrlHelper>를 사용하는 시나리오(예: [태그 도우미](xref:mvc/views/tag-helpers/intro), HTML 도우미 및 [작업 결과](xref:mvc/controllers/actions))는 내부적으로 `LinkGenerator` API를 사용하여 링크 생성 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-368">[Mvc.IUrlHelper](xref:Microsoft.AspNetCore.Mvc.IUrlHelper) and scenarios that rely on <xref:Microsoft.AspNetCore.Mvc.IUrlHelper>, such as [Tag Helpers](xref:mvc/views/tag-helpers/intro), HTML Helpers, and [Action Results](xref:mvc/controllers/actions), use the `LinkGenerator` API internally to provide link generating capabilities.</span></span>

<span data-ttu-id="f6d02-369">링크 생성기는 **주소** 및 **주소 체계**의 개념으로 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-369">The link generator is backed by the concept of an **address** and **address schemes**.</span></span> <span data-ttu-id="f6d02-370">주소 체계는 링크 생성을 위해 고려해야 할 엔드포인트를 결정하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-370">An address scheme is a way of determining the endpoints that should be considered for link generation.</span></span> <span data-ttu-id="f6d02-371">예를 들어 컨트롤러 및 Razor Pages에서 많은 사용자에게 친숙한 경로 이름 및 경로 값 시나리오는 주소 체계로 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-371">For example, the route name and route values scenarios many users are familiar with from controllers and Razor Pages are implemented as an address scheme.</span></span>

<span data-ttu-id="f6d02-372">링크 생성기는 다음 확장 메서드를 통해 컨트롤러 및 Razor Pages에 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-372">The link generator can link to controllers and Razor Pages via the following extension methods:</span></span>

* <xref:Microsoft.AspNetCore.Routing.ControllerLinkGeneratorExtensions.GetPathByAction*>
* <xref:Microsoft.AspNetCore.Routing.ControllerLinkGeneratorExtensions.GetUriByAction*>
* <xref:Microsoft.AspNetCore.Routing.PageLinkGeneratorExtensions.GetPathByPage*>
* <xref:Microsoft.AspNetCore.Routing.PageLinkGeneratorExtensions.GetUriByPage*>

<span data-ttu-id="f6d02-373">이러한 메서드의 오버로드에는 `HttpContext`를 포함한 인수가 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-373">Overloads of these methods accept arguments that include the `HttpContext`.</span></span> <span data-ttu-id="f6d02-374">이러한 메서드는 기능적으로 [Url.Action](xref:System.Web.Mvc.UrlHelper.Action*) 및 [Url.Page](xref:Microsoft.AspNetCore.Mvc.UrlHelperExtensions.Page*)와 동일하지만, 추가적인 유연성과 옵션을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-374">These methods are functionally equivalent to [Url.Action](xref:System.Web.Mvc.UrlHelper.Action*) and [Url.Page](xref:Microsoft.AspNetCore.Mvc.UrlHelperExtensions.Page*), but offer additional flexibility and options.</span></span>

<span data-ttu-id="f6d02-375">`GetPath*` 메서드는 절대 경로가 포함된 URI를 생성한다는 점에서 `Url.Action` 및 `Url.Page`와 가장 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-375">The `GetPath*` methods are most similar to `Url.Action` and `Url.Page`, in that they generate a URI containing an absolute path.</span></span> <span data-ttu-id="f6d02-376">`GetUri*` 메서드는 항상 체계와 호스트를 포함한 절대 URI를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-376">The `GetUri*` methods always generate an absolute URI containing a scheme and host.</span></span> <span data-ttu-id="f6d02-377">`HttpContext`를 허용하는 메서드는 실행 중인 요청의 컨텍스트에서 URI를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-377">The methods that accept an `HttpContext` generate a URI in the context of the executing request.</span></span> <span data-ttu-id="f6d02-378">재정의되지 않는 한 실행 중인 요청의 [앰비언트](#ambient) 경로 값, URL 기본 경로, 체계 및 호스트가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-378">The [ambient](#ambient) route values, URL base path, scheme, and host from the executing request are used unless overridden.</span></span>

<span data-ttu-id="f6d02-379"><xref:Microsoft.AspNetCore.Routing.LinkGenerator>는 주소를 사용하여 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-379"><xref:Microsoft.AspNetCore.Routing.LinkGenerator> is called with an address.</span></span> <span data-ttu-id="f6d02-380">URI 생성은 다음 두 단계로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-380">Generating a URI occurs in two steps:</span></span>

1. <span data-ttu-id="f6d02-381">주소는 해당 주소와 일치하는 엔드포인트 목록에 바인딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-381">An address is bound to a list of endpoints that match the address.</span></span>
1. <span data-ttu-id="f6d02-382">제공된 값과 일치하는 경로 패턴을 찾을 때까지 각 엔드포인트의 <xref:Microsoft.AspNetCore.Routing.RouteEndpoint.RoutePattern>이 평가됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-382">Each endpoint's <xref:Microsoft.AspNetCore.Routing.RouteEndpoint.RoutePattern> is evaluated until a route pattern that matches the supplied values is found.</span></span> <span data-ttu-id="f6d02-383">결과 출력은 링크 생성기에 제공된 다른 URI 부분과 결합되어 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-383">The resulting output is combined with the other URI parts supplied to the link generator and returned.</span></span>

<span data-ttu-id="f6d02-384"><xref:Microsoft.AspNetCore.Routing.LinkGenerator>에서 제공하는 메서드는 모든 유형의 주소에 대해 표준 링크 생성 기능을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-384">The methods provided by <xref:Microsoft.AspNetCore.Routing.LinkGenerator> support standard link generation capabilities for any type of address.</span></span> <span data-ttu-id="f6d02-385">링크 생성기를 사용하는 가장 편리한 방법은 특정 주소 유형에 대한 작업을 수행하는 확장 메서드를 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-385">The most convenient way to use the link generator is through extension methods that perform operations for a specific address type:</span></span>

| <span data-ttu-id="f6d02-386">확장 메서드</span><span class="sxs-lookup"><span data-stu-id="f6d02-386">Extension Method</span></span> | <span data-ttu-id="f6d02-387">설명</span><span class="sxs-lookup"><span data-stu-id="f6d02-387">Description</span></span> |
| ---------------- | ----------- |
| <xref:Microsoft.AspNetCore.Routing.LinkGenerator.GetPathByAddress*> | <span data-ttu-id="f6d02-388">제공된 값에 기반한 절대 경로의 URI를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-388">Generates a URI with an absolute path based on the provided values.</span></span> |
| <xref:Microsoft.AspNetCore.Routing.LinkGenerator.GetUriByAddress*> | <span data-ttu-id="f6d02-389">제공된 값에 기반한 절대 URI를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-389">Generates an absolute URI based on the provided values.</span></span>             |

> [!WARNING]
> <span data-ttu-id="f6d02-390"><xref:Microsoft.AspNetCore.Routing.LinkGenerator> 메서드 호출 시 다음과 같은 의미에 주의하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-390">Pay attention to the following implications of calling <xref:Microsoft.AspNetCore.Routing.LinkGenerator> methods:</span></span>
>
> * <span data-ttu-id="f6d02-391">들어오는 요청의 `GetUri*` 헤더의 유효성을 검사하지 않는 앱 구성에서는 `Host` 확장 메서드를 신중하게 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-391">Use `GetUri*` extension methods with caution in an app configuration that doesn't validate the `Host` header of incoming requests.</span></span> <span data-ttu-id="f6d02-392">들어오는 요청의 `Host` 헤더의 유효성을 검사하지 않으면 신뢰할 수 없는 요청 입력이 보기 또는 페이지에 포함된 URI로 클라이언트에 다시 보내질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-392">If the `Host` header of incoming requests isn't validated, untrusted request input can be sent back to the client in URIs in a view or page.</span></span> <span data-ttu-id="f6d02-393">모든 프로덕션 앱은 알려진 유효한 값에 대해 `Host` 헤더의 유효성을 검사하도록 서버를 구성하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-393">We recommend that all production apps configure their server to validate the `Host` header against known valid values.</span></span>
>
> * <span data-ttu-id="f6d02-394">미들웨어에서 `MapWhen` 또는 <xref:Microsoft.AspNetCore.Routing.LinkGenerator>과 함께 `Map`를 사용할 때는 신중하게 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-394">Use <xref:Microsoft.AspNetCore.Routing.LinkGenerator> with caution in middleware in combination with `Map` or `MapWhen`.</span></span> <span data-ttu-id="f6d02-395">`Map*`는 실행 중인 요청의 기본 경로를 변경하여 링크 생성의 출력에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-395">`Map*` changes the base path of the executing request, which affects the output of link generation.</span></span> <span data-ttu-id="f6d02-396">모든 <xref:Microsoft.AspNetCore.Routing.LinkGenerator> API는 기본 경로를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-396">All of the <xref:Microsoft.AspNetCore.Routing.LinkGenerator> APIs allow specifying a base path.</span></span> <span data-ttu-id="f6d02-397">링크 생성에 대한 `Map*`의 영향을 실행 취소하려면 빈 기본 경로를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-397">Specify an empty base path to undo the `Map*` affect on link generation.</span></span>

### <a name="middleware-example"></a><span data-ttu-id="f6d02-398">미들웨어 예제</span><span class="sxs-lookup"><span data-stu-id="f6d02-398">Middleware example</span></span>

<span data-ttu-id="f6d02-399">다음 예제에서는 미들웨어에서 <xref:Microsoft.AspNetCore.Routing.LinkGenerator> API를 사용하여 상점 제품을 나열하는 작업 메서드에 대한 링크를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-399">In the following example, a middleware uses the <xref:Microsoft.AspNetCore.Routing.LinkGenerator> API to create a link to an action method that lists store products.</span></span> <span data-ttu-id="f6d02-400">링크 생성기를 클래스에 주입하고 `GenerateLink`를 호출하여 앱의 모든 클래스에서 해당 링크 생성기를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-400">Using the link generator by injecting it into a class and calling `GenerateLink` is available to any class in an app:</span></span>

[!code-csharp[](routing/samples/3.x/RoutingSample/Middleware/ProductsLinkMiddleware.cs?name=snippet)]

<a name="rtr"></a>

## <a name="route-template-reference"></a><span data-ttu-id="f6d02-401">경로 템플릿 참조</span><span class="sxs-lookup"><span data-stu-id="f6d02-401">Route template reference</span></span>

<span data-ttu-id="f6d02-402">`{}` 내의 토큰은 경로가 일치하는 경우 바인딩될 경로 매개 변수를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-402">Tokens within `{}` define route parameters that are bound if the route is matched.</span></span> <span data-ttu-id="f6d02-403">경로 세그먼트에 둘 이상의 경로 매개 변수를 정의할 수 있지만 경로 매개 변수를 리터럴 값으로 분리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-403">More than one route parameter can be defined in a route segment, but route parameters  must be separated by a literal value.</span></span> <span data-ttu-id="f6d02-404">예를 들어 `{controller=Home}{action=Index}`는 `{controller}` 및 `{action}` 사이에 리터럴 값이 없으므로 유효한 경로가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-404">For example, `{controller=Home}{action=Index}` isn't a valid route, since there's no literal value between `{controller}` and `{action}`.</span></span>  <span data-ttu-id="f6d02-405">경로 매개 변수는 이름이 있어야 하며 지정된 추가 특성을 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-405">Route parameters must have a name and may have additional attributes specified.</span></span>

<span data-ttu-id="f6d02-406">경로 매개 변수 이외의 리터럴 텍스트(예: `{id}`) 및 경로 구분 기호(`/`)는 URL의 텍스트와 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-406">Literal text other than route parameters (for example, `{id}`) and the path separator `/` must match the text in the URL.</span></span> <span data-ttu-id="f6d02-407">텍스트 일치는 대/소문자를 구분하지 않으며 URL 경로의 디코딩된 표현을 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-407">Text matching is case-insensitive and based on the decoded representation of the URL's path.</span></span> <span data-ttu-id="f6d02-408">리터럴 경로 매개 변수 구분 기호 `{` 또는 `}`와 일치시키려면 문자를</span><span class="sxs-lookup"><span data-stu-id="f6d02-408">To match a literal route parameter delimiter `{` or `}`, escape the delimiter by repeating the character.</span></span> <span data-ttu-id="f6d02-409">반복하여(예: `{{` 또는 `}}`) 구분 기호를 이스케이프합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-409">For example `{{` or `}}`.</span></span>

<span data-ttu-id="f6d02-410">별표 `*` 또는 이중 별표 `**`:</span><span class="sxs-lookup"><span data-stu-id="f6d02-410">Asterisk `*` or double asterisk `**`:</span></span>

* <span data-ttu-id="f6d02-411">URI의 나머지 부분에 바인딩하기 위해 경로 매개 변수의 접두사로 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-411">Can be used as a prefix to a route parameter to bind to the rest of the URI.</span></span>
* <span data-ttu-id="f6d02-412">**범용** 매개 변수라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-412">Are called a **catch-all** parameters.</span></span> <span data-ttu-id="f6d02-413">예: `blog/{**slug}`</span><span class="sxs-lookup"><span data-stu-id="f6d02-413">For example, `blog/{**slug}`:</span></span>
  * <span data-ttu-id="f6d02-414">`/blog`로 시작하고 그 다음에 임의의 값이 오는 모든 URI를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-414">Matches any URI that starts with `/blog` and has any value following it.</span></span>
  * <span data-ttu-id="f6d02-415">`/blog` 다음의 값은 [동적 필드](https://developer.mozilla.org/docs/Glossary/Slug) 경로 값에 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-415">The value following `/blog` is assigned to the [slug](https://developer.mozilla.org/docs/Glossary/Slug) route value.</span></span>

[!INCLUDE[](~/includes/catchall.md)]

<span data-ttu-id="f6d02-416">범용 매개 변수는 빈 문자열과 일치시킬 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-416">Catch-all parameters can also match the empty string.</span></span>

<span data-ttu-id="f6d02-417">범용 매개 변수는 경로 구분 기호 `/` 문자를 포함하여 URL을 생성하는 데 경로가 사용될 때 적절한 문자를 이스케이프합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-417">The catch-all parameter escapes the appropriate characters when the route is used to generate a URL, including path separator `/` characters.</span></span> <span data-ttu-id="f6d02-418">예를 들어 경로 값이 `{ path = "my/path" }`인 경로 `foo/{*path}`는 `foo/my%2Fpath`를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-418">For example, the route `foo/{*path}` with route values `{ path = "my/path" }` generates `foo/my%2Fpath`.</span></span> <span data-ttu-id="f6d02-419">이스케이프된 슬래시에 주의하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-419">Note the escaped forward slash.</span></span> <span data-ttu-id="f6d02-420">경로 구분 기호 문자를 왕복하려면 `**` 경로 매개 변수 접두사를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-420">To round-trip path separator characters, use the `**` route parameter prefix.</span></span> <span data-ttu-id="f6d02-421">`{ path = "my/path" }`를 사용하는 경로 `foo/{**path}`는 `foo/my/path`를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-421">The route `foo/{**path}` with `{ path = "my/path" }` generates `foo/my/path`.</span></span>

<span data-ttu-id="f6d02-422">선택적 파일 확장명이 있는 파일 이름을 캡처하려고 시도하는 URL 패턴에는 추가 고려 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-422">URL patterns that attempt to capture a file name with an optional file extension have additional considerations.</span></span> <span data-ttu-id="f6d02-423">예를 들어 템플릿 `files/{filename}.{ext?}`를 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-423">For example, consider the template `files/{filename}.{ext?}`.</span></span> <span data-ttu-id="f6d02-424">`filename` 및 `ext` 모두에 대한 값이 있으면 두 값이 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-424">When values for both `filename` and `ext` exist, both values are populated.</span></span> <span data-ttu-id="f6d02-425">URL에 `filename`에 대한 값만 있으면 후행 `.`가 선택 사항이므로 경로가 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-425">If only a value for `filename` exists in the URL, the route matches because the trailing `.` is  optional.</span></span> <span data-ttu-id="f6d02-426">다음 URL은 이 경로와 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-426">The following URLs match this route:</span></span>

* `/files/myFile.txt`
* `/files/myFile`

<span data-ttu-id="f6d02-427">경로 매개 변수에는 등호(`=`)로 구분된 매개 변수 이름 뒤에 기본값을 지정하여 지정된 **기본값**이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-427">Route parameters may have **default values** designated by specifying the default value after the parameter name separated by an equals sign (`=`).</span></span> <span data-ttu-id="f6d02-428">예를 들어 `{controller=Home}`은 `controller`에 대한 기본값으로 `Home`을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-428">For example, `{controller=Home}` defines `Home` as the default value for `controller`.</span></span> <span data-ttu-id="f6d02-429">URL에 매개 변수에 대한 값이 없는 경우 기본값이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-429">The default value is used if no value is present in the URL for the parameter.</span></span> <span data-ttu-id="f6d02-430">경로 매개 변수는 매개 변수 이름의 끝에 물음표(`?`)를 추가하면 선택적이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-430">Route parameters are made optional by appending a question mark (`?`) to the end of the parameter name.</span></span> <span data-ttu-id="f6d02-431">예: `id?`.</span><span class="sxs-lookup"><span data-stu-id="f6d02-431">For example, `id?`.</span></span> <span data-ttu-id="f6d02-432">선택적 값과 기본 경로 매개 변수의 차이는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-432">The difference between optional values and default route parameters is:</span></span>

* <span data-ttu-id="f6d02-433">기본값이 있는 경로 매개 변수는 항상 값을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-433">A route parameter with a default value always produces a value.</span></span>
* <span data-ttu-id="f6d02-434">선택적 매개 변수는 요청 URL에서 값을 제공한 경우에만 값이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-434">An optional parameter has a value only when a value is provided by the request URL.</span></span>

<span data-ttu-id="f6d02-435">경로 매개 변수에는 URL에서 바인딩된 경로 값과 일치해야 한다는 제약 조건이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-435">Route parameters may have constraints that must match the route value bound from the URL.</span></span> <span data-ttu-id="f6d02-436">경로 매개 변수 이름 뒤에 `:`과 제약 조건 이름을 추가하여 경로 매개 변수에서 인라인 제약 조건을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-436">Adding `:` and constraint name after the route parameter name specifies an inline constraint on a route parameter.</span></span> <span data-ttu-id="f6d02-437">제약 조건에 인수가 필요한 경우 제약 조건 이름 뒤에서 괄호 `(...)`로 묶입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-437">If the constraint requires arguments, they're enclosed in parentheses `(...)` after the constraint name.</span></span> <span data-ttu-id="f6d02-438">또 다른 `:` 및 제약 조건 이름을 추가하여 여러 ‘인라인 제약 조건’을 지정할 수 있습니다. </span><span class="sxs-lookup"><span data-stu-id="f6d02-438">Multiple *inline constraints* can be specified by appending another `:` and constraint name.</span></span>

<span data-ttu-id="f6d02-439">제약 조건 이름 및 인수는 <xref:Microsoft.AspNetCore.Routing.IRouteConstraint>의 인스턴스를 만드는 <xref:Microsoft.AspNetCore.Routing.IInlineConstraintResolver> 서비스로 전달되어 URL 처리에서 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-439">The constraint name and arguments are passed to the <xref:Microsoft.AspNetCore.Routing.IInlineConstraintResolver> service to create an instance of <xref:Microsoft.AspNetCore.Routing.IRouteConstraint> to use in URL processing.</span></span> <span data-ttu-id="f6d02-440">예를 들어 경로 템플릿 `blog/{article:minlength(10)}`는 인수 `10`으로 `minlength` 제약 조건을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-440">For example, the route template `blog/{article:minlength(10)}` specifies a `minlength` constraint with the argument `10`.</span></span> <span data-ttu-id="f6d02-441">경로 제약 조건 및 프레임워크에서 제공하는 제약 조건 목록에 대한 자세한 내용은 [경로 제약 조건 참조](#route-constraint-reference) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-441">For more information on route constraints and a list of the constraints provided by the framework, see the [Route constraint reference](#route-constraint-reference) section.</span></span>

<span data-ttu-id="f6d02-442">경로 매개 변수에는 매개 변수 변환기가 있을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-442">Route parameters may also have parameter transformers.</span></span> <span data-ttu-id="f6d02-443">매개 변수 변환기는 링크를 생성하고 URL에 대한 작업 및 페이지와 일치할 때 매개 변수 값을 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-443">Parameter transformers transform a parameter's value when generating links and matching actions and pages to URLs.</span></span> <span data-ttu-id="f6d02-444">제약 조건과 마찬가지로, 매개 변수 변환기는 경로 매개 변수 이름 뒤에 `:`과 변환기 이름을 추가하여 경로 매개 변수에 인라인으로 추가될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-444">Like constraints, parameter transformers can be added inline to a route parameter by adding a `:` and transformer name after the route parameter name.</span></span> <span data-ttu-id="f6d02-445">예를 들어 경로 템플릿 `blog/{article:slugify}`는 `slugify` 변환기를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-445">For example, the route template `blog/{article:slugify}` specifies a `slugify` transformer.</span></span> <span data-ttu-id="f6d02-446">매개 변수 변환기에 대한 자세한 내용은 [매개 변수 변환기 참조](#parameter-transformer-reference) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-446">For more information on parameter transformers, see the [Parameter transformer reference](#parameter-transformer-reference) section.</span></span>

<span data-ttu-id="f6d02-447">다음 표에서는 경로 템플릿 예제 및 해당 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-447">The following table demonstrates example route templates and their behavior:</span></span>

| <span data-ttu-id="f6d02-448">경로 템플릿</span><span class="sxs-lookup"><span data-stu-id="f6d02-448">Route Template</span></span>                           | <span data-ttu-id="f6d02-449">URI 일치 예제</span><span class="sxs-lookup"><span data-stu-id="f6d02-449">Example Matching URI</span></span>    | <span data-ttu-id="f6d02-450">요청 URI&hellip;</span><span class="sxs-lookup"><span data-stu-id="f6d02-450">The request URI&hellip;</span></span>                                                    |
| ---------------------------------------- | ----------------------- | -------------------------------------------------------------------------- |
| `hello`                                  | `/hello`                | <span data-ttu-id="f6d02-451">`/hello` 단일 경로만 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-451">Only matches the single path `/hello`.</span></span>                                     |
| `{Page=Home}`                            | `/`                     | <span data-ttu-id="f6d02-452">일치하고, `Page`를 `Home`으로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-452">Matches and sets `Page` to `Home`.</span></span>                                         |
| `{Page=Home}`                            | `/Contact`              | <span data-ttu-id="f6d02-453">일치하고, `Page`를 `Contact`로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-453">Matches and sets `Page` to `Contact`.</span></span>                                      |
| `{controller}/{action}/{id?}`            | `/Products/List`        | <span data-ttu-id="f6d02-454">`Products` 컨트롤러 및 `List` 작업에 매핑합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-454">Maps to the `Products` controller and `List` action.</span></span>                       |
| `{controller}/{action}/{id?}`            | `/Products/Details/123` | <span data-ttu-id="f6d02-455">`Products` 컨트롤러 및 `Details` 작업에 매핑합니다(`id`가 123으로 설정됨).</span><span class="sxs-lookup"><span data-stu-id="f6d02-455">Maps to the `Products` controller and  `Details` action with`id` set to 123.</span></span> |
| `{controller=Home}/{action=Index}/{id?}` | `/`                     | <span data-ttu-id="f6d02-456">`Home` 컨트롤러 및 `Index` 메서드에 매핑합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-456">Maps to the `Home` controller and `Index` method.</span></span> <span data-ttu-id="f6d02-457">`id`는 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-457">`id` is ignored.</span></span>        |
| `{controller=Home}/{action=Index}/{id?}` | `/Products`         | <span data-ttu-id="f6d02-458">`Products` 컨트롤러 및 `Index` 메서드에 매핑합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-458">Maps to the `Products` controller and `Index` method.</span></span> <span data-ttu-id="f6d02-459">`id`는 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-459">`id` is ignored.</span></span>        |

<span data-ttu-id="f6d02-460">템플릿을 사용하는 것은 일반적으로 라우팅에 대한 가장 간단한 방식입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-460">Using a template is generally the simplest approach to routing.</span></span> <span data-ttu-id="f6d02-461">제약 조건 및 기본값을 경로 템플릿 외부에서 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-461">Constraints and defaults can also be specified outside the route template.</span></span>

### <a name="complex-segments"></a><span data-ttu-id="f6d02-462">복잡한 세그먼트</span><span class="sxs-lookup"><span data-stu-id="f6d02-462">Complex segments</span></span>

<span data-ttu-id="f6d02-463">복잡한 세그먼트는 [non-greedy](#greedy) 방식으로 오른쪽에서 왼쪽으로 리터럴 구분 기호를 매칭하여 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-463">Complex segments are processed by matching up literal delimiters from right to left in a [non-greedy](#greedy) way.</span></span> <span data-ttu-id="f6d02-464">예를 들어 `[Route("/a{b}c{d}")]`는 복잡한 세그먼트입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-464">For example, `[Route("/a{b}c{d}")]` is a complex segment.</span></span>
<span data-ttu-id="f6d02-465">복잡한 세그먼트는 특정 방식으로 작동하므로 제대로 사용하려면 이 방식을 이해해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-465">Complex segments work in a particular way that must be understood to use them successfully.</span></span> <span data-ttu-id="f6d02-466">이 단원의 예제에서는 매개 변수 내에 구분 기호 텍스트가 표시되지 않는 경우에만 복잡한 세그먼트가 실제로 잘 작동하는 이유를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-466">The example in this section demonstrates why complex segments only really work well when the delimiter text doesn't appear inside the parameter values.</span></span> <span data-ttu-id="f6d02-467">더욱 복잡한 경우에는 [regex](/dotnet/standard/base-types/regular-expressions)를 사용한 다음 값을 수동으로 추출해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-467">Using a [regex](/dotnet/standard/base-types/regular-expressions) and then manually extracting the values is needed for more complex cases.</span></span>

[!INCLUDE[](~/includes/regex.md)]

<span data-ttu-id="f6d02-468">다음은 라우팅에서 `/a{b}c{d}` 템플릿 및 URL 경로 `/abcd`를 사용하여 수행하는 단계를 요약한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-468">This is a summary of the steps that routing performs with the template `/a{b}c{d}` and the URL path `/abcd`.</span></span> <span data-ttu-id="f6d02-469">`|`는 알고리즘의 작동 방식을 시각화하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-469">The `|` is used to help visualize how the algorithm works:</span></span>

* <span data-ttu-id="f6d02-470">오른쪽에서 왼쪽으로 첫 번째 리터럴은 `c`입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-470">The first literal, right to left, is `c`.</span></span> <span data-ttu-id="f6d02-471">따라서 `/abcd`가 오른쪽에서 검색되고 `/ab|c|d`를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-471">So `/abcd` is searched from right and finds `/ab|c|d`.</span></span>
* <span data-ttu-id="f6d02-472">이제 오른쪽의 모든 항목(`d`)이 경로 매개 변수 `{d}`와 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-472">Everything to the right (`d`) is now matched to the route parameter `{d}`.</span></span>
* <span data-ttu-id="f6d02-473">오른쪽에서 왼쪽으로 다음 리터럴은 `a`입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-473">The next literal, right to left, is `a`.</span></span> <span data-ttu-id="f6d02-474">따라서 `/ab|c|d`가 중단된 위치부터 검색되고 `a`를 `/|a|b|c|d`와 함께 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-474">So `/ab|c|d` is searched starting where we left off, then `a` is found `/|a|b|c|d`.</span></span>
* <span data-ttu-id="f6d02-475">이제 오른쪽 값(`b`)이 경로 매개 변수 `{b}`와 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-475">The value to the right (`b`) is now matched to the route parameter `{b}`.</span></span>
* <span data-ttu-id="f6d02-476">남은 텍스트가 없고 남은 경로 템플릿도 없으므로 이것이 일치 항목입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-476">There is no remaining text and no remaining route template, so this is a match.</span></span>

<span data-ttu-id="f6d02-477">다음은 동일한 템플릿 `/a{b}c{d}`와 URL 경로 `/aabcd`를 사용하는 부정적인 사례의 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-477">Here's an example of a negative case using the same template `/a{b}c{d}` and the URL path `/aabcd`.</span></span> <span data-ttu-id="f6d02-478">`|`는 알고리즘의 작동 방식을 시각화하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-478">The `|` is used to help visualize how the algorithm works.</span></span> <span data-ttu-id="f6d02-479">이 경우는 동일한 알고리즘으로 설명되는 일치 항목이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-479">This case isn't a match, which is explained by the same algorithm:</span></span>
* <span data-ttu-id="f6d02-480">오른쪽에서 왼쪽으로 첫 번째 리터럴은 `c`입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-480">The first literal, right to left, is `c`.</span></span> <span data-ttu-id="f6d02-481">따라서 `/aabcd`가 오른쪽에서 검색되고 `/aab|c|d`를 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-481">So `/aabcd` is searched from right and finds `/aab|c|d`.</span></span>
* <span data-ttu-id="f6d02-482">이제 오른쪽의 모든 항목(`d`)이 경로 매개 변수 `{d}`와 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-482">Everything to the right (`d`) is now matched to the route parameter `{d}`.</span></span>
* <span data-ttu-id="f6d02-483">오른쪽에서 왼쪽으로 다음 리터럴은 `a`입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-483">The next literal, right to left, is `a`.</span></span> <span data-ttu-id="f6d02-484">따라서 `/aab|c|d`가 중단된 위치부터 검색되고 `a`를 `/a|a|b|c|d`와 함께 찾습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-484">So `/aab|c|d` is searched starting where we left off, then `a` is found `/a|a|b|c|d`.</span></span>
* <span data-ttu-id="f6d02-485">이제 오른쪽 값(`b`)이 경로 매개 변수 `{b}`와 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-485">The value to the right (`b`) is now matched to the route parameter `{b}`.</span></span>
* <span data-ttu-id="f6d02-486">이제 남은 텍스트 `a`가 있지만 알고리즘에서 구문 분석할 경로 템플릿이 부족하므로 이것은 일치 항목이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-486">At this point there is remaining text `a`, but the algorithm has run out of route template to parse, so this is not a match.</span></span>

<span data-ttu-id="f6d02-487">일치 알고리즘이 [non-greedy](#greedy)이므로 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-487">Since the matching algorithm is [non-greedy](#greedy):</span></span>

* <span data-ttu-id="f6d02-488">각 단계에서 가능한 최소의 텍스트와 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-488">It matches the smallest amount of text possible in each step.</span></span>
* <span data-ttu-id="f6d02-489">매개 변수 값 내에 구분 기호 값이 표시되는 모든 경우에는 일치하지 않게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-489">Any case where the delimiter value appears inside the parameter values results in not matching.</span></span>

<span data-ttu-id="f6d02-490">정규식을 사용하면 일치 동작을 더 효율적으로 제어할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-490">Regular expressions provide much more control over their matching behavior.</span></span>

<a name="greedy"></a>

<span data-ttu-id="f6d02-491">[지연 일치](https://wikipedia.org/wiki/Regular_expression#Lazy_matching)라고도 하는 greedy 일치는 가능한 가장 큰 문자열과 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-491">Greedy matching, also know as [lazy matching](https://wikipedia.org/wiki/Regular_expression#Lazy_matching), matches the largest possible string.</span></span> <span data-ttu-id="f6d02-492">Non-greedy는 가능한 가장 작은 문자열과 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-492">Non-greedy matches the smallest possible string.</span></span>

## <a name="route-constraint-reference"></a><span data-ttu-id="f6d02-493">경로 제약 조건 참조</span><span class="sxs-lookup"><span data-stu-id="f6d02-493">Route constraint reference</span></span>

<span data-ttu-id="f6d02-494">경로 제약 조건은 들어오는 URL과 일치하고 URL 경로가 경로 값으로 토큰화되면 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-494">Route constraints execute when a match has occurred to the incoming URL and the URL path is tokenized into route values.</span></span> <span data-ttu-id="f6d02-495">일반적으로 경로 제약 조건은 경로 템플릿을 통해 연결된 경로 값을 검사하고 값 허용 여부에 대한 true 또는 false 결정을 내립니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-495">Route constraints generally inspect the route value associated via the route template and make a true or false decision about whether the value is acceptable.</span></span> <span data-ttu-id="f6d02-496">일부 경로 제약 조건은 경로 값 외부의 데이터를 사용하여 요청을 라우팅할 수 있는지 여부를 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-496">Some route constraints use data outside the route value to consider whether the request can be routed.</span></span> <span data-ttu-id="f6d02-497">예를 들어 <xref:Microsoft.AspNetCore.Routing.Constraints.HttpMethodRouteConstraint>는 해당 HTTP 동사에 따라 요청을 허용하거나 거부할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-497">For example, the <xref:Microsoft.AspNetCore.Routing.Constraints.HttpMethodRouteConstraint> can accept or reject a request based on its HTTP verb.</span></span> <span data-ttu-id="f6d02-498">제약 조건은 라우팅 요청 및 링크 생성에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-498">Constraints are used in routing requests and link generation.</span></span>

> [!WARNING]
> <span data-ttu-id="f6d02-499">제약 조건을 입력 유효성 검사에 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-499">Don't use constraints for input validation.</span></span> <span data-ttu-id="f6d02-500">입력 유효성 검사에 제약 조건을 사용하면 잘못된 입력으로 인해 `404` 찾을 수 없음 응답이 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-500">If constraints are used for input validation, invalid input results in a `404` Not Found response.</span></span> <span data-ttu-id="f6d02-501">입력이 잘못되면 `400` 잘못된 요청과 해당하는 오류 메시지가 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-501">Invalid input should produce a `400` Bad Request with an appropriate error message.</span></span> <span data-ttu-id="f6d02-502">경로 제약 조건은 특정 경로에 대한 입력의 유효성을 검사하는 것이 아니라 비슷한 경로를 명확하게 구분하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-502">Route constraints are used to disambiguate similar routes, not to validate the inputs for a particular route.</span></span>

<span data-ttu-id="f6d02-503">다음 표에서는 경로 제약 조건 예제 및 예상되는 해당 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-503">The following table demonstrates example route constraints and their expected behavior:</span></span>

| <span data-ttu-id="f6d02-504">제약 조건</span><span class="sxs-lookup"><span data-stu-id="f6d02-504">constraint</span></span> | <span data-ttu-id="f6d02-505">예제</span><span class="sxs-lookup"><span data-stu-id="f6d02-505">Example</span></span> | <span data-ttu-id="f6d02-506">일치하는 예제</span><span class="sxs-lookup"><span data-stu-id="f6d02-506">Example Matches</span></span> | <span data-ttu-id="f6d02-507">참고</span><span class="sxs-lookup"><span data-stu-id="f6d02-507">Notes</span></span> |
| ---------- | ------- | --------------- | ----- |
| `int` | `{id:int}` | <span data-ttu-id="f6d02-508">`123456789`, `-123456789`</span><span class="sxs-lookup"><span data-stu-id="f6d02-508">`123456789`, `-123456789`</span></span> | <span data-ttu-id="f6d02-509">임의의 정수와 일치</span><span class="sxs-lookup"><span data-stu-id="f6d02-509">Matches any integer</span></span> |
| `bool` | `{active:bool}` | <span data-ttu-id="f6d02-510">`true`, `FALSE`</span><span class="sxs-lookup"><span data-stu-id="f6d02-510">`true`, `FALSE`</span></span> | <span data-ttu-id="f6d02-511">`true` 또는 `false`와 일치.</span><span class="sxs-lookup"><span data-stu-id="f6d02-511">Matches `true` or `false`.</span></span> <span data-ttu-id="f6d02-512">대/소문자 구분하지 않음</span><span class="sxs-lookup"><span data-stu-id="f6d02-512">Case-insensitive</span></span> |
| `datetime` | `{dob:datetime}` | <span data-ttu-id="f6d02-513">`2016-12-31`, `2016-12-31 7:32pm`</span><span class="sxs-lookup"><span data-stu-id="f6d02-513">`2016-12-31`, `2016-12-31 7:32pm`</span></span> | <span data-ttu-id="f6d02-514">유효한 `DateTime` 값 일치(고정 문화권에서)</span><span class="sxs-lookup"><span data-stu-id="f6d02-514">Matches a valid `DateTime` value in the invariant culture.</span></span> <span data-ttu-id="f6d02-515">위의 경고를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-515">See preceding warning.</span></span> |
| `decimal` | `{price:decimal}` | <span data-ttu-id="f6d02-516">`49.99`, `-1,000.01`</span><span class="sxs-lookup"><span data-stu-id="f6d02-516">`49.99`, `-1,000.01`</span></span> | <span data-ttu-id="f6d02-517">유효한 `decimal` 값 일치(고정 문화권에서)</span><span class="sxs-lookup"><span data-stu-id="f6d02-517">Matches a valid `decimal` value in the invariant culture.</span></span> <span data-ttu-id="f6d02-518">위의 경고를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-518">See preceding warning.</span></span>|
| `double` | `{weight:double}` | <span data-ttu-id="f6d02-519">`1.234`, `-1,001.01e8`</span><span class="sxs-lookup"><span data-stu-id="f6d02-519">`1.234`, `-1,001.01e8`</span></span> | <span data-ttu-id="f6d02-520">유효한 `double` 값 일치(고정 문화권에서)</span><span class="sxs-lookup"><span data-stu-id="f6d02-520">Matches a valid `double` value in the invariant culture.</span></span> <span data-ttu-id="f6d02-521">위의 경고를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-521">See preceding warning.</span></span>|
| `float` | `{weight:float}` | <span data-ttu-id="f6d02-522">`1.234`, `-1,001.01e8`</span><span class="sxs-lookup"><span data-stu-id="f6d02-522">`1.234`, `-1,001.01e8`</span></span> | <span data-ttu-id="f6d02-523">유효한 `float` 값 일치(고정 문화권에서)</span><span class="sxs-lookup"><span data-stu-id="f6d02-523">Matches a valid `float` value in the invariant culture.</span></span> <span data-ttu-id="f6d02-524">위의 경고를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-524">See preceding warning.</span></span>|
| `guid` | `{id:guid}` | `CD2C1638-1638-72D5-1638-DEADBEEF1638` | <span data-ttu-id="f6d02-525">유효한 `Guid` 값 일치</span><span class="sxs-lookup"><span data-stu-id="f6d02-525">Matches a valid `Guid` value</span></span> |
| `long` | `{ticks:long}` | <span data-ttu-id="f6d02-526">`123456789`, `-123456789`</span><span class="sxs-lookup"><span data-stu-id="f6d02-526">`123456789`, `-123456789`</span></span> | <span data-ttu-id="f6d02-527">유효한 `long` 값 일치</span><span class="sxs-lookup"><span data-stu-id="f6d02-527">Matches a valid `long` value</span></span> |
| `minlength(value)` | `{username:minlength(4)}` | `Rick` | <span data-ttu-id="f6d02-528">문자열은 4자 이상이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-528">String must be at least 4 characters</span></span> |
| `maxlength(value)` | `{filename:maxlength(8)}` | `MyFile` | <span data-ttu-id="f6d02-529">문자열은 8자 이하여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-529">String must be no more than 8 characters</span></span> |
| `length(length)` | `{filename:length(12)}` | `somefile.txt` | <span data-ttu-id="f6d02-530">문자열은 정확히 12자여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-530">String must be exactly 12 characters long</span></span> |
| `length(min,max)` | `{filename:length(8,16)}` | `somefile.txt` | <span data-ttu-id="f6d02-531">문자열의 길이는 8자 이상이며 16자 이하여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-531">String must be at least 8 and no more than 16 characters long</span></span> |
| `min(value)` | `{age:min(18)}` | `19` | <span data-ttu-id="f6d02-532">정수 값은 18 이상이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-532">Integer value must be at least 18</span></span> |
| `max(value)` | `{age:max(120)}` | `91` | <span data-ttu-id="f6d02-533">정수 값은 120 이하여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-533">Integer value must be no more than 120</span></span> |
| `range(min,max)` | `{age:range(18,120)}` | `91` | <span data-ttu-id="f6d02-534">정수 값은 18 이상이며 120 이하여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-534">Integer value must be at least 18 but no more than 120</span></span> |
| `alpha` | `{name:alpha}` | `Rick` | <span data-ttu-id="f6d02-535">문자열은 하나 이상의 영문자(`a`-`z`, 대/소문자 구분)로 구성되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-535">String must consist of one or more alphabetical characters, `a`-`z` and case-insensitive.</span></span> |
| `regex(expression)` | `{ssn:regex(^\\d{{3}}-\\d{{2}}-\\d{{4}}$)}` | `123-45-6789` | <span data-ttu-id="f6d02-536">문자열은 정규식과 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-536">String must match the regular expression.</span></span> <span data-ttu-id="f6d02-537">정규식을 정의하는 방법에 대한 팁을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-537">See tips about defining a regular expression.</span></span> |
| `required` | `{name:required}` | `Rick` | <span data-ttu-id="f6d02-538">URL을 생성하는 동안 비-매개 변수 값이 존재하도록 강제하는 데 사용됨</span><span class="sxs-lookup"><span data-stu-id="f6d02-538">Used to enforce that a non-parameter value is present during URL generation</span></span> |

[!INCLUDE[](~/includes/regex.md)]

<span data-ttu-id="f6d02-539">콜론으로 구분된 여러 개의 제약 조건을 단일 매개 변수에 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-539">Multiple, colon delimited constraints can be applied to a single parameter.</span></span> <span data-ttu-id="f6d02-540">예를 들어 다음 제약 조건은 매개 변수를 1 이상의 정수 값으로 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-540">For example, the following constraint restricts a parameter to an integer value of 1 or greater:</span></span>

```csharp
[Route("users/{id:int:min(1)}")]
public User GetUserById(int id) { }
```

> [!WARNING]
> <span data-ttu-id="f6d02-541">CLR 형식으로 변환되는 URL을 확인하는 경로 제약 조건은 항상 고정 문화권을</span><span class="sxs-lookup"><span data-stu-id="f6d02-541">Route constraints that verify the URL and are converted to a CLR type always use the invariant culture.</span></span> <span data-ttu-id="f6d02-542">사용합니다(예: CLR 형식 `int` 또는 `DateTime`으로 변환).</span><span class="sxs-lookup"><span data-stu-id="f6d02-542">For example, conversion to the CLR type `int` or `DateTime`.</span></span> <span data-ttu-id="f6d02-543">이러한 제약 조건은 URL은 지역화될 수 없다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-543">These constraints assume that the URL is not localizable.</span></span> <span data-ttu-id="f6d02-544">프레임워크에서 제공한 경로 제약 조건은 경로 값에 저장된 값을 수정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-544">The framework-provided route constraints don't modify the values stored in route values.</span></span> <span data-ttu-id="f6d02-545">URL에서 구문 분석되는 모든 경로 값은 문자열로 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-545">All route values parsed from the URL are stored as strings.</span></span> <span data-ttu-id="f6d02-546">예를 들어 `float` 제약 조건은 경로 값을 부동으로 변환하려고 하지만 변환된 값은 부동으로 변환될 수 있는지 확인하는 데만 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-546">For example, the `float` constraint attempts to convert the route value to a float, but the converted value is used only to verify it can be converted to a float.</span></span>

### <a name="regular-expressions-in-constraints"></a><span data-ttu-id="f6d02-547">제약 조건의 정규식</span><span class="sxs-lookup"><span data-stu-id="f6d02-547">Regular expressions in constraints</span></span>

[!INCLUDE[](~/includes/regex.md)]

<span data-ttu-id="f6d02-548">`regex(...)` 경로 제약 조건을 사용하여 정규식을 인라인 제약 조건으로 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-548">Regular expressions can be specified as inline constraints using the `regex(...)` route constraint.</span></span> <span data-ttu-id="f6d02-549"><xref:Microsoft.AspNetCore.Builder.ControllerEndpointRouteBuilderExtensions.MapControllerRoute*> 제품군의 메서드에서는 개체 리터럴의 제약 조건도 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-549">Methods in the <xref:Microsoft.AspNetCore.Builder.ControllerEndpointRouteBuilderExtensions.MapControllerRoute*> family also accept an object literal of constraints.</span></span> <span data-ttu-id="f6d02-550">해당 양식을 사용하는 경우 문자열 값이 정규식으로 해석됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-550">If that form is used, string values are interpreted as regular expressions.</span></span>

<span data-ttu-id="f6d02-551">다음 코드에서는 인라인 regex 제약 조건을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-551">The following code uses an inline regex constraint:</span></span>

[!code-csharp[](routing/samples/3.x/RoutingSample/StartupRegex.cs?name=snippet)]

<span data-ttu-id="f6d02-552">다음 코드에서는 개체 리터럴을 사용하여 regex 제약 조건을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-552">The following code uses an object literal to specify a regex constraint:</span></span>

[!code-csharp[](routing/samples/3.x/RoutingSample/StartupRegex2.cs?name=snippet)]

<span data-ttu-id="f6d02-553">ASP.NET Core 프레임워크는 정규식 생성자에 `RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.CultureInvariant`를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-553">The ASP.NET Core framework adds `RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.CultureInvariant` to the regular expression constructor.</span></span> <span data-ttu-id="f6d02-554">이러한 멤버에 대한 설명은 <xref:System.Text.RegularExpressions.RegexOptions>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-554">See <xref:System.Text.RegularExpressions.RegexOptions> for a description of these members.</span></span>

<span data-ttu-id="f6d02-555">정규식은 라우팅 및 C# 언어에서 사용하는 것과 유사한 구분 기호 및 토큰을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-555">Regular expressions use delimiters and tokens similar to those used by routing and the C# language.</span></span> <span data-ttu-id="f6d02-556">정규식 토큰은 이스케이프되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-556">Regular expression tokens must be escaped.</span></span> <span data-ttu-id="f6d02-557">인라인 제약 조건에서 정규식 `^\d{3}-\d{2}-\d{4}$`를 사용하려면 다음 중 하나를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-557">To use the regular expression `^\d{3}-\d{2}-\d{4}$` in an inline constraint, use one of the following:</span></span>

* <span data-ttu-id="f6d02-558">`\` 문자열 이스케이프 문자를 이스케이프하기 위해 C# 소스 파일에서 문자열에 제공된 `\` 문자를 `\\` 문자로 바꿉니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-558">Replace `\` characters provided in the string as `\\` characters in the C# source file in order to escape the `\` string escape character.</span></span>
* <span data-ttu-id="f6d02-559">[축자 문자열 리터럴](/dotnet/csharp/language-reference/keywords/string).</span><span class="sxs-lookup"><span data-stu-id="f6d02-559">[Verbatim string literals](/dotnet/csharp/language-reference/keywords/string).</span></span>

<span data-ttu-id="f6d02-560">라우팅 매개 변수 구분 기호 문자(`{`, `}`, `[`, `]`)를 이스케이프하려면 식에서 해당 문자를 이중으로 사용합니다(예: `{{`, `}}`, `[[`, `]]`).</span><span class="sxs-lookup"><span data-stu-id="f6d02-560">To escape routing parameter delimiter characters `{`, `}`, `[`, `]`, double the characters in the expression, for example, `{{`, `}}`, `[[`, `]]`.</span></span> <span data-ttu-id="f6d02-561">다음 표에서는 정규식 및 이스케이프된 버전을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-561">The following table shows a regular expression and its escaped version:</span></span>

| <span data-ttu-id="f6d02-562">정규식</span><span class="sxs-lookup"><span data-stu-id="f6d02-562">Regular expression</span></span>    | <span data-ttu-id="f6d02-563">이스케이프된 정규식</span><span class="sxs-lookup"><span data-stu-id="f6d02-563">Escaped regular expression</span></span>     |
| --------------------- | ------------------------------ |
| `^\d{3}-\d{2}-\d{4}$` | `^\\d{{3}}-\\d{{2}}-\\d{{4}}$` |
| `^[a-z]{2}$`          | `^[[a-z]]{{2}}$`               |

<span data-ttu-id="f6d02-564">라우팅에 사용되는 정규식은 `^` 문자로 시작하고 문자열의 시작 위치와 일치하는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-564">Regular expressions used in routing often start with the `^` character and match the starting position of the string.</span></span> <span data-ttu-id="f6d02-565">식은 `$` 문자로 끝나고 문자열의 끝과 일치하는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-565">The expressions often end with the `$` character and match the end of the string.</span></span> <span data-ttu-id="f6d02-566">`^` 및 `$` 문자는 정규식이 전체 경로 매개 변수 값과 일치하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-566">The `^` and `$` characters ensure that the regular expression matches the entire route parameter value.</span></span> <span data-ttu-id="f6d02-567">`^` 및 `$` 문자가 없는 정규식은 문자열 내의 모든 하위 문자열과 일치하지만, 이는 종종 원하는 것이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-567">Without the `^` and `$` characters, the regular expression matches any substring within the string, which is often undesirable.</span></span> <span data-ttu-id="f6d02-568">다음 표에서는 예제를 제공하고, 일치하거나 일치에 실패하는 이유를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-568">The following table provides examples and explains why they match or fail to match:</span></span>

| <span data-ttu-id="f6d02-569">식</span><span class="sxs-lookup"><span data-stu-id="f6d02-569">Expression</span></span>   | <span data-ttu-id="f6d02-570">String</span><span class="sxs-lookup"><span data-stu-id="f6d02-570">String</span></span>    | <span data-ttu-id="f6d02-571">일치</span><span class="sxs-lookup"><span data-stu-id="f6d02-571">Match</span></span> | <span data-ttu-id="f6d02-572">주석</span><span class="sxs-lookup"><span data-stu-id="f6d02-572">Comment</span></span>               |
| ------------ | --------- | :---: |  -------------------- |
| `[a-z]{2}`   | <span data-ttu-id="f6d02-573">hello</span><span class="sxs-lookup"><span data-stu-id="f6d02-573">hello</span></span>     | <span data-ttu-id="f6d02-574">예</span><span class="sxs-lookup"><span data-stu-id="f6d02-574">Yes</span></span>   | <span data-ttu-id="f6d02-575">부분 문자열 일치</span><span class="sxs-lookup"><span data-stu-id="f6d02-575">Substring matches</span></span>     |
| `[a-z]{2}`   | <span data-ttu-id="f6d02-576">123abc456</span><span class="sxs-lookup"><span data-stu-id="f6d02-576">123abc456</span></span> | <span data-ttu-id="f6d02-577">예</span><span class="sxs-lookup"><span data-stu-id="f6d02-577">Yes</span></span>   | <span data-ttu-id="f6d02-578">부분 문자열 일치</span><span class="sxs-lookup"><span data-stu-id="f6d02-578">Substring matches</span></span>     |
| `[a-z]{2}`   | <span data-ttu-id="f6d02-579">mz</span><span class="sxs-lookup"><span data-stu-id="f6d02-579">mz</span></span>        | <span data-ttu-id="f6d02-580">예</span><span class="sxs-lookup"><span data-stu-id="f6d02-580">Yes</span></span>   | <span data-ttu-id="f6d02-581">식 일치</span><span class="sxs-lookup"><span data-stu-id="f6d02-581">Matches expression</span></span>    |
| `[a-z]{2}`   | <span data-ttu-id="f6d02-582">MZ</span><span class="sxs-lookup"><span data-stu-id="f6d02-582">MZ</span></span>        | <span data-ttu-id="f6d02-583">예</span><span class="sxs-lookup"><span data-stu-id="f6d02-583">Yes</span></span>   | <span data-ttu-id="f6d02-584">대/소문자 구분하지 않음</span><span class="sxs-lookup"><span data-stu-id="f6d02-584">Not case sensitive</span></span>    |
| `^[a-z]{2}$` | <span data-ttu-id="f6d02-585">hello</span><span class="sxs-lookup"><span data-stu-id="f6d02-585">hello</span></span>     | <span data-ttu-id="f6d02-586">아니요</span><span class="sxs-lookup"><span data-stu-id="f6d02-586">No</span></span>    | <span data-ttu-id="f6d02-587">위의 `^` 및 `$` 참조</span><span class="sxs-lookup"><span data-stu-id="f6d02-587">See `^` and `$` above</span></span> |
| `^[a-z]{2}$` | <span data-ttu-id="f6d02-588">123abc456</span><span class="sxs-lookup"><span data-stu-id="f6d02-588">123abc456</span></span> | <span data-ttu-id="f6d02-589">아니요</span><span class="sxs-lookup"><span data-stu-id="f6d02-589">No</span></span>    | <span data-ttu-id="f6d02-590">위의 `^` 및 `$` 참조</span><span class="sxs-lookup"><span data-stu-id="f6d02-590">See `^` and `$` above</span></span> |

<span data-ttu-id="f6d02-591">정규식 구문에 대한 자세한 내용은 [.NET Framework 정규식](/dotnet/standard/base-types/regular-expression-language-quick-reference)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-591">For more information on regular expression syntax, see [.NET Framework Regular Expressions](/dotnet/standard/base-types/regular-expression-language-quick-reference).</span></span>

<span data-ttu-id="f6d02-592">가능한 값의 알려진 집합으로 매개 변수를 제한하려면 정규식을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-592">To constrain a parameter to a known set of possible values, use a regular expression.</span></span> <span data-ttu-id="f6d02-593">예를 들어 `{action:regex(^(list|get|create)$)}`는 `action` 경로 값을 `list`, `get` 또는 `create`으로만 일치시킵니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-593">For example, `{action:regex(^(list|get|create)$)}` only matches the `action` route value to `list`, `get`, or `create`.</span></span> <span data-ttu-id="f6d02-594">제약 조건 사전으로 전달되면 `^(list|get|create)$` 문자열은 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-594">If passed into the constraints dictionary, the string `^(list|get|create)$` is equivalent.</span></span> <span data-ttu-id="f6d02-595">알려진 제약 조건 중 하나와 일치하지 않는 제약 조건 사전에서 전달되는 제약 조건도 정규식으로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-595">Constraints that are passed in the constraints dictionary that don't match one of the known constraints are also treated as regular expressions.</span></span> <span data-ttu-id="f6d02-596">알려진 제약 조건 중 하나와 일치하지 않는 템플릿 내에서 전달되는 제약 조건은 정규식으로 처리되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-596">Constraints that are passed  within a template that don't match one of the known constraints are not treated as regular expressions.</span></span>

### <a name="custom-route-constraints"></a><span data-ttu-id="f6d02-597">사용자 지정 경로 제약 조건</span><span class="sxs-lookup"><span data-stu-id="f6d02-597">Custom route constraints</span></span>

<span data-ttu-id="f6d02-598"><xref:Microsoft.AspNetCore.Routing.IRouteConstraint> 인터페이스를 구현하여 사용자 지정 경로 제약 조건을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-598">Custom route constraints can be created by implementing the <xref:Microsoft.AspNetCore.Routing.IRouteConstraint> interface.</span></span> <span data-ttu-id="f6d02-599">`IRouteConstraint` 인터페이스에는 제약 조건이 충족되는 경우 `true`를 반환하고 그렇지 않은 경우 `false`를 반환하는 <xref:System.Web.Routing.IRouteConstraint.Match*>가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-599">The `IRouteConstraint` interface contains <xref:System.Web.Routing.IRouteConstraint.Match*>, which returns `true` if the constraint is satisfied and `false` otherwise.</span></span>

<span data-ttu-id="f6d02-600">사용자 지정 경로 제약 조건은 거의 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-600">Custom route constraints are rarely needed.</span></span> <span data-ttu-id="f6d02-601">사용자 지정 경로 제약 조건을 구현하기 전에 모델 바인딩과 같은 다른 방식을 고려해 보세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-601">Before implementing a custom route constraint, consider alternatives, such as model binding.</span></span>

<span data-ttu-id="f6d02-602">ASP.NET Core [Constraints](https://github.com/dotnet/aspnetcore/tree/master/src/Http/Routing/src/Constraints) 폴더는 제약 조건을 만드는 좋은 예제를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-602">The ASP.NET Core [Constraints](https://github.com/dotnet/aspnetcore/tree/master/src/Http/Routing/src/Constraints) folder provides good examples of creating a constraints.</span></span> <span data-ttu-id="f6d02-603">예를 들어 [GuidRouteConstraint](https://github.com/dotnet/aspnetcore/blob/master/src/Http/Routing/src/Constraints/GuidRouteConstraint.cs#L18)입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-603">For example, [GuidRouteConstraint](https://github.com/dotnet/aspnetcore/blob/master/src/Http/Routing/src/Constraints/GuidRouteConstraint.cs#L18).</span></span>

<span data-ttu-id="f6d02-604">사용자 지정 `IRouteConstraint`를 사용하려면 서비스 컨테이너에 있는 앱의 <xref:Microsoft.AspNetCore.Routing.RouteOptions.ConstraintMap>에 경로 제약 조건 형식을 등록해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-604">To use a custom `IRouteConstraint`, the route constraint type must be registered with the app's <xref:Microsoft.AspNetCore.Routing.RouteOptions.ConstraintMap> in the service container.</span></span> <span data-ttu-id="f6d02-605">`ConstraintMap`은 경로 제약 조건 키를 해당 제약 조건의 유효성을 검사하는 `IRouteConstraint` 구현과 매핑하는 사전입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-605">A `ConstraintMap` is a dictionary that maps route constraint keys to `IRouteConstraint` implementations that validate those constraints.</span></span> <span data-ttu-id="f6d02-606">`Startup.ConfigureServices`에서 [services.AddRouting](xref:Microsoft.Extensions.DependencyInjection.RoutingServiceCollectionExtensions.AddRouting*) 호출의 일부로 또는 `services.Configure<RouteOptions>`를 사용하여 직접 <xref:Microsoft.AspNetCore.Routing.RouteOptions>를 구성하여 앱의 `ConstraintMap`을 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-606">An app's `ConstraintMap` can be updated in `Startup.ConfigureServices` either as part of a [services.AddRouting](xref:Microsoft.Extensions.DependencyInjection.RoutingServiceCollectionExtensions.AddRouting*) call or by configuring <xref:Microsoft.AspNetCore.Routing.RouteOptions> directly with `services.Configure<RouteOptions>`.</span></span> <span data-ttu-id="f6d02-607">예를 들어:</span><span class="sxs-lookup"><span data-stu-id="f6d02-607">For example:</span></span>

[!code-csharp[](routing/samples/3.x/RoutingSample/StartupConstraint.cs?name=snippet)]

<span data-ttu-id="f6d02-608">위의 제약 조건은 다음 코드에서 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-608">The preceding constraint is applied in the following code:</span></span>

[!code-csharp[](routing/samples/3.x/RoutingSample/Controllers/TestController.cs?name=snippet&highlight=6,13)]

[!INCLUDE[](~/includes/MyDisplayRouteInfo.md)]

<span data-ttu-id="f6d02-609">`MyCustomConstraint`를 구현하면 경로 매개 변수에 `0`이 적용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-609">The implementation of `MyCustomConstraint` prevents `0` being applied to a route parameter:</span></span>

[!code-csharp[](routing/samples/3.x/RoutingSample/StartupConstraint.cs?name=snippet2)]

[!INCLUDE[](~/includes/regex.md)]

<span data-ttu-id="f6d02-610">위의 코드는</span><span class="sxs-lookup"><span data-stu-id="f6d02-610">The preceding code:</span></span>

* <span data-ttu-id="f6d02-611">경로의 `{id}` 세그먼트에 `0`을 사용하지 못하게 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-611">Prevents `0` in the `{id}` segment of the route.</span></span>
* <span data-ttu-id="f6d02-612">사용자 지정 제약 조건을 구현하는 기본 예제를 제공하기 위해 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-612">Is shown to provide a basic example of implementing a custom constraint.</span></span> <span data-ttu-id="f6d02-613">프로덕션 앱에 사용해서는 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-613">It should not be used in a production app.</span></span>

<span data-ttu-id="f6d02-614">다음 코드는 `0`이 포함된 `id`가 처리되지 않게 하는 더 나은 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-614">The following code is a better approach to preventing an `id` containing a `0` from being processed:</span></span>

[!code-csharp[](routing/samples/3.x/RoutingSample/Controllers/TestController.cs?name=snippet2)]

<span data-ttu-id="f6d02-615">위의 코드는 `MyCustomConstraint` 접근 방식과 비교하면 다음과 같은 이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-615">The preceding code has the following advantages over the `MyCustomConstraint` approach:</span></span>

* <span data-ttu-id="f6d02-616">사용자 지정 제약 조건이 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-616">It doesn't require a custom constraint.</span></span>
* <span data-ttu-id="f6d02-617">경로 매개 변수에 `0`이 포함된 경우 더 자세한 설명이 포함된 오류를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-617">It returns a more descriptive error when the route parameter includes `0`.</span></span>

## <a name="parameter-transformer-reference"></a><span data-ttu-id="f6d02-618">매개 변수 변환기 참조</span><span class="sxs-lookup"><span data-stu-id="f6d02-618">Parameter transformer reference</span></span>

<span data-ttu-id="f6d02-619">매개 변수 변환기는:</span><span class="sxs-lookup"><span data-stu-id="f6d02-619">Parameter transformers:</span></span>

* <span data-ttu-id="f6d02-620"><xref:Microsoft.AspNetCore.Routing.LinkGenerator>를 사용하여 링크를 생성할 때 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-620">Execute when generating a link using <xref:Microsoft.AspNetCore.Routing.LinkGenerator>.</span></span>
* <span data-ttu-id="f6d02-621"><xref:Microsoft.AspNetCore.Routing.IOutboundParameterTransformer?displayProperty=fullName>를 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-621">Implement <xref:Microsoft.AspNetCore.Routing.IOutboundParameterTransformer?displayProperty=fullName>.</span></span>
* <span data-ttu-id="f6d02-622"><xref:Microsoft.AspNetCore.Routing.RouteOptions.ConstraintMap>을 사용하여 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-622">Are configured using <xref:Microsoft.AspNetCore.Routing.RouteOptions.ConstraintMap>.</span></span>
* <span data-ttu-id="f6d02-623">매개 변수의 경로 값을 가져와서 새 문자열 값으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-623">Take the parameter's route value and transform it to a new string value.</span></span>
* <span data-ttu-id="f6d02-624">생성된 링크에서 변환된 값을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-624">Result in using the transformed value in the generated link.</span></span>

<span data-ttu-id="f6d02-625">예를 들어, `Url.Action(new { article = "MyTestArticle" })`을 사용하는 경로 패턴 `blog\{article:slugify}`의 사용자 지정 `slugify` 매개 변수 변환기는 `blog\my-test-article`을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-625">For example, a custom `slugify` parameter transformer in route pattern `blog\{article:slugify}` with `Url.Action(new { article = "MyTestArticle" })` generates `blog\my-test-article`.</span></span>

<span data-ttu-id="f6d02-626">다음 `IOutboundParameterTransformer` 구현을 생각해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-626">Consider the following `IOutboundParameterTransformer` implementation:</span></span>

[!code-csharp[](routing/samples/3.x/RoutingSample/StartupConstraint2.cs?name=snippet2)]

<span data-ttu-id="f6d02-627">경로 패턴에서 매개 변수 변환기를 사용하려면 `Startup.ConfigureServices`의 <xref:Microsoft.AspNetCore.Routing.RouteOptions.ConstraintMap>을 사용하여 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-627">To use a parameter transformer in a route pattern, configure it using <xref:Microsoft.AspNetCore.Routing.RouteOptions.ConstraintMap> in `Startup.ConfigureServices`:</span></span>

[!code-csharp[](routing/samples/3.x/RoutingSample/StartupConstraint2.cs?name=snippet)]

<span data-ttu-id="f6d02-628">ASP.NET Core Framework는 매개 변수 변화기를 사용하여 엔드포인트가 해결되는 URI를 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-628">The ASP.NET Core framework uses parameter transformers to transform the URI where an endpoint resolves.</span></span> <span data-ttu-id="f6d02-629">예를 들어 매개 변수 변환기는 `area`, `controller`, `action` 및 `page`와 일치하도록 사용되는 경로 값을 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-629">For example, parameter transformers transform the route values used to match an `area`, `controller`, `action`, and `page`.</span></span>

```csharp
routes.MapControllerRoute(
    name: "default",
    template: "{controller:slugify=Home}/{action:slugify=Index}/{id?}");
```

<span data-ttu-id="f6d02-630">위의 경로 템플릿을 사용하면 `SubscriptionManagementController.GetAll` 작업이 URI `/subscription-management/get-all`과 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-630">With the preceding route template, the action `SubscriptionManagementController.GetAll` is matched with the URI `/subscription-management/get-all`.</span></span> <span data-ttu-id="f6d02-631">매개 변수 변환기는 링크를 생성하는 데 사용되는 경로 값을 변경하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-631">A parameter transformer doesn't change the route values used to generate a link.</span></span> <span data-ttu-id="f6d02-632">예를 들어 `Url.Action("GetAll", "SubscriptionManagement")`는 `/subscription-management/get-all`을 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-632">For example, `Url.Action("GetAll", "SubscriptionManagement")` outputs `/subscription-management/get-all`.</span></span>

<span data-ttu-id="f6d02-633">ASP.NET Core는 생성된 경로와 함께 매개 변수 변환기를 사용하기 위한 API 규칙을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-633">ASP.NET Core provides API conventions for using parameter transformers with generated routes:</span></span>

* <span data-ttu-id="f6d02-634">이 <xref:Microsoft.AspNetCore.Mvc.ApplicationModels.RouteTokenTransformerConvention?displayProperty=fullName> MVC 규칙은 앱의 모든 특성 경로에 지정된 매개 변수 변환기를 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-634">The <xref:Microsoft.AspNetCore.Mvc.ApplicationModels.RouteTokenTransformerConvention?displayProperty=fullName> MVC convention applies a specified parameter transformer to all attribute routes in the app.</span></span> <span data-ttu-id="f6d02-635">매개 변수 변환기는 특성 경로 토큰이 교체될 때 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-635">The parameter transformer transforms attribute route tokens as they are replaced.</span></span> <span data-ttu-id="f6d02-636">자세한 내용은 [매개 변수 변환기를 사용하여 토큰 교체 사용자 지정](xref:mvc/controllers/routing#use-a-parameter-transformer-to-customize-token-replacement)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-636">For more information, see [Use a parameter transformer to customize token replacement](xref:mvc/controllers/routing#use-a-parameter-transformer-to-customize-token-replacement).</span></span>
* <span data-ttu-id="f6d02-637">Razor Pages에서는 <xref:Microsoft.AspNetCore.Mvc.ApplicationModels.PageRouteTransformerConvention> API 규칙을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-637">Razor Pages uses the <xref:Microsoft.AspNetCore.Mvc.ApplicationModels.PageRouteTransformerConvention> API convention.</span></span> <span data-ttu-id="f6d02-638">이 규칙은 자동으로 검색된 모든 Razor Pages에 지정된 매개 변수 변환기를 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-638">This convention applies a specified parameter transformer to all automatically discovered Razor Pages.</span></span> <span data-ttu-id="f6d02-639">매개 변수 변환기는 Razor Pages 경로의 폴더와 파일 이름 부분을 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-639">The parameter transformer transforms the folder and file name segments of Razor Pages routes.</span></span> <span data-ttu-id="f6d02-640">자세한 내용은 [매개 변수 변환기를 사용하여 페이지 경로 사용자 지정](xref:razor-pages/razor-pages-conventions#use-a-parameter-transformer-to-customize-page-routes)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-640">For more information, see [Use a parameter transformer to customize page routes](xref:razor-pages/razor-pages-conventions#use-a-parameter-transformer-to-customize-page-routes).</span></span>

<a name="ugr"></a>

## <a name="url-generation-reference"></a><span data-ttu-id="f6d02-641">URL 생성 참조</span><span class="sxs-lookup"><span data-stu-id="f6d02-641">URL generation reference</span></span>

<span data-ttu-id="f6d02-642">이 단원에는 URL 생성에서 구현하는 알고리즘에 대한 참조가 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-642">This section contains a reference for the algorithm implemented by URL generation.</span></span> <span data-ttu-id="f6d02-643">실제로 URL 생성의 가장 복잡한 예제에서는 컨트롤러나 Razor Pages를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-643">In practice, most complex examples of URL generation use controllers or Razor Pages.</span></span> <span data-ttu-id="f6d02-644">자세한 내용은 [routing in controllers](xref:mvc/controllers/routing)(컨트롤러의 라우팅)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-644">See  [routing in controllers](xref:mvc/controllers/routing) for additional information.</span></span>

<span data-ttu-id="f6d02-645">URL 생성 프로세스는 [LinkGenerator. GetPathByAddress](xref:Microsoft.AspNetCore.Routing.LinkGenerator.GetPathByAddress*) 또는 이와 유사한 메서드를 호출하여 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-645">The URL generation process begins with a call to [LinkGenerator.GetPathByAddress](xref:Microsoft.AspNetCore.Routing.LinkGenerator.GetPathByAddress*) or a similar method.</span></span> <span data-ttu-id="f6d02-646">메서드에는 주소, 경로 값 집합 및 `HttpContext`의 현재 요청에 관한 정보(선택 사항)를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-646">The method is provided with an address, a set of route values, and optionally information about the current request from `HttpContext`.</span></span>

<span data-ttu-id="f6d02-647">첫 번째 단계에서는 주소를 사용하여 주소의 형식과 일치하는 [`IEndpointAddressScheme<TAddress>`](xref:Microsoft.AspNetCore.Routing.IEndpointAddressScheme`1)을 사용하는 후보 엔드포인트 집합을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-647">The first step is to use the address to resolve a set of candidate endpoints using an [`IEndpointAddressScheme<TAddress>`](xref:Microsoft.AspNetCore.Routing.IEndpointAddressScheme`1) that matches the address's type.</span></span>

<span data-ttu-id="f6d02-648">주소 체계에 따라 후보 집합을 찾으면 URL 생성 작업이 성공할 때까지 엔드포인트가 순서 지정되고 반복적으로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-648">Once of set of candidates is found by the address scheme, the endpoints are ordered and processed iteratively until a URL generation operation succeeds.</span></span> <span data-ttu-id="f6d02-649">URL 생성에서는 모호성을 확인하지 **않으며**, 반환되는 첫 번째 결과가 최종 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-649">URL generation does **not** check for ambiguities, the first result returned is the final result.</span></span>

### <a name="troubleshooting-url-generation-with-logging"></a><span data-ttu-id="f6d02-650">로깅을 사용하여 URL 생성 문제 해결</span><span class="sxs-lookup"><span data-stu-id="f6d02-650">Troubleshooting URL generation with logging</span></span>

<span data-ttu-id="f6d02-651">URL 생성 문제를 해결하는 첫 번째 단계는 `Microsoft.AspNetCore.Routing`의 로깅 수준을 `TRACE`로 설정하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-651">The first step in troubleshooting URL generation is setting the logging level of `Microsoft.AspNetCore.Routing` to `TRACE`.</span></span> <span data-ttu-id="f6d02-652">`LinkGenerator`는 문제 해결에 유용할 수 있는 처리에 관한 여러 세부 정보를 기록합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-652">`LinkGenerator` logs many details about its processing which can be useful to troubleshoot problems.</span></span>

<span data-ttu-id="f6d02-653">URL 생성에 대한 자세한 내용은 [URL 생성 참조](#ugr)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-653">See [URL generation reference](#ugr) for details on URL generation.</span></span>

### <a name="addresses"></a><span data-ttu-id="f6d02-654">주소</span><span class="sxs-lookup"><span data-stu-id="f6d02-654">Addresses</span></span>

<span data-ttu-id="f6d02-655">주소는 URL 생성에서 링크 생성기의 호출을 후보 엔드포인트 집합에 바인딩하는 데 사용되는 개념입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-655">Addresses are the concept in URL generation used to bind a call into the link generator to a set of candidate endpoints.</span></span>

<span data-ttu-id="f6d02-656">주소는 기본적으로 다음 두 가지 구현이 함께 제공되는 확장 가능한 개념입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-656">Addresses are an extensible concept that come with two implementations by default:</span></span>

* <span data-ttu-id="f6d02-657">‘엔드포인트 이름’(`string`)을 주소로 사용: </span><span class="sxs-lookup"><span data-stu-id="f6d02-657">Using *endpoint name* (`string`) as the address:</span></span>
    * <span data-ttu-id="f6d02-658">MVC의 경로 이름과 유사한 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-658">Provides similar functionality to MVC's route name.</span></span>
    * <span data-ttu-id="f6d02-659"><xref:Microsoft.AspNetCore.Routing.IEndpointNameMetadata> 메타데이터 형식을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-659">Uses the <xref:Microsoft.AspNetCore.Routing.IEndpointNameMetadata> metadata type.</span></span>
    * <span data-ttu-id="f6d02-660">등록된 모든 엔드포인트의 메타데이터와 제공된 문자열을 비교하여 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-660">Resolves the provided string against the metadata of all registered endpoints.</span></span>
    * <span data-ttu-id="f6d02-661">여러 엔드포인트에서 같은 이름을 사용하는 경우 시작 시 예외를 throw합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-661">Throws an exception on startup if multiple endpoints use the same name.</span></span>
    * <span data-ttu-id="f6d02-662">컨트롤러 및 Razor Pages 외의 일반적인 용도에 사용하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-662">Recommended for general-purpose use outside of controllers and Razor Pages.</span></span>
* <span data-ttu-id="f6d02-663">‘경로 값’(<xref:Microsoft.AspNetCore.Routing.RouteValuesAddress>)을 주소로 사용: </span><span class="sxs-lookup"><span data-stu-id="f6d02-663">Using *route values* (<xref:Microsoft.AspNetCore.Routing.RouteValuesAddress>) as the address:</span></span>
    * <span data-ttu-id="f6d02-664">컨트롤러 및 Razor Pages 레거시 URL 생성과 비슷한 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-664">Provides similar functionality to controllers and Razor Pages legacy URL generation.</span></span>
    * <span data-ttu-id="f6d02-665">확장 및 디버그하기가 매우 복잡합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-665">Very complex to extend and debug.</span></span>
    * <span data-ttu-id="f6d02-666">`IUrlHelper`, 태그 도우미, HTML 도우미, 작업 결과 등에서 사용하는 구현을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-666">Provides the implementation used by `IUrlHelper`, Tag Helpers, HTML Helpers, Action Results, etc.</span></span>

<span data-ttu-id="f6d02-667">주소 체계의 역할은 다음과 같은 임의 조건에 따라 주소와 일치하는 엔드포인트 사이를 연결하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-667">The role of the address scheme is to make the association between the address and matching endpoints by arbitrary criteria:</span></span>

* <span data-ttu-id="f6d02-668">엔드포인트 이름 체계에서 기본 사전 조회를 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-668">The endpoint name scheme performs a basic dictionary lookup.</span></span>
* <span data-ttu-id="f6d02-669">경로 값 체계에는 알고리즘의 복잡한 최적 하위 집합이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-669">The route values scheme has a complex best subset of set algorithm.</span></span>

<a name="ambient"></a>

### <a name="ambient-values-and-explicit-values"></a><span data-ttu-id="f6d02-670">앰비언트 값 및 명시적 값</span><span class="sxs-lookup"><span data-stu-id="f6d02-670">Ambient values and explicit values</span></span>

<span data-ttu-id="f6d02-671">현재 요청에서 라우팅은 현재 요청의 경로 값 `HttpContext.Request.RouteValues`에 액세스합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-671">From the current request, routing accesses the route values of the current request `HttpContext.Request.RouteValues`.</span></span> <span data-ttu-id="f6d02-672">현재 요청과 연결된 값을 **앰비언트 값**이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-672">The values associated with the current request are referred to as the **ambient values**.</span></span> <span data-ttu-id="f6d02-673">명확하게 하도록 설명서에서는 메서드에 전달된 경로 값을 **명시적 값**이라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-673">For the purpose of clarity, the documentation refers to the route values passed in to methods as **explicit values**.</span></span>

<span data-ttu-id="f6d02-674">다음 예제에서는 앰비언트 값과 명시적 값을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-674">The following example shows ambient values and explicit values.</span></span> <span data-ttu-id="f6d02-675">현재 요청의 앰비언트 값과 명시적 값 `{ id = 17, }`을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-675">It provides ambient values from the current request and explicit values: `{ id = 17, }`:</span></span>

[!code-csharp[](routing/samples/3.x/RoutingSample/Controllers/WidgetController.cs?name=snippet)]

<span data-ttu-id="f6d02-676">위의 코드는</span><span class="sxs-lookup"><span data-stu-id="f6d02-676">The preceding code:</span></span>

* <span data-ttu-id="f6d02-677">`/Widget/Index/17`를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-677">Returns `/Widget/Index/17`</span></span>
* <span data-ttu-id="f6d02-678">[DI](xref:fundamentals/dependency-injection)를 통해 <xref:Microsoft.AspNetCore.Routing.LinkGenerator>를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-678">Gets <xref:Microsoft.AspNetCore.Routing.LinkGenerator> via [DI](xref:fundamentals/dependency-injection).</span></span>

<span data-ttu-id="f6d02-679">다음 코드는 앰비언트 값과 `{ controller = "Home", action = "Subscribe", id = 17, }`을 제공하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-679">The following code provides no ambient values and explicit values: `{ controller = "Home", action = "Subscribe", id = 17, }`:</span></span>

[!code-csharp[](routing/samples/3.x/RoutingSample/Controllers/WidgetController.cs?name=snippet2)]

<span data-ttu-id="f6d02-680">앞의 메서드는 `/Home/Subscribe/17`을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-680">The preceding  method returns `/Home/Subscribe/17`</span></span>

<span data-ttu-id="f6d02-681">`WidgetController`의 다음 코드는 `/Widget/Subscribe/17`을 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-681">The following code in the `WidgetController` returns `/Widget/Subscribe/17`:</span></span>

[!code-csharp[](routing/samples/3.x/RoutingSample/Controllers/WidgetController.cs?name=snippet3)]

<span data-ttu-id="f6d02-682">다음 코드는 현재 요청의 앰비언트 값과 명시적 값 `{ action = "Edit", id = 17, }`을 컨트롤러에 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-682">The following code provides the controller from ambient values in the current request and explicit values: `{ action = "Edit", id = 17, }`:</span></span>

[!code-csharp[](routing/samples/3.x/RoutingSample/Controllers/GadgetController.cs?name=snippet)]

<span data-ttu-id="f6d02-683">위의 코드에서</span><span class="sxs-lookup"><span data-stu-id="f6d02-683">In the preceding code:</span></span>

* <span data-ttu-id="f6d02-684">`/Gadget/Edit/17`이 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-684">`/Gadget/Edit/17` is returned.</span></span>
* <span data-ttu-id="f6d02-685"><xref:Microsoft.AspNetCore.Mvc.ControllerBase.Url>는 <xref:Microsoft.AspNetCore.Mvc.IUrlHelper>를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-685"><xref:Microsoft.AspNetCore.Mvc.ControllerBase.Url> gets the <xref:Microsoft.AspNetCore.Mvc.IUrlHelper>.</span></span>
* <xref:Microsoft.AspNetCore.Mvc.UrlHelperExtensions.Action*>   
<span data-ttu-id="f6d02-686">작업 메서드의 절대 경로가 포함된 URL을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-686">generates a URL with an absolute path for an action method.</span></span> <span data-ttu-id="f6d02-687">URL에는 지정된 `action` 이름과 `route` 값이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-687">The URL contains the specified `action` name and `route` values.</span></span>

<span data-ttu-id="f6d02-688">다음 코드에서는 현재 요청의 앰비언트 값과 명시적 값 `{ page = "./Edit, id = 17, }`을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-688">The following code provides ambient values from the current request and explicit values: `{ page = "./Edit, id = 17, }`:</span></span>

[!code-csharp[](routing/samples/3.x/RoutingSample/Pages/Index.cshtml.cs?name=snippet)]

<span data-ttu-id="f6d02-689">앞의 코드에서는 Razor 편집 페이지에 다음 지시문이 포함된 경우 `url`을 `/Edit/17`로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-689">The preceding code sets `url` to  `/Edit/17` when the Edit Razor Page contains the following page directive:</span></span>

 `@page "{id:int}"`

<span data-ttu-id="f6d02-690">편집 페이지에 `"{id:int}"` 경로 템플릿이 포함되어 있지 않으면 `url`은 `/Edit?id=17`입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-690">If the Edit page doesn't contain the `"{id:int}"` route template, `url` is `/Edit?id=17`.</span></span>

<span data-ttu-id="f6d02-691">MVC의 <xref:Microsoft.AspNetCore.Mvc.IUrlHelper> 동작은 여기에 설명된 규칙 외에도 복잡성 계층을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-691">The behavior of MVC's <xref:Microsoft.AspNetCore.Mvc.IUrlHelper> adds a layer of complexity in addition to the rules described here:</span></span>

* <span data-ttu-id="f6d02-692">`IUrlHelper`는 항상 현재 요청의 경로 값을 앰비언트 값으로 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-692">`IUrlHelper` always provides the route values from the current request as ambient values.</span></span>
* <span data-ttu-id="f6d02-693">[IUrlHelper.Action](xref:Microsoft.AspNetCore.Mvc.UrlHelperExtensions.Action*)은 개발자가 재정의하는 경우 외에는 항상 현재 `action` 및 `controller` 경로 값을 명시적 값으로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-693">[IUrlHelper.Action](xref:Microsoft.AspNetCore.Mvc.UrlHelperExtensions.Action*) always copies the current `action` and `controller` route values as explicit values unless overridden by the developer.</span></span>
* <span data-ttu-id="f6d02-694">[IUrlHelper.Page](xref:Microsoft.AspNetCore.Mvc.UrlHelperExtensions.Page*)는 재정의되는 경우 외에는 항상 현재 `page` 경로 값을 명시적 값으로 복사합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-694">[IUrlHelper.Page](xref:Microsoft.AspNetCore.Mvc.UrlHelperExtensions.Page*) always copies the current `page` route value as an explicit value unless overridden.</span></span> <!--by the user-->
* <span data-ttu-id="f6d02-695">`IUrlHelper.Page`는 재정의되는 경우 외에는 항상 현재 `handler` 경로 값을 명시적 값 `null`로 재정의합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-695">`IUrlHelper.Page` always overrides the current `handler` route value with `null` as an explicit values unless overridden.</span></span>

<span data-ttu-id="f6d02-696">MVC가 자체 규칙을 따르지 않기 때문에 앰비언트 값의 동작 세부 정보에 사용자가 놀라는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-696">Users are often surprised by the behavioral details of ambient values, because MVC doesn't seem to follow its own rules.</span></span> <span data-ttu-id="f6d02-697">기록 및 호환성을 위해 `action`, `controller`, `page`, `handler` 등의 특정 경로 값에는 고유한 특수 사례 동작이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-697">For historical and compatibility reasons, certain route values such as `action`, `controller`, `page`, and `handler` have their own special-case behavior.</span></span>

<span data-ttu-id="f6d02-698">`LinkGenerator.GetPathByAction` 및 `LinkGenerator.GetPathByPage`에서 제공하는 동일한 기능에서는 호환성을 위해 `IUrlHelper`의 이러한 변칙을 복제합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-698">The equivalent functionality provided by `LinkGenerator.GetPathByAction` and `LinkGenerator.GetPathByPage` duplicates these anomalies of `IUrlHelper` for compatibility.</span></span>

### <a name="url-generation-process"></a><span data-ttu-id="f6d02-699">URL 생성 프로세스</span><span class="sxs-lookup"><span data-stu-id="f6d02-699">URL generation process</span></span>

<span data-ttu-id="f6d02-700">후보 엔드포인트 집합을 찾으면 URL 생성 알고리즘은 다음을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-700">Once the set of candidate endpoints are found, the URL generation algorithm:</span></span>

* <span data-ttu-id="f6d02-701">엔드포인트를 반복적으로 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-701">Processes the endpoints iteratively.</span></span>
* <span data-ttu-id="f6d02-702">첫 번째 성공적인 결과를 반환합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-702">Returns the first successful result.</span></span>

<span data-ttu-id="f6d02-703">이 프로세스의 첫 번째 단계를 **경로 값 무효화**라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-703">The first step in this process is called **route value invalidation**.</span></span>  <span data-ttu-id="f6d02-704">경로 값 무효화는 라우팅에서 앰비언트 값의 어떤 경로 값을 사용하고 무시할지 결정하는 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-704">Route value invalidation is the process by which routing decides which route values from the ambient values should be used and which should be ignored.</span></span> <span data-ttu-id="f6d02-705">각 앰비언트 값이 고려되고 명시적 값과 결합되거나 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-705">Each ambient value is considered and either combined with the explicit values, or ignored.</span></span>

<span data-ttu-id="f6d02-706">앰비언트 값의 역할을 알아보려면 일반적인 사례에서 애플리케이션 개발자 입력을 저장하려고 하는 점을 고려하면 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-706">The best way to think about the role of ambient values is that they attempt to save application developers typing, in some common cases.</span></span> <span data-ttu-id="f6d02-707">일반적으로 앰비언트 값이 유용한 시나리오는 MVC와 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-707">Traditionally, the scenarios where ambient values are helpful are related to MVC:</span></span>

* <span data-ttu-id="f6d02-708">동일한 컨트롤러의 다른 작업에 연결하는 경우에는 컨트롤러 이름을 지정할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-708">When linking to another action in the same controller, the controller name doesn't need to be specified.</span></span>
* <span data-ttu-id="f6d02-709">같은 영역의 다른 컨트롤러에 연결하는 경우 영역 이름을 지정할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-709">When linking to another controller in the same area, the area name doesn't need to be specified.</span></span>
* <span data-ttu-id="f6d02-710">동일한 작업 메서드에 연결하는 경우 경로 값을 지정할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-710">When linking to the same action method, route values don't need to be specified.</span></span>
* <span data-ttu-id="f6d02-711">앱의 다른 부분에 연결하는 경우 앱의 해당 부분에서 의미가 없는 경로 값을 전달하지 않을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-711">When linking to another part of the app, you don't want to carry over route values that have no meaning in that part of the app.</span></span>

<span data-ttu-id="f6d02-712">`null`을 반환하는 `LinkGenerator` 또는 `IUrlHelper`를 호출하면 일반적으로 이해되지 않는 경로 값 무효화가 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-712">Calls to `LinkGenerator` or `IUrlHelper` that return `null` are usually caused by not understanding route value invalidation.</span></span> <span data-ttu-id="f6d02-713">경로 값 무효화 문제를 해결하려면 더 많은 경로 값을 명시적으로 지정하여 문제가 해결되는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-713">Troubleshoot route value invalidation by explicitly specifying more of the route values to see if that solves the problem.</span></span>

<span data-ttu-id="f6d02-714">경로 값 무효화는 앱의 URL 체계가 계층이 왼쪽에서 오른쪽으로 형성된 계층 구조라고 가정하고 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-714">Route value invalidation works on the assumption that the app's URL scheme is hierarchical, with a hierarchy formed from left-to-right.</span></span> <span data-ttu-id="f6d02-715">기본 컨트롤러 경로 템플릿 `{controller}/{action}/{id?}`를 사용하여 실제 작동 방법을 직관적으로 파악해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-715">Consider the basic controller route template `{controller}/{action}/{id?}` to get an intuitive sense of how this works in practice.</span></span> <span data-ttu-id="f6d02-716">값을 **변경**하면 오른쪽에 표시되는 경로 값이 모두 **무효화**됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-716">A **change** to a value **invalidates** all of the route values that appear to the right.</span></span> <span data-ttu-id="f6d02-717">이는 계층 구조에 관한 가정이 반영된 것입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-717">This reflects the assumption about hierarchy.</span></span> <span data-ttu-id="f6d02-718">앱에 `id`의 앰비언트 값이 있고 작업에서 `controller`에 대해 다른 값을 지정하는 경우:</span><span class="sxs-lookup"><span data-stu-id="f6d02-718">If the app has an ambient value for `id`, and the operation specifies a different value for the `controller`:</span></span>

* <span data-ttu-id="f6d02-719">`{controller}`가 `{id?}`의 왼쪽에 있으므로 `id`가 다시 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-719">`id` won't be reused because `{controller}` is to the left of `{id?}`.</span></span>

<span data-ttu-id="f6d02-720">이 원칙을 보여 주는 몇 가지 예는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-720">Some examples demonstrating this principle:</span></span>

* <span data-ttu-id="f6d02-721">명시적 값에 `id`의 값이 포함된 경우 `id`의 앰비언트 값은 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-721">If the explicit values contain a value for `id`, the ambient value for `id` is ignored.</span></span> <span data-ttu-id="f6d02-722">`controller` 및 `action`의 앰비언트 값이 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-722">The ambient values for `controller` and `action` can be used.</span></span>
* <span data-ttu-id="f6d02-723">명시적 값에 `action`의 값이 포함된 경우 `action`의 앰비언트 값은 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-723">If the explicit values contain a value for `action`, any ambient value for `action` is ignored.</span></span> <span data-ttu-id="f6d02-724">`controller`의 앰비언트 값이 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-724">The ambient values for `controller` can be used.</span></span> <span data-ttu-id="f6d02-725">`action`의 명시적 값이 `action`의 앰비언트 값과 다른 경우 `id` 값은 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-725">If the explicit value for `action` is different from the ambient value for `action`, the `id` value won't be used.</span></span>  <span data-ttu-id="f6d02-726">`action`의 명시적 값이 `action`의 앰비언트 값과 같으면 `id` 값이 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-726">If the explicit value for `action` is the same as the ambient value for `action`, the `id` value can be used.</span></span>
* <span data-ttu-id="f6d02-727">명시적 값에 `controller`의 값이 포함된 경우 `controller`의 앰비언트 값은 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-727">If the explicit values contain a value for `controller`, any ambient value for `controller` is ignored.</span></span> <span data-ttu-id="f6d02-728">`controller`의 명시적 값이 `controller`의 앰비언트 값과 다른 경우 `action` 및 `id` 값은 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-728">If the explicit value for `controller` is different from the ambient value for `controller`, the `action` and `id` values won't be used.</span></span> <span data-ttu-id="f6d02-729">`controller`의 명시적 값이 `controller`의 앰비언트 값과 같으면 `action` 및 `id` 값이 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-729">If the explicit value for `controller` is the same as the ambient value for `controller`, the `action` and `id` values can be used.</span></span>

<span data-ttu-id="f6d02-730">이 프로세스는 특성 경로와 전용 규칙 기반 경로가 있으면 더 복잡해집니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-730">This process is further complicated by the existence of attribute routes and dedicated conventional routes.</span></span> <span data-ttu-id="f6d02-731">`{controller}/{action}/{id?}`와 같은 컨트롤러 규칙 기반 경로는 경로 매개 변수를 사용하여 계층 구조를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-731">Controller conventional routes such as `{controller}/{action}/{id?}` specify a hierarchy using route parameters.</span></span> <span data-ttu-id="f6d02-732">컨트롤러 및 Razor Pages에 대한 [전용 규칙 기반 경로](xref:mvc/controllers/routing#dcr) 및 [특성 경로](xref:mvc/controllers/routing#ar)의 경우:</span><span class="sxs-lookup"><span data-stu-id="f6d02-732">For [dedicated conventional routes](xref:mvc/controllers/routing#dcr) and [attribute routes](xref:mvc/controllers/routing#ar) to controllers and Razor Pages:</span></span>

* <span data-ttu-id="f6d02-733">경로 값의 계층 구조가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-733">There is a hierarchy of route values.</span></span>
* <span data-ttu-id="f6d02-734">템플릿에는 표시되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-734">They don't appear in the template.</span></span>

<span data-ttu-id="f6d02-735">이러한 경우 URL 생성에서 **필수 값** 개념을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-735">For these cases, URL generation defines the **required values** concept.</span></span> <span data-ttu-id="f6d02-736">컨트롤러 및 Razor Pages에서 만든 엔드포인트에는 경로 값 무효화가 작동할 수 있도록 필수 값이 지정되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-736">Endpoints created by controllers and Razor Pages have required values specified that allow route value invalidation to work.</span></span>

<span data-ttu-id="f6d02-737">경로 값 무효화 알고리즘을 자세히 설명하면 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-737">The route value invalidation algorithm in detail:</span></span>

* <span data-ttu-id="f6d02-738">필요 값 이름을 경로 매개 변수와 결합한 다음 왼쪽에서 오른쪽으로 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-738">The required value names are combined with the route parameters, then processed from left-to-right.</span></span>
* <span data-ttu-id="f6d02-739">각 매개 변수에 대해 앰비언트 값과 명시적 값을 비교합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-739">For each parameter, the ambient value and explicit value are compared:</span></span>
    * <span data-ttu-id="f6d02-740">앰비언트 값과 명시적 값이 같으면 프로세스가 계속됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-740">If the ambient value and explicit value are the same, the process continues.</span></span>
    * <span data-ttu-id="f6d02-741">앰비언트 값이 있고 명시적 값이 없으면 URL을 생성할 때 앰비언트 값이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-741">If the ambient value is present and the explicit value isn't, the ambient value is used when generating the URL.</span></span>
    * <span data-ttu-id="f6d02-742">앰비언트 값이 없고 명시적 값이 있으면 앰비언트 값과 모든 후속 앰비언트 값을 거부합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-742">If the ambient value isn't present and the explicit value is, reject the ambient value and all subsequent ambient values.</span></span>
    * <span data-ttu-id="f6d02-743">앰비언트 값과 명시적 값이 있고 두 값이 다른 경우 앰비언트 값과 모든 후속 앰비언트 값을 거부합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-743">If the ambient value and the explicit value are present, and the two values are different, reject the ambient value and all subsequent ambient values.</span></span>

<span data-ttu-id="f6d02-744">이제 URL 생성 작업에서 경로 제약 조건을 평가할 준비가 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-744">At this point, the URL generation operation is ready to evaluate route constraints.</span></span> <span data-ttu-id="f6d02-745">허용되는 값 집합이 제약 조건에 제공되는 매개 변수 기본값과 결합됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-745">The set of accepted values is combined with the parameter default values, which is provided to constraints.</span></span> <span data-ttu-id="f6d02-746">제약 조건이 모두 통과되면 작업이 계속됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-746">If the constraints all pass, the operation continues.</span></span>

<span data-ttu-id="f6d02-747">다음으로 **허용되는 값**을 사용하여 경로 템플릿을 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-747">Next, the **accepted values** can be used to expand the route template.</span></span> <span data-ttu-id="f6d02-748">경로 템플릿은 다음과 같이 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-748">The route template is processed:</span></span>

* <span data-ttu-id="f6d02-749">왼쪽에서 오른쪽으로</span><span class="sxs-lookup"><span data-stu-id="f6d02-749">From left-to-right.</span></span>
* <span data-ttu-id="f6d02-750">각 매개 변수의 허용되는 값이 대체됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-750">Each parameter has its accepted value substituted.</span></span>
* <span data-ttu-id="f6d02-751">다음과 같은 특수 사례의 경우:</span><span class="sxs-lookup"><span data-stu-id="f6d02-751">With the following special cases:</span></span>
  * <span data-ttu-id="f6d02-752">허용되는 값에 누락된 값이 있고 매개 변수에 기본값이 있으면 기본값이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-752">If the accepted values is missing a value and the parameter has a default value, the default value is used.</span></span>
  * <span data-ttu-id="f6d02-753">허용되는 값에 누락된 값이 있고 매개 변수가 선택 사항이면 처리가 계속됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-753">If the accepted values is missing a value and the parameter is optional, processing continues.</span></span>
  * <span data-ttu-id="f6d02-754">누락된 선택적 매개 변수 오른쪽의 경로 매개 변수에 값이 있으면 작업이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-754">If any route parameter to the right of a missing optional parameter has a value, the operation fails.</span></span>
  * <!-- review default-valued parameters optional parameters --> <span data-ttu-id="f6d02-755">연속된 기본값 매개 변수 및 선택적 매개 변수는 가능하면 축소됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-755">Contiguous default-valued parameters and optional parameters are collapsed where possible.</span></span>

<span data-ttu-id="f6d02-756">명시적으로 제공되지만 경로의 세그먼트와 일치하지 않는 값은 쿼리 문자열에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-756">Values explicitly provided that don't match a segment of the route are added to the query string.</span></span> <span data-ttu-id="f6d02-757">다음 표에서 경로 템플릿 `{controller}/{action}/{id?}`를 사용하는 경우 결과를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-757">The following table shows the result when using the route template `{controller}/{action}/{id?}`.</span></span>

| <span data-ttu-id="f6d02-758">앰비언트 값</span><span class="sxs-lookup"><span data-stu-id="f6d02-758">Ambient Values</span></span>                     | <span data-ttu-id="f6d02-759">명시적 값</span><span class="sxs-lookup"><span data-stu-id="f6d02-759">Explicit Values</span></span>                        | <span data-ttu-id="f6d02-760">결과</span><span class="sxs-lookup"><span data-stu-id="f6d02-760">Result</span></span>                  |
| ---------------------------------- | -------------------------------------- | ----------------------- |
| <span data-ttu-id="f6d02-761">controller = "Home"</span><span class="sxs-lookup"><span data-stu-id="f6d02-761">controller = "Home"</span></span>                | <span data-ttu-id="f6d02-762">action = "About"</span><span class="sxs-lookup"><span data-stu-id="f6d02-762">action = "About"</span></span>                       | `/Home/About`           |
| <span data-ttu-id="f6d02-763">controller = "Home"</span><span class="sxs-lookup"><span data-stu-id="f6d02-763">controller = "Home"</span></span>                | <span data-ttu-id="f6d02-764">controller = "Order", action = "About"</span><span class="sxs-lookup"><span data-stu-id="f6d02-764">controller = "Order", action = "About"</span></span> | `/Order/About`          |
| <span data-ttu-id="f6d02-765">controller = "Home", color = "Red"</span><span class="sxs-lookup"><span data-stu-id="f6d02-765">controller = "Home", color = "Red"</span></span> | <span data-ttu-id="f6d02-766">action = "About"</span><span class="sxs-lookup"><span data-stu-id="f6d02-766">action = "About"</span></span>                       | `/Home/About`           |
| <span data-ttu-id="f6d02-767">controller = "Home"</span><span class="sxs-lookup"><span data-stu-id="f6d02-767">controller = "Home"</span></span>                | <span data-ttu-id="f6d02-768">action = "About", color = "Red"</span><span class="sxs-lookup"><span data-stu-id="f6d02-768">action = "About", color = "Red"</span></span>        | `/Home/About?color=Red` |

### <a name="problems-with-route-value-invalidation"></a><span data-ttu-id="f6d02-769">경로 값 무효화 문제</span><span class="sxs-lookup"><span data-stu-id="f6d02-769">Problems with route value invalidation</span></span>

<span data-ttu-id="f6d02-770">ASP.NET Core 3.0부터 이전 ASP.NET Core 버전에서 사용되는 일부 URL 생성 체계가 URL 생성에서 잘 작동하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-770">As of ASP.NET Core 3.0, some URL generation schemes used in earlier ASP.NET Core versions don't work well with URL generation.</span></span> <span data-ttu-id="f6d02-771">ASP.NET Core 팀은 향후 릴리스에서 이러한 요구를 해결하는 기능을 추가할 계획입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-771">The ASP.NET Core team plans to add features to address these needs in a future release.</span></span> <span data-ttu-id="f6d02-772">지금은 레거시 라우팅을 사용하는 것이 가장 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-772">For now the best solution is to use legacy routing.</span></span>

<span data-ttu-id="f6d02-773">다음 코드에서는 라우팅에서 지원하지 않는 URL 생성 체계의 예제를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-773">The following code shows an example of a URL generation scheme that's not supported by routing.</span></span>

[!code-csharp[](routing/samples/3.x/RoutingSample/StartupUnsupported.cs?name=snippet)]

<span data-ttu-id="f6d02-774">위의 코드에서 `culture` 경로 매개 변수는 지역화에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-774">In the preceding code, the `culture` route parameter is used for localization.</span></span> <span data-ttu-id="f6d02-775">`culture` 매개 변수가 앰비언트 값으로 항상 허용되게 하려는 것이 목표입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-775">The desire is to have the `culture` parameter always accepted as an ambient value.</span></span> <span data-ttu-id="f6d02-776">그러나 `culture` 매개 변수는 필수 값이 작동하는 방식 때문에 앰비언트 값으로 허용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-776">However, the `culture` parameter is not accepted as an ambient value because of the way required values work:</span></span>

* <span data-ttu-id="f6d02-777">`"default"` 경로 템플릿에서 `culture` 경로 매개 변수는 `controller`의 왼쪽에 있으므로 `controller`를 변경해도 `culture`가 무효화되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-777">In the `"default"` route template, the `culture` route parameter is to the left of `controller`, so changes to `controller` won't invalidate `culture`.</span></span>
* <span data-ttu-id="f6d02-778">`"blog"` 경로 템플릿에서 `culture` 경로 매개 변수는 필수 값에 표시되는 `controller`의 오른쪽에 있는 것으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-778">In the `"blog"` route template, the `culture` route parameter is considered to be to the right of `controller`, which appears in the required values.</span></span>

## <a name="configuring-endpoint-metadata"></a><span data-ttu-id="f6d02-779">엔드포인트 메타데이터 구성</span><span class="sxs-lookup"><span data-stu-id="f6d02-779">Configuring endpoint metadata</span></span>

<span data-ttu-id="f6d02-780">다음 링크는 엔드포인트 메타데이터를 구성하는 방법에 대한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-780">The following links provide information on configuring endpoint metadata:</span></span>

* [<span data-ttu-id="f6d02-781">엔드포인트 라우팅을 사용하여 Cors 사용</span><span class="sxs-lookup"><span data-stu-id="f6d02-781">Enable Cors with endpoint routing</span></span>](xref:security/cors#enable-cors-with-endpoint-routing)
* <span data-ttu-id="f6d02-782">사용자 지정 `[MinimumAgeAuthorize]` 특성을 사용하는 [IAuthorizationPolicyProvider 샘플](https://github.com/dotnet/AspNetCore/tree/release/3.0/src/Security/samples/CustomPolicyProvider)</span><span class="sxs-lookup"><span data-stu-id="f6d02-782">[IAuthorizationPolicyProvider sample](https://github.com/dotnet/AspNetCore/tree/release/3.0/src/Security/samples/CustomPolicyProvider) using a custom `[MinimumAgeAuthorize]` attribute</span></span>
* <span data-ttu-id="f6d02-783">[[권한 부여] 특성으로 인증 테스트](xref:security/authentication/identity#test-identity)</span><span class="sxs-lookup"><span data-stu-id="f6d02-783">[Test authentication with the [Authorize] attribute](xref:security/authentication/identity#test-identity)</span></span>
* <xref:Microsoft.AspNetCore.Builder.AuthorizationEndpointConventionBuilderExtensions.RequireAuthorization*>
* <span data-ttu-id="f6d02-784">[[권한 부여] 특성을 갖는 체계 선택](xref:security/authorization/limitingidentitybyscheme#selecting-the-scheme-with-the-authorize-attribute)</span><span class="sxs-lookup"><span data-stu-id="f6d02-784">[Selecting the scheme with the [Authorize] attribute](xref:security/authorization/limitingidentitybyscheme#selecting-the-scheme-with-the-authorize-attribute)</span></span>
* <span data-ttu-id="f6d02-785">[[권한 부여] 특성을 사용하여 정책 적용](xref:security/authorization/policies#applying-policies-to-mvc-controllers)</span><span class="sxs-lookup"><span data-stu-id="f6d02-785">[Applying policies using the [Authorize] attribute](xref:security/authorization/policies#applying-policies-to-mvc-controllers)</span></span>
* <xref:security/authorization/roles>

<a name="hostmatch"></a>

## <a name="host-matching-in-routes-with-requirehost"></a><span data-ttu-id="f6d02-786">RequireHost가 있는 경로의 호스트 일치</span><span class="sxs-lookup"><span data-stu-id="f6d02-786">Host matching in routes with RequireHost</span></span>

<span data-ttu-id="f6d02-787"><xref:Microsoft.AspNetCore.Builder.RoutingEndpointConventionBuilderExtensions.RequireHost*>는 지정된 호스트가 필요한 경로에 제약 조건을 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-787"><xref:Microsoft.AspNetCore.Builder.RoutingEndpointConventionBuilderExtensions.RequireHost*> applies a constraint to the route which requires the specified host.</span></span> <span data-ttu-id="f6d02-788">`RequireHost` 또는 [[Host]](xref:Microsoft.AspNetCore.Routing.HostAttribute) 매개 변수는 다음과 같을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-788">The `RequireHost` or [[Host]](xref:Microsoft.AspNetCore.Routing.HostAttribute) parameter can be:</span></span>

* <span data-ttu-id="f6d02-789">호스트: `www.domain.com`(아무 포트에서나 `www.domain.com`과 일치)</span><span class="sxs-lookup"><span data-stu-id="f6d02-789">Host: `www.domain.com`, matches `www.domain.com` with any port.</span></span>
* <span data-ttu-id="f6d02-790">와일드카드가 있는 호스트: `*.domain.com`(아무 포트에서나 `www.domain.com`, `subdomain.domain.com` 또는 `www.subdomain.domain.com`과 일치)</span><span class="sxs-lookup"><span data-stu-id="f6d02-790">Host with wildcard: `*.domain.com`, matches `www.domain.com`, `subdomain.domain.com`, or `www.subdomain.domain.com` on any port.</span></span>
* <span data-ttu-id="f6d02-791">포트: `*:5000`(아무 호스트에서나 포트 5000과 일치)</span><span class="sxs-lookup"><span data-stu-id="f6d02-791">Port: `*:5000`, matches port 5000 with any host.</span></span>
* <span data-ttu-id="f6d02-792">호스트 및 포트: `www.domain.com:5000` 또는 `*.domain.com:5000`(호스트 및 포트와 일치)</span><span class="sxs-lookup"><span data-stu-id="f6d02-792">Host and port: `www.domain.com:5000` or `*.domain.com:5000`, matches host and port.</span></span>

<span data-ttu-id="f6d02-793">`RequireHost` 또는 `[Host]`를 사용하여 여러 매개 변수를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-793">Multiple parameters can be specified using `RequireHost` or `[Host]`.</span></span> <span data-ttu-id="f6d02-794">제약 조건은 모든 매개 변수에 유효한 호스트와 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-794">The constraint  matches hosts valid for any of the parameters.</span></span> <span data-ttu-id="f6d02-795">예를 들어 `[Host("domain.com", "*.domain.com")]`은 `domain.com`, `www.domain.com` 및 `subdomain.domain.com`과 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-795">For example, `[Host("domain.com", "*.domain.com")]` matches `domain.com`, `www.domain.com`, and `subdomain.domain.com`.</span></span>

<span data-ttu-id="f6d02-796">다음 코드는 `RequireHost`를 사용하여 경로상에 있는 지정된 호스트를 요구합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-796">The following code uses `RequireHost` to require the specified host on the route:</span></span>

[!code-csharp[](routing/samples/3.x/RoutingSample/StartupRequireHost.cs?name=snippet)]

<span data-ttu-id="f6d02-797">다음 코드는 컨트롤러의 `[Host]` 특성을 사용하여 지정된 호스트를 요구합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-797">The following code uses the `[Host]` attribute on the controller to require any of the specified hosts:</span></span>

[!code-csharp[](routing/samples/3.x/RoutingSample/Controllers/ProductController.cs?name=snippet)]

<span data-ttu-id="f6d02-798">`[Host]` 특성이 컨트롤러 메서드와 작업 메서드에 모두 적용될 경우</span><span class="sxs-lookup"><span data-stu-id="f6d02-798">When the `[Host]` attribute is applied to both the controller and action method:</span></span>

* <span data-ttu-id="f6d02-799">작업의 특성이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-799">The attribute on the action is used.</span></span>
* <span data-ttu-id="f6d02-800">컨트롤러의 특성은 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-800">The controller attribute is ignored.</span></span>

## <a name="performance-guidance-for-routing"></a><span data-ttu-id="f6d02-801">라우팅의 성능 지침</span><span class="sxs-lookup"><span data-stu-id="f6d02-801">Performance guidance for routing</span></span>

<span data-ttu-id="f6d02-802">ASP.NET Core 3.0에서는 성능 향상을 위해 대부분의 라우팅이 업데이트되었습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-802">Most of routing was updated in ASP.NET Core 3.0 to increase performance.</span></span>

<span data-ttu-id="f6d02-803">앱에 성능 문제가 있는 경우 라우팅이 문제의 원인으로 의심받는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-803">When an app has performance problems, routing is often suspected as the problem.</span></span> <span data-ttu-id="f6d02-804">라우팅이 의심받는 이유는 컨트롤러 및 Razor Pages 같은 프레임워크가 프레임워크 내에서 소요된 시간을 로깅 메시지로 보고하기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-804">The reason routing is suspected is that frameworks like controllers and Razor Pages report the amount of time spent inside the framework in their logging messages.</span></span> <span data-ttu-id="f6d02-805">컨트롤러에서 보고하는 시간과 요청의 총 시간 사이에 상당한 차이가 있는 경우:</span><span class="sxs-lookup"><span data-stu-id="f6d02-805">When there's a significant difference between the time reported by controllers and the total time of the request:</span></span>

* <span data-ttu-id="f6d02-806">개발자는 문제의 원인인 앱 코드를 제거합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-806">Developers eliminate their app code as the source of the problem.</span></span>
* <span data-ttu-id="f6d02-807">일반적으로 라우팅이 원인이라고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-807">It's common to assume routing is the cause.</span></span>

<span data-ttu-id="f6d02-808">라우팅은 수천 개의 엔드포인트를 사용하여 성능을 테스트했습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-808">Routing is performance tested using thousands of endpoints.</span></span> <span data-ttu-id="f6d02-809">일반적인 앱에서는 너무 크다고 성능 문제가 발생할 가능성은 거의 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-809">It's unlikely that a typical app will encounter a performance problem just by being too large.</span></span> <span data-ttu-id="f6d02-810">라우팅 성능이 저하되는 가장 일반적인 근본 원인은 일반적으로 잘못 동작하는 사용자 지정 미들웨어입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-810">The most common root cause of slow routing performance is usually a badly-behaving custom middleware.</span></span>

<span data-ttu-id="f6d02-811">다음 코드 샘플에서는 지연의 원인을 좁히기 위한 기본 기술을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-811">This following code sample demonstrates a basic technique for narrowing down the source of delay:</span></span>

[!code-csharp[](routing/samples/3.x/RoutingSample/StartupDelay.cs?name=snippet)]

<span data-ttu-id="f6d02-812">종료 시간 라우팅:</span><span class="sxs-lookup"><span data-stu-id="f6d02-812">To time routing:</span></span>

* <span data-ttu-id="f6d02-813">앞의 코드에 표시된 타이밍 미들웨어의 복사본을 각 미들웨어에 인터리빙합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-813">Interleave each middleware with a copy of the timing middleware shown in the preceding code.</span></span>
* <span data-ttu-id="f6d02-814">고유 식별자를 추가하여 타이밍 데이터를 코드와 연관 짓습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-814">Add a unique identifier to correlate the timing data with the code.</span></span>

<span data-ttu-id="f6d02-815">이것이 예를 들어 `10ms` 이상의 상당한 지연이 발생하는 경우 지연을 좁히는 기본적인 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-815">This is a basic way to narrow down the delay when it's significant, for example, more than `10ms`.</span></span>  <span data-ttu-id="f6d02-816">`Time 1`에서 `Time 2`를 빼면 `UseRouting` 미들웨어 내에서 소요된 시간이 보고됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-816">Subtracting `Time 2` from `Time 1` reports the time spent inside the `UseRouting` middleware.</span></span>

<span data-ttu-id="f6d02-817">다음 코드에서는 앞의 타이밍 코드에 더욱 간결한 방법을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-817">The following code uses a more compact approach to the preceding timing code:</span></span>

[!code-csharp[](routing/samples/3.x/RoutingSample/StartupSW.cs?name=snippetSW)]

[!code-csharp[](routing/samples/3.x/RoutingSample/StartupSW.cs?name=snippet)]

### <a name="potentially-expensive-routing-features"></a><span data-ttu-id="f6d02-818">비용이 많이 들 수 있는 라우팅 기능</span><span class="sxs-lookup"><span data-stu-id="f6d02-818">Potentially expensive routing features</span></span>

<span data-ttu-id="f6d02-819">다음 목록에서는 기본 경로 템플릿보다 비교적 비용이 많이 드는 라우팅 기능에 대한 몇 가지 유용한 정보를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-819">The following list provides some insight into routing features that are relatively expensive compared with basic route templates:</span></span>

* <span data-ttu-id="f6d02-820">정규식: 정규식 작성은 복잡하거나 적은 양의 입력으로 실행 시간이 오래 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-820">Regular expressions: It's possible to write regular expressions that are complex, or have long running time with a small amount of input.</span></span>

* <span data-ttu-id="f6d02-821">복잡한 세그먼트(`{x}-{y}-{z}`):</span><span class="sxs-lookup"><span data-stu-id="f6d02-821">Complex segments (`{x}-{y}-{z}`):</span></span> 
  * <span data-ttu-id="f6d02-822">일반 URL 경로 세그먼트를 구문 분석하는 것보다 훨씬 비용이 많이 듭니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-822">Are significantly more expensive than parsing a regular URL path segment.</span></span>
  * <span data-ttu-id="f6d02-823">더 많은 부분 문자열이 할당됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-823">Result in many more substrings being allocated.</span></span>
  * <span data-ttu-id="f6d02-824">복잡한 세그먼트 논리는 ASP.NET Core 3.0 라우팅 성능 업데이트에서 업데이트되지 않았습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-824">The complex segment logic was not updated in ASP.NET Core 3.0 routing performance update.</span></span>

* <span data-ttu-id="f6d02-825">동기 데이터 액세스: 많은 복잡한 앱에서 라우팅의 일부로 데이터베이스에 액세스합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-825">Synchronous data access: Many complex apps have database access as part of their routing.</span></span> <span data-ttu-id="f6d02-826">ASP.NET Core 2.2 및 이전 라우팅에서는 데이터베이스 액세스 라우팅을 지원하기 위한 적합한 확장 포인트를 제공할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-826">ASP.NET Core 2.2 and earlier routing might not provide the right extensibility points to support database access routing.</span></span> <span data-ttu-id="f6d02-827">예를 들어 <xref:Microsoft.AspNetCore.Routing.IRouteConstraint> 및 <xref:Microsoft.AspNetCore.Mvc.ActionConstraints.IActionConstraint>는 동기식입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-827">For example, <xref:Microsoft.AspNetCore.Routing.IRouteConstraint>, and <xref:Microsoft.AspNetCore.Mvc.ActionConstraints.IActionConstraint> are synchronous.</span></span> <span data-ttu-id="f6d02-828"><xref:Microsoft.AspNetCore.Routing.MatcherPolicy> 및 <xref:Microsoft.AspNetCore.Routing.EndpointSelectorContext> 같은 확장 포인트는 비동기식입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-828">Extensibility points such as <xref:Microsoft.AspNetCore.Routing.MatcherPolicy> and <xref:Microsoft.AspNetCore.Routing.EndpointSelectorContext> are asynchronous.</span></span>

## <a name="guidance-for-library-authors"></a><span data-ttu-id="f6d02-829">라이브러리 작성자를 위한 지침</span><span class="sxs-lookup"><span data-stu-id="f6d02-829">Guidance for library authors</span></span>

<span data-ttu-id="f6d02-830">이 단원에는 라우팅을 기반으로 빌드하는 라이브러리 작성자를 위한 지침이 포함되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-830">This section contains guidance for library authors building on top of routing.</span></span> <span data-ttu-id="f6d02-831">이러한 세부 내용은 앱 개발자가 라우팅을 확장하는 라이브러리 및 프레임워크를 사용하는 좋은 환경을 갖추도록 하기 위한 것입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-831">These details are intended to ensure that app developers have a good experience using libraries and frameworks that extend routing.</span></span>

### <a name="define-endpoints"></a><span data-ttu-id="f6d02-832">엔드포인트 정의</span><span class="sxs-lookup"><span data-stu-id="f6d02-832">Define endpoints</span></span>

<span data-ttu-id="f6d02-833">URL 일치를 위해 라우팅을 사용하는 프레임워크를 만들려면 먼저 <xref:Microsoft.AspNetCore.Builder.EndpointRoutingApplicationBuilderExtensions.UseEndpoints*>를 기반으로 빌드되는 사용자 환경을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-833">To create a framework that uses routing for URL matching, start by defining a user experience that builds on top of <xref:Microsoft.AspNetCore.Builder.EndpointRoutingApplicationBuilderExtensions.UseEndpoints*>.</span></span>

<span data-ttu-id="f6d02-834"><xref:Microsoft.AspNetCore.Routing.IEndpointRouteBuilder>를 기반으로 **빌드하세요**.</span><span class="sxs-lookup"><span data-stu-id="f6d02-834">**DO** build on top of <xref:Microsoft.AspNetCore.Routing.IEndpointRouteBuilder>.</span></span> <span data-ttu-id="f6d02-835">이렇게 하면 사용자는 혼동하지 않고 다른 ASP.NET Core 기능을 사용하여 프레임워크를 작성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-835">This allows users to compose your framework with other ASP.NET Core features without confusion.</span></span> <span data-ttu-id="f6d02-836">모든 ASP.NET Core 템플릿에는 라우팅이 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-836">Every ASP.NET Core template includes routing.</span></span> <span data-ttu-id="f6d02-837">라우팅이 있고 사용자에게 친숙하다고 간주합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-837">Assume routing is present and familiar for users.</span></span>

```csharp
app.UseEndpoints(endpoints =>
{
    // Your framework
    endpoints.MapMyFramework(...);

    endpoints.MapHealthChecks("/healthz");
});
```

<span data-ttu-id="f6d02-838"><xref:Microsoft.AspNetCore.Builder.IEndpointConventionBuilder>를 구현하는 `MapMyFramework(...)` 호출에서 봉인된 구체적인 형식을 반환**하세요**.</span><span class="sxs-lookup"><span data-stu-id="f6d02-838">**DO** return a sealed concrete type from a call to `MapMyFramework(...)` that implements <xref:Microsoft.AspNetCore.Builder.IEndpointConventionBuilder>.</span></span> <span data-ttu-id="f6d02-839">대부분의 프레임워크 `Map...` 메서드는 이 패턴을 따릅니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-839">Most framework `Map...` methods follow this pattern.</span></span> <span data-ttu-id="f6d02-840">`IEndpointConventionBuilder` 인터페이스:</span><span class="sxs-lookup"><span data-stu-id="f6d02-840">The `IEndpointConventionBuilder` interface:</span></span>

* <span data-ttu-id="f6d02-841">메타데이터를 작성 가능하게 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-841">Allows composability of metadata.</span></span>
* <span data-ttu-id="f6d02-842">다양한 확장 메서드의 대상으로 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-842">Is targeted by a variety of extension methods.</span></span>

<span data-ttu-id="f6d02-843">고유의 형식을 선언하면 작성기에 사용자 고유의 프레임워크 관련 기능을 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-843">Declaring your own type allows you to add your own framework-specific functionality to the builder.</span></span> <span data-ttu-id="f6d02-844">프레임워크 선언된 작성기를 래핑하고 여기에 호출을 전달해도 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-844">It's ok to wrap a framework-declared builder and forward calls to it.</span></span>

```csharp
app.UseEndpoints(endpoints =>
{
    // Your framework
    endpoints.MapMyFramework(...).RequrireAuthorization()
                                 .WithMyFrameworkFeature(awesome: true);

    endpoints.MapHealthChecks("/healthz");
});
```

<span data-ttu-id="f6d02-845">사용자 고유의 <xref:Microsoft.AspNetCore.Routing.EndpointDataSource>를 작성하는 것이 **좋습니다**.</span><span class="sxs-lookup"><span data-stu-id="f6d02-845">**CONSIDER** writing your own <xref:Microsoft.AspNetCore.Routing.EndpointDataSource>.</span></span> <span data-ttu-id="f6d02-846">`EndpointDataSource`는 엔드포인트 컬렉션을 선언하고 업데이트하기 위한 하위 수준 기본 형식입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-846">`EndpointDataSource` is the low-level primitive for declaring and updating a collection of endpoints.</span></span> <span data-ttu-id="f6d02-847">`EndpointDataSource`는 컨트롤러 및 Razor Pages에서 사용되는 강력한 API입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-847">`EndpointDataSource` is a powerful API used by controllers and Razor Pages.</span></span>

<span data-ttu-id="f6d02-848">라우팅 테스트에는 업데이트되지 않는 데이터 원본의 [기본 예제](https://github.com/aspnet/AspNetCore/blob/master/src/Http/Routing/test/testassets/RoutingSandbox/Framework/FrameworkEndpointDataSource.cs#L17)가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-848">The routing tests have a [basic example](https://github.com/aspnet/AspNetCore/blob/master/src/Http/Routing/test/testassets/RoutingSandbox/Framework/FrameworkEndpointDataSource.cs#L17) of a non-updating data source.</span></span>

<span data-ttu-id="f6d02-849">기본적으로 `EndpointDataSource`를 등록하지 **마세요**.</span><span class="sxs-lookup"><span data-stu-id="f6d02-849">**DO NOT** attempt to register an `EndpointDataSource` by default.</span></span> <span data-ttu-id="f6d02-850">프레임워크를 <xref:Microsoft.AspNetCore.Builder.EndpointRoutingApplicationBuilderExtensions.UseEndpoints*>에 등록하도록 사용자에게 요구하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-850">Require users to register your framework in <xref:Microsoft.AspNetCore.Builder.EndpointRoutingApplicationBuilderExtensions.UseEndpoints*>.</span></span> <span data-ttu-id="f6d02-851">라우팅의 원리에 따르면 기본적으로 아무것도 포함되지 않으며 `UseEndpoints`가 엔드포인트를 등록하는 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-851">The philosophy of routing is that nothing is included by default, and that `UseEndpoints` is the place to register endpoints.</span></span>

### <a name="creating-routing-integrated-middleware"></a><span data-ttu-id="f6d02-852">라우팅 통합 미들웨어 만들기</span><span class="sxs-lookup"><span data-stu-id="f6d02-852">Creating routing-integrated middleware</span></span>

<span data-ttu-id="f6d02-853">메타데이터 형식을 인터페이스로 정의하는 것이 **좋습니다**.</span><span class="sxs-lookup"><span data-stu-id="f6d02-853">**CONSIDER** defining metadata types as an interface.</span></span>

<span data-ttu-id="f6d02-854">메타데이터 형식을 클래스 및 메서드의 특성으로 사용할 수 있게 **하세요**.</span><span class="sxs-lookup"><span data-stu-id="f6d02-854">**DO** make it possible to use metadata types as an attribute on classes and methods.</span></span>

[!code-csharp[](routing/samples/3.x/RoutingSample/ICoolMetadata.cs?name=snippet2)]

<span data-ttu-id="f6d02-855">컨트롤러 및 Razor Pages와 같은 프레임워크는 형식 및 메서드에 메타데이터 특성을 적용하도록 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-855">Frameworks like controllers and Razor Pages support applying metadata attributes to types and methods.</span></span> <span data-ttu-id="f6d02-856">메타데이터 형식을 선언하는 경우:</span><span class="sxs-lookup"><span data-stu-id="f6d02-856">If you declare metadata types:</span></span>

* <span data-ttu-id="f6d02-857">이 형식에 [특성](/dotnet/csharp/programming-guide/concepts/attributes/)으로 액세스할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-857">Make them accessible as [attributes](/dotnet/csharp/programming-guide/concepts/attributes/).</span></span>
* <span data-ttu-id="f6d02-858">사용자 대부분이 특성을 적용하는 데 익숙합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-858">Most users are familiar with applying attributes.</span></span>

<span data-ttu-id="f6d02-859">메타데이터 형식을 인터페이스로 선언하면 또 하나의 유연성 계층이 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-859">Declaring a metadata type as an interface adds another layer of flexibility:</span></span>

* <span data-ttu-id="f6d02-860">인터페이스는 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-860">Interfaces are composable.</span></span>
* <span data-ttu-id="f6d02-861">개발자가 여러 정책을 결합하여 고유한 형식을 선언할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-861">Developers can declare their own types that combine multiple policies.</span></span>

<span data-ttu-id="f6d02-862">다음 예제와 같이 메타데이터를 재정의할 수 있게 **하세요**.</span><span class="sxs-lookup"><span data-stu-id="f6d02-862">**DO** make it possible to override metadata, as shown in the following example:</span></span>

[!code-csharp[](routing/samples/3.x/RoutingSample/ICoolMetadata.cs?name=snippet)]

<span data-ttu-id="f6d02-863">이러한 지침을 따르는 가장 좋은 방법은 **마커 메타데이터**를 정의하지 않는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-863">The best way to follow these guidelines is to avoid defining **marker metadata**:</span></span>

* <span data-ttu-id="f6d02-864">메타데이터 형식이 있는지만 확인하면 안 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-864">Don't just look for the presence of a metadata type.</span></span>
* <span data-ttu-id="f6d02-865">메타데이터의 속성을 정의하고 속성을 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-865">Define a property on the metadata and check the property.</span></span>

<span data-ttu-id="f6d02-866">메타데이터 컬렉션은 순서 지정되며 우선 순위별로 재정의할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-866">The metadata collection is ordered and supports overriding by priority.</span></span> <span data-ttu-id="f6d02-867">컨트롤러의 경우 작업 메서드의 메타데이터가 가장 구체적입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-867">In the case of controllers, metadata on the action method is most specific.</span></span>

<span data-ttu-id="f6d02-868">라우팅이 있는지와 관계없이 미들웨어를 유용하게 사용할 수 있게 **하세요**.</span><span class="sxs-lookup"><span data-stu-id="f6d02-868">**DO** make middleware useful with and without routing.</span></span>

```csharp
app.UseRouting();

app.UseAuthorization(new AuthorizationPolicy() { ... });

app.UseEndpoints(endpoints =>
{
    // Your framework
    endpoints.MapMyFramework(...).RequrireAuthorization();
});
```

<span data-ttu-id="f6d02-869">이 지침의 예제에서는 `UseAuthorization` 미들웨어를 고려해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-869">As an example of this guideline, consider the `UseAuthorization` middleware.</span></span> <span data-ttu-id="f6d02-870">권한 부여 미들웨어를 사용하면 대체 정책을 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-870">The authorization middleware allows you to pass in a fallback policy.</span></span> <!-- shown where?  (shown here) --> <span data-ttu-id="f6d02-871">대체 정책(지정된 경우)은 다음 모두에 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-871">The fallback policy, if specified, applies to both:</span></span>

* <span data-ttu-id="f6d02-872">지정된 정책이 없는 엔드포인트</span><span class="sxs-lookup"><span data-stu-id="f6d02-872">Endpoints without a specified policy.</span></span>
* <span data-ttu-id="f6d02-873">엔드포인트와 일치하지 않는 요청</span><span class="sxs-lookup"><span data-stu-id="f6d02-873">Requests that don't match an endpoint.</span></span>

<span data-ttu-id="f6d02-874">따라서 권한 부여 미들웨어는 라우팅 컨텍스트 외에서도 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-874">This makes the authorization middleware useful outside of the context of routing.</span></span> <span data-ttu-id="f6d02-875">권한 부여 미들웨어는 기존 미들웨어 프로그래밍에 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-875">The authorization middleware can be used for traditional middleware programming.</span></span>

[!INCLUDE[](~/includes/dbg-route.md)]

::: moniker-end

::: moniker range="= aspnetcore-2.2"

<span data-ttu-id="f6d02-876">라우팅은 요청 URI를 엔드포인트에 매핑하고 들어오는 요청을 이러한 엔드포인트로 디스패치합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-876">Routing is responsible for mapping request URIs to endpoints and dispatching incoming requests to those endpoints.</span></span> <span data-ttu-id="f6d02-877">경로는 앱에서 정의되고 앱 시작 시 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-877">Routes are defined in the app and configured when the app starts.</span></span> <span data-ttu-id="f6d02-878">경로는 요청에 포함된 URL에서 필요에 따라 값을 추출할 수 있으며 이러한 값은 요청 처리를 위해 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-878">A route can optionally extract values from the URL contained in the request, and these values can then be used for request processing.</span></span> <span data-ttu-id="f6d02-879">또한 라우팅은 앱의 경로 정보를 사용하여 엔드포인트에 매핑되는 URL을 생성할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-879">Using route information from the app, routing is also able to generate URLs that map to endpoints.</span></span>

<span data-ttu-id="f6d02-880">ASP.NET Core 2.2에서 최신 라우팅 시나리오를 사용하려면 `Startup.ConfigureServices`의 MVC 서비스 등록에 [호환성 버전](xref:mvc/compatibility-version)을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-880">To use the latest routing scenarios in ASP.NET Core 2.2, specify the [compatibility version](xref:mvc/compatibility-version) to the MVC services registration in `Startup.ConfigureServices`:</span></span>

```csharp
services.AddMvc()
    .SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
```

<span data-ttu-id="f6d02-881"><xref:Microsoft.AspNetCore.Mvc.MvcOptions.EnableEndpointRouting> 옵션은 라우팅에서 내부적으로 엔드포인트 기반 논리를 사용해야 하는지, 또는 ASP.NET Core 2.1 이하의 <xref:Microsoft.AspNetCore.Routing.IRouter> 기반 논리를 사용해야 하는지 여부를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-881">The <xref:Microsoft.AspNetCore.Mvc.MvcOptions.EnableEndpointRouting> option determines if routing should internally use endpoint-based logic or the <xref:Microsoft.AspNetCore.Routing.IRouter>-based logic of ASP.NET Core 2.1 or earlier.</span></span> <span data-ttu-id="f6d02-882">호환성 버전이 2.2 이상으로 설정된 경우 기본값은 `true`입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-882">When the compatibility version is set to 2.2 or later, the default value is `true`.</span></span> <span data-ttu-id="f6d02-883">이전 라우팅 논리를 사용하려면 값을 `false`로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-883">Set the value to `false` to use the prior routing logic:</span></span>

```csharp
// Use the routing logic of ASP.NET Core 2.1 or earlier:
services.AddMvc(options => options.EnableEndpointRouting = false)
    .SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
```

<span data-ttu-id="f6d02-884"><xref:Microsoft.AspNetCore.Routing.IRouter> 기반 라우팅에 대한 자세한 내용은 [이 항목의 ASP.NET Core 2.1 버전](/aspnet/core/fundamentals/routing?view=aspnetcore-2.1)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-884">For more information on <xref:Microsoft.AspNetCore.Routing.IRouter>-based routing, see the [ASP.NET Core 2.1 version of this topic](/aspnet/core/fundamentals/routing?view=aspnetcore-2.1).</span></span>

> [!IMPORTANT]
> <span data-ttu-id="f6d02-885">이 문서에서는 낮은 수준의 ASP.NET Core 라우팅을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-885">This document covers low-level ASP.NET Core routing.</span></span> <span data-ttu-id="f6d02-886">ASP.NET Core MVC 라우팅에 대한 내용은 <xref:mvc/controllers/routing>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-886">For information on ASP.NET Core MVC routing, see <xref:mvc/controllers/routing>.</span></span> <span data-ttu-id="f6d02-887">Razor Pages의 라우팅 규칙에 대한 내용은 <xref:razor-pages/razor-pages-conventions>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-887">For information on routing conventions in Razor Pages, see <xref:razor-pages/razor-pages-conventions>.</span></span>

<span data-ttu-id="f6d02-888">[예제 코드 살펴보기 및 다운로드](https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/routing/samples) ([다운로드 방법](xref:index#how-to-download-a-sample))</span><span class="sxs-lookup"><span data-stu-id="f6d02-888">[View or download sample code](https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/routing/samples) ([how to download](xref:index#how-to-download-a-sample))</span></span>

## <a name="routing-basics"></a><span data-ttu-id="f6d02-889">라우팅 기본 사항</span><span class="sxs-lookup"><span data-stu-id="f6d02-889">Routing basics</span></span>

<span data-ttu-id="f6d02-890">대부분의 앱은 URL을 읽을 수 있고 의미를 담고 있도록 기본적이고 서술적인 라우팅 체계를 선택해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-890">Most apps should choose a basic and descriptive routing scheme so that URLs are readable and meaningful.</span></span> <span data-ttu-id="f6d02-891">기본 기존 경로인 `{controller=Home}/{action=Index}/{id?}`는:</span><span class="sxs-lookup"><span data-stu-id="f6d02-891">The default conventional route `{controller=Home}/{action=Index}/{id?}`:</span></span>

* <span data-ttu-id="f6d02-892">기본적이고 서술적인 라우팅 체계를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-892">Supports a basic and descriptive routing scheme.</span></span>
* <span data-ttu-id="f6d02-893">UI 기반 앱에 대한 유용한 시작점입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-893">Is a useful starting point for UI-based apps.</span></span>

<span data-ttu-id="f6d02-894">일반적으로 개발자는 [특성 라우팅](xref:mvc/controllers/routing#attribute-routing) 또는 전용 기존 경로를 사용하여 특수한 상황에서 앱의 트래픽이 높은 영역에 간결한 추가 경로를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-894">Developers commonly add additional terse routes to high-traffic areas of an app in specialized situations using [attribute routing](xref:mvc/controllers/routing#attribute-routing) or dedicated conventional routes.</span></span> <span data-ttu-id="f6d02-895">특수한 상황 예제로는 블로그 및 전자 상거래 엔드포인트가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-895">Specialized situations examples include, blog and ecommerce endpoints.</span></span>

<span data-ttu-id="f6d02-896">Web API는 특성 라우팅을 사용하여 작업이 HTTP 동사로 표현되는 리소스 집합으로 앱의 기능을 모델링해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-896">Web APIs should use attribute routing to model the app's functionality as a set of resources where operations are represented by HTTP verbs.</span></span> <span data-ttu-id="f6d02-897">이는 동일한 논리 리소스의 많은 작업(예: GET, POST)이 동일한 URL을 사용한다는 뜻입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-897">This means that many operations, for example, GET, and POST, on the same logical resource use the same URL.</span></span> <span data-ttu-id="f6d02-898">특성 라우팅은 API의 공개 엔드포인트 레이아웃을 신중하게 설계하는 데 필요한 제어 수준을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-898">Attribute routing provides a level of control that's needed to carefully design an API's public endpoint layout.</span></span>

<span data-ttu-id="f6d02-899">Razor Pages 앱은 기본 기존 라우팅을 사용하여 앱의 *Pages* 폴더에서 명명된 리소스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-899">Razor Pages apps use default conventional routing to serve named resources in the *Pages* folder of an app.</span></span> <span data-ttu-id="f6d02-900">Razor Pages 라우팅 동작을 사용자 지정할 수 있는 추가 규칙을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-900">Additional conventions are available that allow you to customize Razor Pages routing behavior.</span></span> <span data-ttu-id="f6d02-901">자세한 내용은 <xref:razor-pages/index> 및 <xref:razor-pages/razor-pages-conventions>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-901">For more information, see <xref:razor-pages/index> and <xref:razor-pages/razor-pages-conventions>.</span></span>

<span data-ttu-id="f6d02-902">URL 생성 지원을 사용하면 URL을 하드 코딩하지 않고 앱을 개발하여 앱을 서로 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-902">URL generation support allows the app to be developed without hard-coding URLs to link the app together.</span></span> <span data-ttu-id="f6d02-903">이 지원을 사용하면 기본 라우팅 구성으로 시작하고 앱의 리소스 레이아웃이 결정된 후에 해당 경로를 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-903">This support allows for starting with a basic routing configuration and modifying the routes after the app's resource layout is determined.</span></span>

<span data-ttu-id="f6d02-904">라우팅은 *엔드포인트*(`Endpoint`)를 사용하여 앱에서 논리적 엔드포인트를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-904">Routing uses *endpoints* (`Endpoint`) to represent logical endpoints in an app.</span></span>

<span data-ttu-id="f6d02-905">엔드포인트는 요청을 처리할 대리자와 임의의 메타데이터 컬렉션을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-905">An endpoint defines a delegate to process requests and a collection of arbitrary metadata.</span></span> <span data-ttu-id="f6d02-906">메타데이터는 각 엔드포인트에 연결된 정책과 구성에 따라 횡단 관심사(Cross-Cutting Concerns)를 구현하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-906">The metadata is used implement cross-cutting concerns based on policies and configuration attached to each endpoint.</span></span>

<span data-ttu-id="f6d02-907">라우팅 시스템에는 다음과 같은 특징이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-907">The routing system has the following characteristics:</span></span>

* <span data-ttu-id="f6d02-908">경로 템플릿 구문은 토큰화된 경로 매개 변수를 사용하여 경로를 정의하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-908">Route template syntax is used to define routes with tokenized route parameters.</span></span>
* <span data-ttu-id="f6d02-909">기본 방식 스타일 및 특성 스타일 엔드포인트 구성이 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-909">Conventional-style and attribute-style endpoint configuration is permitted.</span></span>
* <span data-ttu-id="f6d02-910"><xref:Microsoft.AspNetCore.Routing.IRouteConstraint>는 URL 매개 변수가 지정한 엔드포인트 제약 조건에 대해 유효한 값을 포함하고 있는지 알아내는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-910"><xref:Microsoft.AspNetCore.Routing.IRouteConstraint> is used to determine whether a URL parameter contains a valid value for a given endpoint constraint.</span></span>
* <span data-ttu-id="f6d02-911">MVC/Razor Pages와 같은 앱 모델은 라우팅 시나리오의 예측 가능한 구현을 가진 모든 엔드포인트를 등록합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-911">App models, such as MVC/Razor Pages, register all of their endpoints, which have a predictable implementation of routing scenarios.</span></span>
* <span data-ttu-id="f6d02-912">라우팅 구현은 미들웨어 파이프라인에서 필요한 곳이라면 어디서든지 라우팅 결정을 내립니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-912">The routing implementation makes routing decisions wherever desired in the middleware pipeline.</span></span>
* <span data-ttu-id="f6d02-913">라우팅 미들웨어 이후에 나타나는 미들웨어는 지정된 요청 URI에 대한 라우팅 미들웨어의 엔드포인트 결정 결과를 검사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-913">Middleware that appears after a Routing Middleware can inspect the result of the Routing Middleware's endpoint decision for a given request URI.</span></span>
* <span data-ttu-id="f6d02-914">미들웨어 파이프라인의 어느 곳에서든 앱의 모든 엔드포인트를 열거할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-914">It's possible to enumerate all of the endpoints in the app anywhere in the middleware pipeline.</span></span>
* <span data-ttu-id="f6d02-915">앱은 라우팅을 사용하여 엔드포인트 정보에 따라 URL을 생성(예: 리디렉션 또는 링크)하므로 하드 코딩된 URL을 방지하여 유지 관리에 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-915">An app can use routing to generate URLs (for example, for redirection or links) based on endpoint information and thus avoid hard-coded URLs, which helps maintainability.</span></span>
* <span data-ttu-id="f6d02-916">URL 생성은 임의의 확장성을 지원하는 주소를 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-916">URL generation is based on addresses, which support arbitrary extensibility:</span></span>

  * <span data-ttu-id="f6d02-917">링크 생성기 API(<xref:Microsoft.AspNetCore.Routing.LinkGenerator>)는 [DI(종속성 주입)](xref:fundamentals/dependency-injection)를 사용하여 URL을 생성하기 위해 어디서나 확인할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-917">The Link Generator API (<xref:Microsoft.AspNetCore.Routing.LinkGenerator>) can be resolved anywhere using [dependency injection (DI)](xref:fundamentals/dependency-injection) to generate URLs.</span></span>
  * <span data-ttu-id="f6d02-918">DI를 통해 링크 생성기 API를 사용할 수 없는 경우 <xref:Microsoft.AspNetCore.Mvc.IUrlHelper>에서 URL을 작성하는 메서드를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-918">Where the Link Generator API isn't available via DI, <xref:Microsoft.AspNetCore.Mvc.IUrlHelper> offers methods to build URLs.</span></span>

> [!NOTE]
> <span data-ttu-id="f6d02-919">ASP.NET Core 2.2의 엔드포인트 라우팅이 릴리스되면서 엔드포인트 연결이 MVC/Razor Pages 작업 및 페이지로 제한되었습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-919">With the release of endpoint routing in ASP.NET Core 2.2, endpoint linking is limited to MVC/Razor Pages actions and pages.</span></span> <span data-ttu-id="f6d02-920">이후 릴리스에서는 엔드포인트 연결 기능이 확장될 예정입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-920">The expansions of endpoint-linking capabilities is planned for future releases.</span></span>

<span data-ttu-id="f6d02-921">라우팅은 <xref:Microsoft.AspNetCore.Builder.RouterMiddleware> 클래스에 의해 [미들웨어](xref:fundamentals/middleware/index) 파이프라인에 연결되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-921">Routing is connected to the [middleware](xref:fundamentals/middleware/index) pipeline by the <xref:Microsoft.AspNetCore.Builder.RouterMiddleware> class.</span></span> <span data-ttu-id="f6d02-922">[ASP.NET Core MVC](xref:mvc/overview)는 라우팅을 해당 구성의 일부로 미들웨어 파이프라인에 추가하고, MVC 및 Razor Pages 앱에서 라우팅을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-922">[ASP.NET Core MVC](xref:mvc/overview) adds routing to the middleware pipeline as part of its configuration and handles routing in MVC and Razor Pages apps.</span></span> <span data-ttu-id="f6d02-923">라우팅을 독립 실행형 구성 요소로 사용하는 방법을 알아보려면 [라우팅 미들웨어 사용](#use-routing-middleware) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-923">To learn how to use routing as a standalone component, see the [Use Routing Middleware](#use-routing-middleware) section.</span></span>

### <a name="url-matching"></a><span data-ttu-id="f6d02-924">URL 일치</span><span class="sxs-lookup"><span data-stu-id="f6d02-924">URL matching</span></span>

<span data-ttu-id="f6d02-925">URL 일치는 라우팅이 들어오는 요청을 *엔드포인트*로 디스패치하는 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-925">URL matching is the process by which routing dispatches an incoming request to an *endpoint*.</span></span> <span data-ttu-id="f6d02-926">이 프로세스는 URL 경로의 데이터를 기반으로 하지만 요청에 있는 모든 데이터를 고려하도록 확장될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-926">This process is based on data in the URL path but can be extended to consider any data in the request.</span></span> <span data-ttu-id="f6d02-927">요청을 별도의 처리기로 디스패치하는 기능은 앱의 크기와 복잡성을 확장하는 핵심입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-927">The ability to dispatch requests to separate handlers is key to scaling the size and complexity of an app.</span></span>

<span data-ttu-id="f6d02-928">엔드포인트 라우팅의 라우팅 시스템은 모든 디스패치를 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-928">The routing system in endpoint routing is responsible for all dispatching decisions.</span></span> <span data-ttu-id="f6d02-929">미들웨어가 선택된 엔드포인트를 기반으로 정책을 적용하므로 디스패치 또는 애플리케이션의 보안 정책에 영향을 미칠 수 있는 모든 결정은 라우팅 시스템 내에서 이루어져야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-929">Since the middleware applies policies based on the selected endpoint, it's important that any decision that can affect dispatching or the application of security policies is made inside the routing system.</span></span>

<span data-ttu-id="f6d02-930">엔드포인트 대리자가 실행되면 [RouteContext.RouteData](xref:Microsoft.AspNetCore.Routing.RouteContext.RouteData)의 속성이 지금까지 수행된 요청 처리에 따라 적절한 값으로 설정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-930">When the endpoint delegate is executed, the properties of [RouteContext.RouteData](xref:Microsoft.AspNetCore.Routing.RouteContext.RouteData) are set to appropriate values based on the request processing performed thus far.</span></span>

<span data-ttu-id="f6d02-931">[RouteData.Values](xref:Microsoft.AspNetCore.Routing.RouteData.Values*)는 경로에서 생성된 *경로 값*의 사전입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-931">[RouteData.Values](xref:Microsoft.AspNetCore.Routing.RouteData.Values*) is a dictionary of *route values* produced from the route.</span></span> <span data-ttu-id="f6d02-932">이러한 값은 일반적으로 URL을 토큰화하여 결정되고, 사용자 입력을 수락하거나 앱 내부의 추가 디스패치 결정을 내리는 데 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-932">These values are usually determined by tokenizing the URL and can be used to accept user input or to make further dispatching decisions inside the app.</span></span>

<span data-ttu-id="f6d02-933">[RouteData.DataTokens](xref:Microsoft.AspNetCore.Routing.RouteData.DataTokens*)는 일치하는 경로와 관련된 추가 데이터의 속성 모음입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-933">[RouteData.DataTokens](xref:Microsoft.AspNetCore.Routing.RouteData.DataTokens*) is a property bag of additional data related to the matched route.</span></span> <span data-ttu-id="f6d02-934"><xref:Microsoft.AspNetCore.Routing.RouteData.DataTokens*>는 앱에서 일치된 경로에 따라 결정할 수 있도록 각 경로와 상태 데이터의 연결을 지원하기 위해 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-934"><xref:Microsoft.AspNetCore.Routing.RouteData.DataTokens*> are provided to support associating state data with each route so that the app can make decisions based on which route matched.</span></span> <span data-ttu-id="f6d02-935">이러한 값은 개발자 정의되고 어떤 방식으로든 라우팅의 동작에 영향을 주지 **않습니다**.</span><span class="sxs-lookup"><span data-stu-id="f6d02-935">These values are developer-defined and do **not** affect the behavior of routing in any way.</span></span> <span data-ttu-id="f6d02-936">또한 [RouteData.DataTokens](xref:Microsoft.AspNetCore.Routing.RouteData.DataTokens*)에 안전하게 배치되는(stashed) 값은 [RouteData.Values](xref:Microsoft.AspNetCore.Routing.RouteData.Values)와는 달리 문자열 간에 변환될 수 있어야 하는 모든 형식일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-936">Additionally, values stashed in [RouteData.DataTokens](xref:Microsoft.AspNetCore.Routing.RouteData.DataTokens*) can be of any type, in contrast to [RouteData.Values](xref:Microsoft.AspNetCore.Routing.RouteData.Values), which must be convertible to and from strings.</span></span>

<span data-ttu-id="f6d02-937">[RouteData.Routers](xref:Microsoft.AspNetCore.Routing.RouteData.Routers)는 요청을 성공적으로 일치하는 데 참여한 경로의 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-937">[RouteData.Routers](xref:Microsoft.AspNetCore.Routing.RouteData.Routers) is a list of the routes that took part in successfully matching the request.</span></span> <span data-ttu-id="f6d02-938">경로는 서로 중첩될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-938">Routes can be nested inside of one another.</span></span> <span data-ttu-id="f6d02-939"><xref:Microsoft.AspNetCore.Routing.RouteData.Routers> 속성은 일치한 경로의 논리 트리를 통해 경로를 반영합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-939">The <xref:Microsoft.AspNetCore.Routing.RouteData.Routers> property reflects the path through the logical tree of routes that resulted in a match.</span></span> <span data-ttu-id="f6d02-940">일반적으로 <xref:Microsoft.AspNetCore.Routing.RouteData.Routers>의 첫 번째 항목은 경로 컬렉션이며 URL 생성을 위해 사용되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-940">Generally, the first item in <xref:Microsoft.AspNetCore.Routing.RouteData.Routers> is the route collection and should be used for URL generation.</span></span> <span data-ttu-id="f6d02-941"><xref:Microsoft.AspNetCore.Routing.RouteData.Routers>의 마지막 항목은 일치한 경로 처리기입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-941">The last item in <xref:Microsoft.AspNetCore.Routing.RouteData.Routers> is the route handler that matched.</span></span>

<a name="lg"></a>

### <a name="url-generation-with-linkgenerator"></a><span data-ttu-id="f6d02-942">LinkGenerator를 사용한 URL 생성</span><span class="sxs-lookup"><span data-stu-id="f6d02-942">URL generation with LinkGenerator</span></span>

<span data-ttu-id="f6d02-943">URL 생성은 라우팅이 경로 값의 집합을 기반으로 하는 URL 경로를 만들 수 있는 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-943">URL generation is the process by which routing can create a URL path based on a set of route values.</span></span> <span data-ttu-id="f6d02-944">이렇게 하면 엔드포인트와 이에 액세스하는 URL을 논리적으로 분리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-944">This allows for a logical separation between your endpoints and the URLs that access them.</span></span>

<span data-ttu-id="f6d02-945">엔드포인트 라우팅에는 링크 생성기 API(<xref:Microsoft.AspNetCore.Routing.LinkGenerator>)가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-945">Endpoint routing includes the Link Generator API (<xref:Microsoft.AspNetCore.Routing.LinkGenerator>).</span></span> <span data-ttu-id="f6d02-946"><xref:Microsoft.AspNetCore.Routing.LinkGenerator>는 [DI](xref:fundamentals/dependency-injection)에서 가져올 수 있는 싱글톤 서비스입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-946"><xref:Microsoft.AspNetCore.Routing.LinkGenerator> is a singleton service that can be retrieved from [DI](xref:fundamentals/dependency-injection).</span></span> <span data-ttu-id="f6d02-947">API는 실행 중인 요청의 컨텍스트 외부에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-947">The API can be used outside of the context of an executing request.</span></span> <span data-ttu-id="f6d02-948">MVC의 <xref:Microsoft.AspNetCore.Mvc.IUrlHelper> 및 <xref:Microsoft.AspNetCore.Mvc.IUrlHelper>를 사용하는 시나리오(예: [태그 도우미](xref:mvc/views/tag-helpers/intro), HTML 도우미 및 [작업 결과](xref:mvc/controllers/actions))는 링크 생성기를 사용하여 링크 생성 기능을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-948">MVC's <xref:Microsoft.AspNetCore.Mvc.IUrlHelper> and scenarios that rely on <xref:Microsoft.AspNetCore.Mvc.IUrlHelper>, such as [Tag Helpers](xref:mvc/views/tag-helpers/intro), HTML Helpers, and [Action Results](xref:mvc/controllers/actions), use the link generator to provide link generating capabilities.</span></span>

<span data-ttu-id="f6d02-949">링크 생성기는 *주소* 및 *주소 체계*의 개념으로 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-949">The link generator is backed by the concept of an *address* and *address schemes*.</span></span> <span data-ttu-id="f6d02-950">주소 체계는 링크 생성을 위해 고려해야 할 엔드포인트를 결정하는 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-950">An address scheme is a way of determining the endpoints that should be considered for link generation.</span></span> <span data-ttu-id="f6d02-951">예를 들어 많은 사용자가 MVC/Razor Pages에서 친숙한 경로 이름 및 경로 값 시나리오는 주소 체계로 구현됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-951">For example, the route name and route values scenarios many users are familiar with from MVC/Razor Pages are implemented as an address scheme.</span></span>

<span data-ttu-id="f6d02-952">링크 생성기는 다음 확장 메서드를 통해 MVC/Razor Pages 작업 및 페이지에 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-952">The link generator can link to MVC/Razor Pages actions and pages via the following extension methods:</span></span>

* <xref:Microsoft.AspNetCore.Routing.ControllerLinkGeneratorExtensions.GetPathByAction*>
* <xref:Microsoft.AspNetCore.Routing.ControllerLinkGeneratorExtensions.GetUriByAction*>
* <xref:Microsoft.AspNetCore.Routing.PageLinkGeneratorExtensions.GetPathByPage*>
* <xref:Microsoft.AspNetCore.Routing.PageLinkGeneratorExtensions.GetUriByPage*>

<span data-ttu-id="f6d02-953">이러한 메서드의 오버로드에는 `HttpContext`를 포함한 인수가 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-953">An overload of these methods accepts arguments that include the `HttpContext`.</span></span> <span data-ttu-id="f6d02-954">이러한 메서드는 기능적으로 `Url.Action` 및 `Url.Page`와 동일하지만, 추가적인 유연성과 옵션을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-954">These methods are functionally equivalent to `Url.Action` and `Url.Page` but offer additional flexibility and options.</span></span>

<span data-ttu-id="f6d02-955">`GetPath*` 메서드는 절대 경로가 포함된 URI를 생성한다는 점에서 `Url.Action` 및 `Url.Page`와 가장 비슷합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-955">The `GetPath*` methods are most similar to `Url.Action` and `Url.Page` in that they generate a URI containing an absolute path.</span></span> <span data-ttu-id="f6d02-956">`GetUri*` 메서드는 항상 체계와 호스트를 포함한 절대 URI를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-956">The `GetUri*` methods always generate an absolute URI containing a scheme and host.</span></span> <span data-ttu-id="f6d02-957">`HttpContext`를 허용하는 메서드는 실행 중인 요청의 컨텍스트에서 URI를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-957">The methods that accept an `HttpContext` generate a URI in the context of the executing request.</span></span> <span data-ttu-id="f6d02-958">재정의되지 않는 한 실행 중인 요청의 앰비언트 경로 값, URL 기본 경로, 체계 및 호스트가 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-958">The ambient route values, URL base path, scheme, and host from the executing request are used unless overridden.</span></span>

<span data-ttu-id="f6d02-959"><xref:Microsoft.AspNetCore.Routing.LinkGenerator>는 주소를 사용하여 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-959"><xref:Microsoft.AspNetCore.Routing.LinkGenerator> is called with an address.</span></span> <span data-ttu-id="f6d02-960">URI 생성은 다음 두 단계로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-960">Generating a URI occurs in two steps:</span></span>

1. <span data-ttu-id="f6d02-961">주소는 해당 주소와 일치하는 엔드포인트 목록에 바인딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-961">An address is bound to a list of endpoints that match the address.</span></span>
1. <span data-ttu-id="f6d02-962">제공된 값과 일치하는 경로 패턴을 찾을 때까지 각 엔드포인트의 `RoutePattern`이 평가됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-962">Each endpoint's `RoutePattern` is evaluated until a route pattern that matches the supplied values is found.</span></span> <span data-ttu-id="f6d02-963">결과 출력은 링크 생성기에 제공된 다른 URI 부분과 결합되어 반환됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-963">The resulting output is combined with the other URI parts supplied to the link generator and returned.</span></span>

<span data-ttu-id="f6d02-964"><xref:Microsoft.AspNetCore.Routing.LinkGenerator>에서 제공하는 메서드는 모든 유형의 주소에 대해 표준 링크 생성 기능을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-964">The methods provided by <xref:Microsoft.AspNetCore.Routing.LinkGenerator> support standard link generation capabilities for any type of address.</span></span> <span data-ttu-id="f6d02-965">링크 생성기를 사용하는 가장 편리한 방법은 특정 주소 유형에 대한 작업을 수행하는 확장 메서드를 사용하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-965">The most convenient way to use the link generator is through extension methods that perform operations for a specific address type.</span></span>

| <span data-ttu-id="f6d02-966">확장 메서드</span><span class="sxs-lookup"><span data-stu-id="f6d02-966">Extension Method</span></span>   | <span data-ttu-id="f6d02-967">설명</span><span class="sxs-lookup"><span data-stu-id="f6d02-967">Description</span></span>                                                         |
| ------------------ | ------------------------------------------------------------------- |
| <xref:Microsoft.AspNetCore.Routing.LinkGenerator.GetPathByAddress*> | <span data-ttu-id="f6d02-968">제공된 값에 기반한 절대 경로의 URI를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-968">Generates a URI with an absolute path based on the provided values.</span></span> |
| <xref:Microsoft.AspNetCore.Routing.LinkGenerator.GetUriByAddress*> | <span data-ttu-id="f6d02-969">제공된 값에 기반한 절대 URI를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-969">Generates an absolute URI based on the provided values.</span></span>             |

> [!WARNING]
> <span data-ttu-id="f6d02-970"><xref:Microsoft.AspNetCore.Routing.LinkGenerator> 메서드 호출 시 다음과 같은 의미에 주의하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-970">Pay attention to the following implications of calling <xref:Microsoft.AspNetCore.Routing.LinkGenerator> methods:</span></span>
>
> * <span data-ttu-id="f6d02-971">들어오는 요청의 `GetUri*` 헤더의 유효성을 검사하지 않는 앱 구성에서는 `Host` 확장 메서드를 신중하게 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-971">Use `GetUri*` extension methods with caution in an app configuration that doesn't validate the `Host` header of incoming requests.</span></span> <span data-ttu-id="f6d02-972">들어오는 요청의 `Host` 헤더의 유효성을 검사하지 않으면 신뢰할 수 없는 요청 입력이 보기/페이지에 포함된 URI로 클라이언트에 다시 보내질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-972">If the `Host` header of incoming requests isn't validated, untrusted request input can be sent back to the client in URIs in a view/page.</span></span> <span data-ttu-id="f6d02-973">모든 프로덕션 앱은 알려진 유효한 값에 대해 `Host` 헤더의 유효성을 검사하도록 서버를 구성하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-973">We recommend that all production apps configure their server to validate the `Host` header against known valid values.</span></span>
>
> * <span data-ttu-id="f6d02-974">미들웨어에서 `MapWhen` 또는 <xref:Microsoft.AspNetCore.Routing.LinkGenerator>과 함께 `Map`를 사용할 때는 신중하게 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-974">Use <xref:Microsoft.AspNetCore.Routing.LinkGenerator> with caution in middleware in combination with `Map` or `MapWhen`.</span></span> <span data-ttu-id="f6d02-975">`Map*`는 실행 중인 요청의 기본 경로를 변경하여 링크 생성의 출력에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-975">`Map*` changes the base path of the executing request, which affects the output of link generation.</span></span> <span data-ttu-id="f6d02-976">모든 <xref:Microsoft.AspNetCore.Routing.LinkGenerator> API는 기본 경로를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-976">All of the <xref:Microsoft.AspNetCore.Routing.LinkGenerator> APIs allow specifying a base path.</span></span> <span data-ttu-id="f6d02-977">링크 생성에 대한 `Map*`의 영향을 취소하려면 항상 빈 기본 경로를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-977">Always specify an empty base path to undo `Map*`'s affect on link generation.</span></span>

## <a name="differences-from-earlier-versions-of-routing"></a><span data-ttu-id="f6d02-978">이전 버전의 라우팅과의 차이점</span><span class="sxs-lookup"><span data-stu-id="f6d02-978">Differences from earlier versions of routing</span></span>

<span data-ttu-id="f6d02-979">ASP.NET Core 2.2 이상의 엔드포인트 라우팅과 ASP.NET Core 이전 버전의 라우팅 간에는 다음과 같은 몇 가지 차이점이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-979">A few differences exist between endpoint routing in ASP.NET Core 2.2 or later and earlier versions of routing in ASP.NET Core:</span></span>

* <span data-ttu-id="f6d02-980">엔드포인트 라우팅 시스템은 <xref:Microsoft.AspNetCore.Routing.Route>에서 상속하는 것을 포함하여 <xref:Microsoft.AspNetCore.Routing.IRouter> 기반 확장성을 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-980">The endpoint routing system doesn't support <xref:Microsoft.AspNetCore.Routing.IRouter>-based extensibility, including inheriting from <xref:Microsoft.AspNetCore.Routing.Route>.</span></span>

* <span data-ttu-id="f6d02-981">엔드포인트 라우팅은 [WebApiCompatShim](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.WebApiCompatShim)을 지원하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-981">Endpoint routing doesn't support [WebApiCompatShim](https://www.nuget.org/packages/Microsoft.AspNetCore.Mvc.WebApiCompatShim).</span></span> <span data-ttu-id="f6d02-982">호환성 shim을 계속 사용하려면 2.1 [호환성 버전](xref:mvc/compatibility-version)(`.SetCompatibilityVersion(CompatibilityVersion.Version_2_1)`)을 사용하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-982">Use the 2.1 [compatibility version](xref:mvc/compatibility-version) (`.SetCompatibilityVersion(CompatibilityVersion.Version_2_1)`) to continue using the compatibility shim.</span></span>

* <span data-ttu-id="f6d02-983">엔드포인트 라우팅은 기존 경로를 사용하여 생성된 URI의 대/소문자 표기와 다른 동작을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-983">Endpoint Routing has different behavior for the casing of generated URIs when using conventional routes.</span></span>

  <span data-ttu-id="f6d02-984">다음과 같은 기본 경로 템플릿을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-984">Consider the following default route template:</span></span>

  ```csharp
  app.UseMvc(routes =>
  {
      routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
  });
  ```

  <span data-ttu-id="f6d02-985">다음 경로를 사용하여 작업에 대한 링크를 생성한다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-985">Suppose you generate a link to an action using the following route:</span></span>

  ```csharp
  var link = Url.Action("ReadPost", "blog", new { id = 17, });
  ```

  <span data-ttu-id="f6d02-986"><xref:Microsoft.AspNetCore.Routing.IRouter> 기반 라우팅을 사용하는 경우 이 코드는 제공된 경로 값의 대/소문자 표기를 고려하여 `/blog/ReadPost/17`이라는 URI를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-986">With <xref:Microsoft.AspNetCore.Routing.IRouter>-based routing, this code generates a URI of `/blog/ReadPost/17`, which respects the casing of the provided route value.</span></span> <span data-ttu-id="f6d02-987">ASP.NET Core 2.2 이상의 엔드포인트 라우팅에서는 `/Blog/ReadPost/17`을 생성합니다("Blog"의 첫 글자가 대문자로 지정됨).</span><span class="sxs-lookup"><span data-stu-id="f6d02-987">Endpoint routing in ASP.NET Core 2.2 or later produces `/Blog/ReadPost/17` ("Blog" is capitalized).</span></span> <span data-ttu-id="f6d02-988">엔드포인트 라우팅은 이 동작을 전역으로 사용자 지정하거나 URL 매핑에 대해 다른 규칙을 적용하는 데 사용할 수 있는 `IOutboundParameterTransformer` 인터페이스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-988">Endpoint routing provides the `IOutboundParameterTransformer` interface that can be used to customize this behavior globally or to apply different conventions for mapping URLs.</span></span>

  <span data-ttu-id="f6d02-989">자세한 내용은 [매개 변수 변환기 참조](#parameter-transformer-reference) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-989">For more information, see the [Parameter transformer reference](#parameter-transformer-reference) section.</span></span>

* <span data-ttu-id="f6d02-990">MVC/Razor Pages에서 기존 경로를 통해 사용하는 링크 생성이 존재하지 않는 컨트롤러/작업 또는 페이지에 연결하려고 할 때 다르게 동작합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-990">Link Generation used by MVC/Razor Pages with conventional routes behaves differently when attempting to link to an controller/action or page that doesn't exist.</span></span>

  <span data-ttu-id="f6d02-991">다음과 같은 기본 경로 템플릿을 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-991">Consider the following default route template:</span></span>

  ```csharp
  app.UseMvc(routes =>
  {
      routes.MapRoute("default", "{controller=Home}/{action=Index}/{id?}");
  });
  ```

  <span data-ttu-id="f6d02-992">다음과 함께 기본 템플릿을 사용하여 작업에 대한 링크를 생성한다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-992">Suppose you generate a link to an action using the default template with the following:</span></span>

  ```csharp
  var link = Url.Action("ReadPost", "Blog", new { id = 17, });
  ```

  <span data-ttu-id="f6d02-993">`IRouter` 기반 라우팅을 사용하면 `BlogController`가 존재하지 않거나 `ReadPost` 작업 메서드가 존재하지 않는 경우에도 결과는 항상 `/Blog/ReadPost/17`입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-993">With `IRouter`-based routing, the result is always `/Blog/ReadPost/17`, even if the `BlogController` doesn't exist or doesn't have a `ReadPost` action method.</span></span> <span data-ttu-id="f6d02-994">예상대로, 작업 메서드가 존재할 경우 ASP.NET Core 2.2 이상의 엔드포인트 라우팅은 `/Blog/ReadPost/17`을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-994">As expected, endpoint routing in ASP.NET Core 2.2 or later produces `/Blog/ReadPost/17` if the action method exists.</span></span> <span data-ttu-id="f6d02-995">*그러나 작업이 존재하지 않을 경우 엔드포인트 라우팅은 빈 문자열을 생성합니다.*</span><span class="sxs-lookup"><span data-stu-id="f6d02-995">*However, endpoint routing produces an empty string if the action doesn't exist.*</span></span> <span data-ttu-id="f6d02-996">개념적으로 엔드포인트 라우팅은 작업이 존재하지 않는 경우 엔드포인트가 존재한다고 가정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-996">Conceptually, endpoint routing doesn't assume that the endpoint exists if the action doesn't exist.</span></span>

* <span data-ttu-id="f6d02-997">링크 생성 *앰비언트 값 무효화 알고리즘*은 엔드포인트 라우팅에서 사용할 때 다르게 작동합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-997">The link generation *ambient value invalidation algorithm* behaves differently when used with endpoint routing.</span></span>

  <span data-ttu-id="f6d02-998">*앰비언트 값 무효화*는 링크 생성 작업에서 사용할 수 있는 현재 실행 중인 요청의 경로 값(앰비언트 값)을 결정하는 알고리즘입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-998">*Ambient value invalidation* is the algorithm that decides which route values from the currently executing request (the ambient values) can be used in link generation operations.</span></span> <span data-ttu-id="f6d02-999">기존 라우팅은 다른 작업에 연결할 때 항상 추가 경로 값을 무효화했습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-999">Conventional routing always invalidated extra route values when linking to a different action.</span></span> <span data-ttu-id="f6d02-1000">ASP.NET Core 2.2를 릴리스하기 전에는 특성 라우팅에 이 동작이 없었습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1000">Attribute routing didn't have this behavior prior to the release of ASP.NET Core 2.2.</span></span> <span data-ttu-id="f6d02-1001">이전 버전의 ASP.NET Core에서는 동일한 경로 매개 변수 이름을 사용하는 다른 작업에 연결하면 링크 생성 오류가 발생했습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1001">In earlier versions of ASP.NET Core, links to another action that use the same route parameter names resulted in link generation errors.</span></span> <span data-ttu-id="f6d02-1002">ASP.NET Core 2.2 이상에서는 두 가지 형태의 라우팅 모두에서 다른 작업에 연결하면 값이 무효화됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1002">In ASP.NET Core 2.2 or later, both forms of routing invalidate values when linking to another action.</span></span>

  <span data-ttu-id="f6d02-1003">ASP.NET Core 2.1 이하에서 다음 예제를 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1003">Consider the following example in ASP.NET Core 2.1 or earlier.</span></span> <span data-ttu-id="f6d02-1004">다른 작업(또는 다른 페이지)에 연결할 때 경로 값을 원하지 않는 방법으로 다시 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1004">When linking to another action (or another page), route values can be reused in undesirable ways.</span></span>

  <span data-ttu-id="f6d02-1005">*/Pages/Store/Product.cshtml*,</span><span class="sxs-lookup"><span data-stu-id="f6d02-1005">In */Pages/Store/Product.cshtml*:</span></span>

  ```cshtml
  @page "{id}"
  @Url.Page("/Login")
  ```

  <span data-ttu-id="f6d02-1006">*/Pages/Login.cshtml*,</span><span class="sxs-lookup"><span data-stu-id="f6d02-1006">In */Pages/Login.cshtml*:</span></span>

  ```cshtml
  @page "{id?}"
  ```

  <span data-ttu-id="f6d02-1007">ASP.NET Core 2.1 이하에서 URI가 `/Store/Product/18`인 경우 Store/Info 페이지에서 `@Url.Page("/Login")`로 생성된 링크는 `/Login/18`입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1007">If the URI is `/Store/Product/18` in ASP.NET Core 2.1 or earlier, the link generated on the Store/Info page by `@Url.Page("/Login")` is `/Login/18`.</span></span> <span data-ttu-id="f6d02-1008">링크 대상이 완전히 다른 앱 부분인 경우에도 18이라는 `id` 값이 다시 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1008">The `id` value of 18 is reused, even though the link destination is different part of the app entirely.</span></span> <span data-ttu-id="f6d02-1009">`/Login` 페이지의 컨텍스트에 있는 `id` 경로 값은 상점 제품 ID 값이 아닌 사용자 ID 값일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1009">The `id` route value in the context of the `/Login` page is probably a user ID value, not a store product ID value.</span></span>

  <span data-ttu-id="f6d02-1010">ASP.NET Core 2.2 이상을 사용하는 엔드포인트 라우팅에서 결과는 `/Login`입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1010">In endpoint routing with ASP.NET Core 2.2 or later, the result is `/Login`.</span></span> <span data-ttu-id="f6d02-1011">연결된 대상이 다른 작업 또는 페이지인 경우 앰비언트 값은 다시 사용되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1011">Ambient values aren't reused when the linked destination is a different action or page.</span></span>

* <span data-ttu-id="f6d02-1012">라운드트립 경로 매개 변수 구문: 이중 별표(`**`) 범용(catch-all) 매개 변수 구문을 사용하는 경우 슬래시는 인코딩되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1012">Round-tripping route parameter syntax: Forward slashes aren't encoded when using a double-asterisk (`**`) catch-all parameter syntax.</span></span>

  <span data-ttu-id="f6d02-1013">링크를 생성하는 동안 라우팅 시스템은 슬래시를 제외한 이중 별표(`**`) 범용 매개 변수(예: `{**myparametername}`)에서 캡처된 값을 인코딩합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1013">During link generation, the routing system encodes the value captured in a double-asterisk (`**`) catch-all parameter (for example, `{**myparametername}`) except the forward slashes.</span></span> <span data-ttu-id="f6d02-1014">이중 별표 범용 매개 변수는 ASP.NET Core 2.2 이상의 `IRouter` 기반 라우팅에서 지원됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1014">The double-asterisk catch-all is supported with `IRouter`-based routing in ASP.NET Core 2.2 or later.</span></span>

  <span data-ttu-id="f6d02-1015">ASP.NET Core 이전 버전의 단일 별표 범용 매개 변수 구문(`{*myparametername}`)은 계속 지원되며, 슬래시가 인코딩됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1015">The single asterisk catch-all parameter syntax in prior versions of ASP.NET Core (`{*myparametername}`) remains supported, and forward slashes are encoded.</span></span>

  | <span data-ttu-id="f6d02-1016">경로</span><span class="sxs-lookup"><span data-stu-id="f6d02-1016">Route</span></span>              | <span data-ttu-id="f6d02-1017">다음을 사용하여 생성되는 링크</span><span class="sxs-lookup"><span data-stu-id="f6d02-1017">Link generated with</span></span><br>`Url.Action(new { category = "admin/products" })`&hellip; |
  | ------------------ | --------------------------------------------------------------------- |
  | `/search/{*page}`  | <span data-ttu-id="f6d02-1018">`/search/admin%2Fproducts`(슬래시가 인코딩됨)</span><span class="sxs-lookup"><span data-stu-id="f6d02-1018">`/search/admin%2Fproducts` (the forward slash is encoded)</span></span>             |
  | `/search/{**page}` | `/search/admin/products`                                              |

### <a name="middleware-example"></a><span data-ttu-id="f6d02-1019">미들웨어 예제</span><span class="sxs-lookup"><span data-stu-id="f6d02-1019">Middleware example</span></span>

<span data-ttu-id="f6d02-1020">다음 예제에서는 미들웨어에서 <xref:Microsoft.AspNetCore.Routing.LinkGenerator> API를 사용하여 상점 제품을 나열하는 작업 메서드에 대한 링크를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1020">In the following example, a middleware uses the <xref:Microsoft.AspNetCore.Routing.LinkGenerator> API to create link to an action method that lists store products.</span></span> <span data-ttu-id="f6d02-1021">링크 생성기를 클래스에 주입하고 `GenerateLink`를 호출하여 앱의 모든 클래스에서 해당 링크 생성기를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1021">Using the link generator by injecting it into a class and calling `GenerateLink` is available to any class in an app.</span></span>

```csharp
using Microsoft.AspNetCore.Routing;

public class ProductsLinkMiddleware
{
    private readonly LinkGenerator _linkGenerator;

    public ProductsLinkMiddleware(RequestDelegate next, LinkGenerator linkGenerator)
    {
        _linkGenerator = linkGenerator;
    }

    public async Task InvokeAsync(HttpContext httpContext)
    {
        var url = _linkGenerator.GetPathByAction("ListProducts", "Store");

        httpContext.Response.ContentType = "text/plain";

        await httpContext.Response.WriteAsync($"Go to {url} to see our products.");
    }
}
```

### <a name="create-routes"></a><span data-ttu-id="f6d02-1022">경로 만들기</span><span class="sxs-lookup"><span data-stu-id="f6d02-1022">Create routes</span></span>

<span data-ttu-id="f6d02-1023">대부분의 앱은 <xref:Microsoft.AspNetCore.Builder.MapRouteRouteBuilderExtensions.MapRoute*> 또는 <xref:Microsoft.AspNetCore.Routing.IRouteBuilder>에 정의된 유사한 확장 메서드 중 하나를 호출하여 경로를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1023">Most apps create routes by calling <xref:Microsoft.AspNetCore.Builder.MapRouteRouteBuilderExtensions.MapRoute*> or one of the similar extension methods defined on <xref:Microsoft.AspNetCore.Routing.IRouteBuilder>.</span></span> <span data-ttu-id="f6d02-1024">모든 <xref:Microsoft.AspNetCore.Routing.IRouteBuilder> 확장 메서드는 <xref:Microsoft.AspNetCore.Routing.Route>의 인스턴스를 만들고, 경로 컬렉션에 이를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1024">Any of the <xref:Microsoft.AspNetCore.Routing.IRouteBuilder> extension methods create an instance of <xref:Microsoft.AspNetCore.Routing.Route> and add it to the route collection.</span></span>

<span data-ttu-id="f6d02-1025"><xref:Microsoft.AspNetCore.Builder.MapRouteRouteBuilderExtensions.MapRoute*>는 경로 처리기 매개 변수를 허용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1025"><xref:Microsoft.AspNetCore.Builder.MapRouteRouteBuilderExtensions.MapRoute*> doesn't accept a route handler parameter.</span></span> <span data-ttu-id="f6d02-1026"><xref:Microsoft.AspNetCore.Builder.MapRouteRouteBuilderExtensions.MapRoute*>는 <xref:Microsoft.AspNetCore.Routing.RouteBuilder.DefaultHandler*>에 의해 처리되는 경로만 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1026"><xref:Microsoft.AspNetCore.Builder.MapRouteRouteBuilderExtensions.MapRoute*> only adds routes that are handled by the <xref:Microsoft.AspNetCore.Routing.RouteBuilder.DefaultHandler*>.</span></span> <span data-ttu-id="f6d02-1027">MVC의 라우팅에 대해 자세히 알아보려면 <xref:mvc/controllers/routing>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1027">To learn more about routing in MVC, see <xref:mvc/controllers/routing>.</span></span>

<span data-ttu-id="f6d02-1028">다음 코드 예제는 일반적인 ASP.NET Core MVC 경로 정의에서 사용되는 <xref:Microsoft.AspNetCore.Builder.MapRouteRouteBuilderExtensions.MapRoute*> 호출의 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1028">The following code example is an example of a <xref:Microsoft.AspNetCore.Builder.MapRouteRouteBuilderExtensions.MapRoute*> call used by a typical ASP.NET Core MVC route definition:</span></span>

```csharp
routes.MapRoute(
    name: "default",
    template: "{controller=Home}/{action=Index}/{id?}");
```

<span data-ttu-id="f6d02-1029">이 템플릿은 URL 경로와 일치시키고 경로 값을 추출합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1029">This template matches a URL path and extracts the route values.</span></span> <span data-ttu-id="f6d02-1030">예를 들어 `/Products/Details/17` 경로는 `{ controller = Products, action = Details, id = 17 }` 경로 값을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1030">For example, the path `/Products/Details/17` generates the following route values: `{ controller = Products, action = Details, id = 17 }`.</span></span>

<span data-ttu-id="f6d02-1031">경로 값은 URL 경로를 세그먼트로 분할하고 각 세그먼트를 경로 템플릿의 *경로 매개 변수* 이름과 일치시켜 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1031">Route values are determined by splitting the URL path into segments and matching each segment with the *route parameter* name in the route template.</span></span> <span data-ttu-id="f6d02-1032">경로 매개 변수는 이름이 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1032">Route parameters are named.</span></span> <span data-ttu-id="f6d02-1033">매개 변수는 매개 변수 이름을 `{ ... }` 중괄호로 묶어 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1033">The parameters defined by enclosing the parameter name in braces `{ ... }`.</span></span>

<span data-ttu-id="f6d02-1034">또한 위의 템플릿은 `/` URL 경로와 일치시키고 `{ controller = Home, action = Index }` 값을 생성할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1034">The preceding template could also match the URL path `/` and produce the values `{ controller = Home, action = Index }`.</span></span> <span data-ttu-id="f6d02-1035">이는 `{controller}` 및 `{action}` 경로 매개 변수에 기본값이 있으며 `id` 경로 매개 변수는 선택 사항이기 때문에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1035">This occurs because the `{controller}` and `{action}` route parameters have default values and the `id` route parameter is optional.</span></span> <span data-ttu-id="f6d02-1036">경로 매개 변수 이름 뒤에 있는 값이 뒤따르는 등호(`=`)는 매개 변수에 대한 기본값을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1036">An equals sign (`=`) followed by a value after the route parameter name defines a default value for the parameter.</span></span> <span data-ttu-id="f6d02-1037">경로 매개 변수 이름 뒤에 있는 물음표(`?`)는 선택적 매개 변수를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1037">A question mark (`?`) after the route parameter name defines an optional parameter.</span></span>

<span data-ttu-id="f6d02-1038">기본 값을 사용하는 경로 매개 변수는 경로가 일치하는 경우 *항상* 경로 값을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1038">Route parameters with a default value *always* produce a route value when the route matches.</span></span> <span data-ttu-id="f6d02-1039">해당 URL 경로 세그먼트가 없는 경우 선택적 매개 변수는 경로 값을 생성하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1039">Optional parameters don't produce a route value if there is no corresponding URL path segment.</span></span> <span data-ttu-id="f6d02-1040">경로 템플릿 시나리오 및 구문에 대한 자세한 설명은 [경로 템플릿 참조](#route-template-reference) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1040">See the [Route template reference](#route-template-reference) section for a thorough description of route template scenarios and syntax.</span></span>

<span data-ttu-id="f6d02-1041">다음 예제에서 `{id:int}` 경로 매개 변수 정의는 `id` 경로 매개 변수에 대한 [경로 제약 조건](#route-constraint-reference)을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1041">In the following example, the route parameter definition `{id:int}` defines a [route constraint](#route-constraint-reference) for the `id` route parameter:</span></span>

```csharp
routes.MapRoute(
    name: "default",
    template: "{controller=Home}/{action=Index}/{id:int}");
```

<span data-ttu-id="f6d02-1042">이 템플릿은 `/Products/Details/Apples`가 아닌 `/Products/Details/17`과 같은 URL 경로와 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1042">This template matches a URL path like `/Products/Details/17` but not `/Products/Details/Apples`.</span></span> <span data-ttu-id="f6d02-1043">경로 제약 조건은 <xref:Microsoft.AspNetCore.Routing.IRouteConstraint>를 구현하고 경로 값을 검사하여 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1043">Route constraints implement <xref:Microsoft.AspNetCore.Routing.IRouteConstraint> and inspect route values to verify them.</span></span> <span data-ttu-id="f6d02-1044">이 예제에서 경로 값 `id`는 정수로 변환할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1044">In this example, the route value `id` must be convertible to an integer.</span></span> <span data-ttu-id="f6d02-1045">프레임워크에서 제공하는 경로 제약 조건에 대한 설명은 [경로 제약 조건 참조](#route-constraint-reference)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1045">See [route-constraint-reference](#route-constraint-reference) for an explanation of route constraints provided by the framework.</span></span>

<span data-ttu-id="f6d02-1046"><xref:Microsoft.AspNetCore.Builder.MapRouteRouteBuilderExtensions.MapRoute*>의 추가 오버로드는 `constraints`, `dataTokens` 및 `defaults`에 대한 값을 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1046">Additional overloads of <xref:Microsoft.AspNetCore.Builder.MapRouteRouteBuilderExtensions.MapRoute*> accept values for `constraints`, `dataTokens`, and `defaults`.</span></span> <span data-ttu-id="f6d02-1047">이러한 매개 변수의 일반적인 사용법은 익명 형식의 속성 이름이 경로 매개 변수 이름과 일치하는 익명 형식의 개체를 전달하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1047">The typical usage of these parameters is to pass an anonymously typed object, where the property names of the anonymous type match route parameter names.</span></span>

<span data-ttu-id="f6d02-1048">다음 <xref:Microsoft.AspNetCore.Builder.MapRouteRouteBuilderExtensions.MapRoute*> 예제에서는 동등한 경로를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1048">The following <xref:Microsoft.AspNetCore.Builder.MapRouteRouteBuilderExtensions.MapRoute*> examples create equivalent routes:</span></span>

```csharp
routes.MapRoute(
    name: "default_route",
    template: "{controller}/{action}/{id?}",
    defaults: new { controller = "Home", action = "Index" });

routes.MapRoute(
    name: "default_route",
    template: "{controller=Home}/{action=Index}/{id?}");
```

> [!TIP]
> <span data-ttu-id="f6d02-1049">제약 조건 및 기본값을 정의하기 위한 인라인 구문은 단순 경로에 편리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1049">The inline syntax for defining constraints and defaults can be convenient for simple routes.</span></span> <span data-ttu-id="f6d02-1050">그러나 데이터 토큰과 같이 인라인 구문에서는 지원되지 않는 시나리오가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1050">However, there are scenarios, such as data tokens, that aren't supported by inline syntax.</span></span>

<span data-ttu-id="f6d02-1051">다음 예제에서는 몇 가지 추가 시나리오를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1051">The following example demonstrates a few additional scenarios:</span></span>

```csharp
routes.MapRoute(
    name: "blog",
    template: "Blog/{**article}",
    defaults: new { controller = "Blog", action = "ReadArticle" });
```

<span data-ttu-id="f6d02-1052">위의 템플릿은 `/Blog/All-About-Routing/Introduction`과 같은 URL 경로와 일치하고 `{ controller = Blog, action = ReadArticle, article = All-About-Routing/Introduction }` 값을 추출합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1052">The preceding template matches a URL path like `/Blog/All-About-Routing/Introduction` and extracts the values `{ controller = Blog, action = ReadArticle, article = All-About-Routing/Introduction }`.</span></span> <span data-ttu-id="f6d02-1053">`controller` 및 `action`에 대한 기본 경로 값은 템플릿에 해당 경로 매개 변수가 없는 경우에도 경로에 의해 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1053">The default route values for `controller` and `action` are produced by the route even though there are no corresponding route parameters in the template.</span></span> <span data-ttu-id="f6d02-1054">기본값은 경로 템플릿에서 지정될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1054">Default values can be specified in the route template.</span></span> <span data-ttu-id="f6d02-1055">`article` 경로 매개 변수는 경로 매개 변수 이름 앞에 이중 별표(`**`)를 표시하여 *범용*으로 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1055">The `article` route parameter is defined as a *catch-all* by the appearance of an double asterisk (`**`) before the route parameter name.</span></span> <span data-ttu-id="f6d02-1056">범용 경로 매개 변수는 URL 경로의 나머지를 캡처하고 빈 문자열과도 일치시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1056">Catch-all route parameters capture the remainder of the URL path and can also match the empty string.</span></span>

<span data-ttu-id="f6d02-1057">다음 예제에서는 경로 제약 조건 및 데이터 토큰을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1057">The following example adds route constraints and data tokens:</span></span>

```csharp
routes.MapRoute(
    name: "us_english_products",
    template: "en-US/Products/{id}",
    defaults: new { controller = "Products", action = "Details" },
    constraints: new { id = new IntRouteConstraint() },
    dataTokens: new { locale = "en-US" });
```

<span data-ttu-id="f6d02-1058">앞의 템플릿은 `/en-US/Products/5`와 같은 URL 경로와 일치하고, `{ controller = Products, action = Details, id = 5 }` 값 및 `{ locale = en-US }` 데이터 토큰을 추출합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1058">The preceding template matches a URL path like `/en-US/Products/5` and extracts the values `{ controller = Products, action = Details, id = 5 }` and the data tokens `{ locale = en-US }`.</span></span>

![지역 Windows 토큰](routing/_static/tokens.png)

### <a name="route-class-url-generation"></a><span data-ttu-id="f6d02-1060">Route 클래스 URL 생성</span><span class="sxs-lookup"><span data-stu-id="f6d02-1060">Route class URL generation</span></span>

<span data-ttu-id="f6d02-1061"><xref:Microsoft.AspNetCore.Routing.Route> 클래스는 경로 값의 집합을 해당 경로 템플릿과 결합하여 URL 생성을 수행할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1061">The <xref:Microsoft.AspNetCore.Routing.Route> class can also perform URL generation by combining a set of route values with its route template.</span></span> <span data-ttu-id="f6d02-1062">이는 논리적으로 URL 경로와 일치시키는 역방향 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1062">This is logically the reverse process of matching the URL path.</span></span>

> [!TIP]
> <span data-ttu-id="f6d02-1063">URL 생성을 보다 잘 이해하려면 생성하려는 URL을 가정한 다음, 경로 템플릿을 해당 URL과 일치시키는 방법을 생각합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1063">To better understand URL generation, imagine what URL you want to generate and then think about how a route template would match that URL.</span></span> <span data-ttu-id="f6d02-1064">어떤 값이 생성되나요?</span><span class="sxs-lookup"><span data-stu-id="f6d02-1064">What values would be produced?</span></span> <span data-ttu-id="f6d02-1065">이는 URL 생성이 <xref:Microsoft.AspNetCore.Routing.Route> 클래스에서 작동하는 방식과 대략적으로 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1065">This is the rough equivalent of how URL generation works in the <xref:Microsoft.AspNetCore.Routing.Route> class.</span></span>

<span data-ttu-id="f6d02-1066">다음 예제에서는 일반적인 ASP.NET Core MVC 기본 경로를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1066">The following example uses a general ASP.NET Core MVC default route:</span></span>

```csharp
routes.MapRoute(
    name: "default",
    template: "{controller=Home}/{action=Index}/{id?}");
```

<span data-ttu-id="f6d02-1067">`{ controller = Products, action = List }` 경로 값을 사용하면 `/Products/List` URL이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1067">With the route values `{ controller = Products, action = List }`, the URL `/Products/List` is generated.</span></span> <span data-ttu-id="f6d02-1068">경로 값은 URL 경로를 구성하기 위해 해당 경로 매개 변수에 대해 대체됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1068">The route values are substituted for the corresponding route parameters to form the URL path.</span></span> <span data-ttu-id="f6d02-1069">`id`는 선택적 경로 매개 변수이므로 `id`에 대한 값 없이 URL이 성공적으로 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1069">Since `id` is an optional route parameter, the URL is successfully generated without a value for `id`.</span></span>

<span data-ttu-id="f6d02-1070">`{ controller = Home, action = Index }` 경로 값을 사용하면 `/` URL이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1070">With the route values `{ controller = Home, action = Index }`, the URL `/` is generated.</span></span> <span data-ttu-id="f6d02-1071">제공된 경로 값이 기본값과 일치하고, 기본값에 해당하는 세그먼트는 안전하게 생략됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1071">The provided route values match the default values, and the segments corresponding to the default values are safely omitted.</span></span>

<span data-ttu-id="f6d02-1072">뒤이어 언급된 경로 정의(`/Home/Index` 및 `/`)를 사용하는 URL 생성 왕복 모두에서는 URL을 생성하기 위해 사용된 것과 동일한 경로 값을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1072">Both URLs generated round-trip with the following route definition (`/Home/Index` and `/`) produce the same route values that were used to generate the URL.</span></span>

> [!NOTE]
> <span data-ttu-id="f6d02-1073">ASP.NET Core MVC를 사용하는 앱은 라우팅을 직접 호출하는 대신 <xref:Microsoft.AspNetCore.Mvc.Routing.UrlHelper>를 사용하여 URL을 생성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1073">An app using ASP.NET Core MVC should use <xref:Microsoft.AspNetCore.Mvc.Routing.UrlHelper> to generate URLs instead of calling into routing directly.</span></span>

<span data-ttu-id="f6d02-1074">URL 생성에 대한 자세한 내용은 [URL 생성 참조](#url-generation-reference) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1074">For more information on URL generation, see the [Url generation reference](#url-generation-reference) section.</span></span>

## <a name="use-routing-middleware"></a><span data-ttu-id="f6d02-1075">라우팅 미들웨어 사용</span><span class="sxs-lookup"><span data-stu-id="f6d02-1075">Use Routing Middleware</span></span>

<span data-ttu-id="f6d02-1076">앱의 프로젝트 파일에서 [Microsoft.AspNetCore.App 메타패키지](xref:fundamentals/metapackage-app)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1076">Reference the [Microsoft.AspNetCore.App metapackage](xref:fundamentals/metapackage-app) in the app's project file.</span></span>

<span data-ttu-id="f6d02-1077">`Startup.ConfigureServices`의 서비스 컨테이너에 라우팅을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1077">Add routing to the service container in `Startup.ConfigureServices`:</span></span>

[!code-csharp[](routing/samples/2.x/RoutingSample/Startup.cs?name=snippet_ConfigureServices&highlight=3)]

<span data-ttu-id="f6d02-1078">경로는 `Startup.Configure` 메서드에서 구성되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1078">Routes must be configured in the `Startup.Configure` method.</span></span> <span data-ttu-id="f6d02-1079">샘플 앱에서 사용하는 API는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1079">The sample app uses the following APIs:</span></span>

* <xref:Microsoft.AspNetCore.Routing.RouteBuilder>
* <span data-ttu-id="f6d02-1080"><xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapGet*> &ndash; HTTP GET 요청만 일치시킵니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1080"><xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapGet*> &ndash; Matches only HTTP GET requests.</span></span>
* <xref:Microsoft.AspNetCore.Builder.RoutingBuilderExtensions.UseRouter*>

[!code-csharp[](routing/samples/2.x/RoutingSample/Startup.cs?name=snippet_RouteHandler)]

<span data-ttu-id="f6d02-1081">다음 표는 지정된 URI에 대한 응답을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1081">The following table shows the responses with the given URIs.</span></span>

| <span data-ttu-id="f6d02-1082">URI</span><span class="sxs-lookup"><span data-stu-id="f6d02-1082">URI</span></span>                    | <span data-ttu-id="f6d02-1083">응답</span><span class="sxs-lookup"><span data-stu-id="f6d02-1083">Response</span></span>                                          |
| ---------------------- | ------------------------------------------------- |
| `/package/create/3`    | <span data-ttu-id="f6d02-1084">Hello!</span><span class="sxs-lookup"><span data-stu-id="f6d02-1084">Hello!</span></span> <span data-ttu-id="f6d02-1085">Route values: [operation, create], [id, 3]</span><span class="sxs-lookup"><span data-stu-id="f6d02-1085">Route values: [operation, create], [id, 3]</span></span> |
| `/package/track/-3`    | <span data-ttu-id="f6d02-1086">Hello!</span><span class="sxs-lookup"><span data-stu-id="f6d02-1086">Hello!</span></span> <span data-ttu-id="f6d02-1087">Route values: [operation, track], [id, -3]</span><span class="sxs-lookup"><span data-stu-id="f6d02-1087">Route values: [operation, track], [id, -3]</span></span> |
| `/package/track/-3/`   | <span data-ttu-id="f6d02-1088">Hello!</span><span class="sxs-lookup"><span data-stu-id="f6d02-1088">Hello!</span></span> <span data-ttu-id="f6d02-1089">Route values: [operation, track], [id, -3]</span><span class="sxs-lookup"><span data-stu-id="f6d02-1089">Route values: [operation, track], [id, -3]</span></span> |
| `/package/track/`      | <span data-ttu-id="f6d02-1090">일치하는 경로가 없으므로, 요청이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1090">The request falls through, no match.</span></span>              |
| `GET /hello/Joe`       | <span data-ttu-id="f6d02-1091">Hi, Joe!</span><span class="sxs-lookup"><span data-stu-id="f6d02-1091">Hi, Joe!</span></span>                                          |
| `POST /hello/Joe`      | <span data-ttu-id="f6d02-1092">HTTP GET만 일치하므로, 요청이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1092">The request falls through, matches HTTP GET only.</span></span> |
| `GET /hello/Joe/Smith` | <span data-ttu-id="f6d02-1093">일치하는 경로가 없으므로, 요청이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1093">The request falls through, no match.</span></span>              |

<span data-ttu-id="f6d02-1094">프레임워크는 경로를 만드는 확장 메서드 모음(<xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions>)을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1094">The framework provides a set of extension methods for creating routes (<xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions>):</span></span>

* <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapDelete*>
* <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapGet*>
* <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapMiddlewareDelete*>
* <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapMiddlewareGet*>
* <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapMiddlewarePost*>
* <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapMiddlewarePut*>
* <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapMiddlewareRoute*>
* <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapMiddlewareVerb*>
* <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapPost*>
* <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapPut*>
* <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapRoute*>
* <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapVerb*>

<span data-ttu-id="f6d02-1095">`Map[Verb]` 메서드는 제약 조건을 사용하여 메서드 이름에 지정된 HTTP 동사에 대한 경로로 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1095">The `Map[Verb]` methods use constraints to limit the route to the HTTP Verb in the method name.</span></span> <span data-ttu-id="f6d02-1096">예제는 <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapGet*> 및 <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapVerb*>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1096">For example, see <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapGet*> and <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapVerb*>.</span></span>

## <a name="route-template-reference"></a><span data-ttu-id="f6d02-1097">경로 템플릿 참조</span><span class="sxs-lookup"><span data-stu-id="f6d02-1097">Route template reference</span></span>

<span data-ttu-id="f6d02-1098">중괄호(`{ ... }`) 내의 토큰은 경로가 일치하는 경우 바인딩될 *경로 매개 변수*를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1098">Tokens within curly braces (`{ ... }`) define *route parameters* that are bound if the route is matched.</span></span> <span data-ttu-id="f6d02-1099">경로 세그먼트에 둘 이상의 경로 매개 변수를 정의할 수 있지만 리터럴 값으로 분리되어 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1099">You can define more than one route parameter in a route segment, but they must be separated by a literal value.</span></span> <span data-ttu-id="f6d02-1100">예를 들어 `{controller=Home}{action=Index}`는 `{controller}` 및 `{action}` 사이에 리터럴 값이 없으므로 유효한 경로가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1100">For example, `{controller=Home}{action=Index}` isn't a valid route, since there's no literal value between `{controller}` and `{action}`.</span></span> <span data-ttu-id="f6d02-1101">이러한 경로 매개 변수는 이름이 있어야 하며 지정된 추가 특성을 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1101">These route parameters must have a name and may have additional attributes specified.</span></span>

<span data-ttu-id="f6d02-1102">경로 매개 변수 이외의 리터럴 텍스트(예: `{id}`) 및 경로 구분 기호(`/`)는 URL의 텍스트와 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1102">Literal text other than route parameters (for example, `{id}`) and the path separator `/` must match the text in the URL.</span></span> <span data-ttu-id="f6d02-1103">텍스트 일치는 대/소문자를 구분하지 않으며 URL 경로의 디코딩된 표현을 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1103">Text matching is case-insensitive and based on the decoded representation of the URLs path.</span></span> <span data-ttu-id="f6d02-1104">리터럴 경로 매개 변수 구분 기호(`{` 또는 `}`)와 일치시키려면 문자를 반복하여(`{{` 또는 `}}`) 구분 기호를 이스케이프합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1104">To match a literal route parameter delimiter (`{` or `}`), escape the delimiter by repeating the character (`{{` or `}}`).</span></span>

<span data-ttu-id="f6d02-1105">선택적 파일 확장명이 있는 파일 이름을 캡처하려고 시도하는 URL 패턴에는 추가 고려 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1105">URL patterns that attempt to capture a file name with an optional file extension have additional considerations.</span></span> <span data-ttu-id="f6d02-1106">예를 들어 템플릿 `files/{filename}.{ext?}`를 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1106">For example, consider the template `files/{filename}.{ext?}`.</span></span> <span data-ttu-id="f6d02-1107">`filename` 및 `ext` 모두에 대한 값이 있으면 두 값이 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1107">When values for both `filename` and `ext` exist, both values are populated.</span></span> <span data-ttu-id="f6d02-1108">URL에 `filename`에 대한 값만 있으면 후행 마침표(`.`)가 선택 사항이므로 경로가 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1108">If only a value for `filename` exists in the URL, the route matches because the trailing period (`.`) is  optional.</span></span> <span data-ttu-id="f6d02-1109">다음 URL은 이 경로와 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1109">The following URLs match this route:</span></span>

* `/files/myFile.txt`
* `/files/myFile`

<span data-ttu-id="f6d02-1110">별표(`*`) 또는 이중 별표(`**`)를 경로 매개 변수의 접두사로 사용하여 URI의 나머지 부분에 바인딩할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1110">You can use an asterisk (`*`) or double asterisk (`**`) as a prefix to a route parameter to bind to the rest of the URI.</span></span> <span data-ttu-id="f6d02-1111">이러한 매개 변수는 *범용* 매개 변수라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1111">These are called a *catch-all* parameters.</span></span> <span data-ttu-id="f6d02-1112">예를 들어 `blog/{**slug}`는 `/blog`로 시작하고 모든 값(`slug` 경로 값에 할당된)이 뒤따르는 모든 URI와 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1112">For example, `blog/{**slug}` matches any URI that starts with `/blog` and has any value following it, which is assigned to the `slug` route value.</span></span> <span data-ttu-id="f6d02-1113">범용 매개 변수는 빈 문자열과 일치시킬 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1113">Catch-all parameters can also match the empty string.</span></span>

<span data-ttu-id="f6d02-1114">catch-all 매개 변수는 경로 구분 기호(`/`) 문자를 포함하여 URL을 생성하는 데 경로가 사용될 때 적절한 문자를 이스케이프합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1114">The catch-all parameter escapes the appropriate characters when the route is used to generate a URL, including path separator (`/`) characters.</span></span> <span data-ttu-id="f6d02-1115">예를 들어 경로 값이 `{ path = "my/path" }`인 경로 `foo/{*path}`는 `foo/my%2Fpath`를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1115">For example, the route `foo/{*path}` with route values `{ path = "my/path" }` generates `foo/my%2Fpath`.</span></span> <span data-ttu-id="f6d02-1116">이스케이프된 슬래시에 주의하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1116">Note the escaped forward slash.</span></span> <span data-ttu-id="f6d02-1117">경로 구분 기호 문자를 왕복하려면 `**` 경로 매개 변수 접두사를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1117">To round-trip path separator characters, use the `**` route parameter prefix.</span></span> <span data-ttu-id="f6d02-1118">`{ path = "my/path" }`를 사용하는 경로 `foo/{**path}`는 `foo/my/path`를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1118">The route `foo/{**path}` with `{ path = "my/path" }` generates `foo/my/path`.</span></span>

<span data-ttu-id="f6d02-1119">경로 매개 변수에는 등호(`=`)로 구분된 매개 변수 이름 뒤에 기본값을 지정하여 지정된 *기본값*이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1119">Route parameters may have *default values* designated by specifying the default value after the parameter name separated by an equals sign (`=`).</span></span> <span data-ttu-id="f6d02-1120">예를 들어 `{controller=Home}`은 `controller`에 대한 기본값으로 `Home`을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1120">For example, `{controller=Home}` defines `Home` as the default value for `controller`.</span></span> <span data-ttu-id="f6d02-1121">URL에 매개 변수에 대한 값이 없는 경우 기본값이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1121">The default value is used if no value is present in the URL for the parameter.</span></span> <span data-ttu-id="f6d02-1122">경로 매개 변수는 `id?`와 같이 매개 변수 이름의 끝에 물음표(`?`)를 추가하면 선택적이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1122">Route parameters are made optional by appending a question mark (`?`) to the end of the parameter name, as in `id?`.</span></span> <span data-ttu-id="f6d02-1123">선택적 값과 기본 경로 매개 변수 간의 차이점은 기본값이 있는 경로 매개 변수는 항상 값을 생성한다는 것입니다. 선택적 매개 변수에는 요청 URL에서 값을 제공하는 경우에만 값이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1123">The difference between optional values and default route parameters is that a route parameter with a default value always produces a value&mdash;an optional parameter has a value only when a value is provided by the request URL.</span></span>

<span data-ttu-id="f6d02-1124">경로 매개 변수에는 URL에서 바인딩된 경로 값과 일치해야 한다는 제약 조건이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1124">Route parameters may have constraints that must match the route value bound from the URL.</span></span> <span data-ttu-id="f6d02-1125">경로 매개 변수 이름 뒤에 콜론(`:`)과 제약 조건 이름을 추가하여 경로 매개 변수에서 *인라인 제약 조건*을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1125">Adding a colon (`:`) and constraint name after the route parameter name specifies an *inline constraint* on a route parameter.</span></span> <span data-ttu-id="f6d02-1126">제약 조건에 인수가 필요한 경우 제약 조건 이름 뒤에 인수를 괄호(`(...)`)로 묶습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1126">If the constraint requires arguments, they're enclosed in parentheses (`(...)`) after the constraint name.</span></span> <span data-ttu-id="f6d02-1127">또 다른 콜론(`:`) 및 제약 조건 이름을 추가하여 여러 인라인 제약 조건을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1127">Multiple inline constraints can be specified by appending another colon (`:`) and constraint name.</span></span>

<span data-ttu-id="f6d02-1128">제약 조건 이름 및 인수는 <xref:Microsoft.AspNetCore.Routing.IRouteConstraint>의 인스턴스를 만드는 <xref:Microsoft.AspNetCore.Routing.IInlineConstraintResolver> 서비스로 전달되어 URL 처리에서 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1128">The constraint name and arguments are passed to the <xref:Microsoft.AspNetCore.Routing.IInlineConstraintResolver> service to create an instance of <xref:Microsoft.AspNetCore.Routing.IRouteConstraint> to use in URL processing.</span></span> <span data-ttu-id="f6d02-1129">예를 들어 경로 템플릿 `blog/{article:minlength(10)}`는 인수 `10`으로 `minlength` 제약 조건을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1129">For example, the route template `blog/{article:minlength(10)}` specifies a `minlength` constraint with the argument `10`.</span></span> <span data-ttu-id="f6d02-1130">경로 제약 조건 및 프레임워크에서 제공하는 제약 조건 목록에 대한 자세한 내용은 [경로 제약 조건 참조](#route-constraint-reference) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1130">For more information on route constraints and a list of the constraints provided by the framework, see the [Route constraint reference](#route-constraint-reference) section.</span></span>

<span data-ttu-id="f6d02-1131">또한 경로 매개 변수에는 링크를 생성하고 URL에 대한 작업 및 페이지와 일치할 때 매개 변수 값을 변환하는 매개 변수 변환기가 있을 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1131">Route parameters may also have parameter transformers, which transform a parameter's value when generating links and matching actions and pages to URLs.</span></span> <span data-ttu-id="f6d02-1132">제약 조건과 마찬가지로, 매개 변수 변환기는 경로 매개 변수 이름 뒤에 콜론(`:`)과 변환기 이름을 추가하여 라우트 매개 변수에 인라인으로 추가될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1132">Like constraints, parameter transformers can be added inline to a route parameter by adding a colon (`:`) and transformer name after the route parameter name.</span></span> <span data-ttu-id="f6d02-1133">예를 들어 경로 템플릿 `blog/{article:slugify}`는 `slugify` 변환기를 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1133">For example, the route template `blog/{article:slugify}` specifies a `slugify` transformer.</span></span> <span data-ttu-id="f6d02-1134">매개 변수 변환기에 대한 자세한 내용은 [매개 변수 변환기 참조](#parameter-transformer-reference) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1134">For more information on parameter transformers, see the [Parameter transformer reference](#parameter-transformer-reference) section.</span></span>

<span data-ttu-id="f6d02-1135">다음 표에서는 경로 템플릿 예제 및 해당 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1135">The following table demonstrates example route templates and their behavior.</span></span>

| <span data-ttu-id="f6d02-1136">경로 템플릿</span><span class="sxs-lookup"><span data-stu-id="f6d02-1136">Route Template</span></span>                           | <span data-ttu-id="f6d02-1137">URI 일치 예제</span><span class="sxs-lookup"><span data-stu-id="f6d02-1137">Example Matching URI</span></span>    | <span data-ttu-id="f6d02-1138">요청 URI&hellip;</span><span class="sxs-lookup"><span data-stu-id="f6d02-1138">The request URI&hellip;</span></span>                                                    |
| ---------------------------------------- | ----------------------- | -------------------------------------------------------------------------- |
| `hello`                                  | `/hello`                | <span data-ttu-id="f6d02-1139">`/hello` 단일 경로만 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1139">Only matches the single path `/hello`.</span></span>                                     |
| `{Page=Home}`                            | `/`                     | <span data-ttu-id="f6d02-1140">일치하고, `Page`를 `Home`으로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1140">Matches and sets `Page` to `Home`.</span></span>                                         |
| `{Page=Home}`                            | `/Contact`              | <span data-ttu-id="f6d02-1141">일치하고, `Page`를 `Contact`로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1141">Matches and sets `Page` to `Contact`.</span></span>                                      |
| `{controller}/{action}/{id?}`            | `/Products/List`        | <span data-ttu-id="f6d02-1142">`Products` 컨트롤러 및 `List` 작업에 매핑합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1142">Maps to the `Products` controller and `List` action.</span></span>                       |
| `{controller}/{action}/{id?}`            | `/Products/Details/123` | <span data-ttu-id="f6d02-1143">`Products` 컨트롤러 및 `Details` 작업에 매핑합니다(`id`가 123으로 설정됨).</span><span class="sxs-lookup"><span data-stu-id="f6d02-1143">Maps to the `Products` controller and  `Details` action (`id` set to 123).</span></span> |
| `{controller=Home}/{action=Index}/{id?}` | `/`                     | <span data-ttu-id="f6d02-1144">`Home` 컨트롤러 및 `Index` 메서드에 매핑합니다(`id`가 무시됨).</span><span class="sxs-lookup"><span data-stu-id="f6d02-1144">Maps to the `Home` controller and `Index` method (`id` is ignored).</span></span>        |

<span data-ttu-id="f6d02-1145">템플릿을 사용하는 것은 일반적으로 라우팅에 대한 가장 간단한 방식입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1145">Using a template is generally the simplest approach to routing.</span></span> <span data-ttu-id="f6d02-1146">제약 조건 및 기본값을 경로 템플릿 외부에서 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1146">Constraints and defaults can also be specified outside the route template.</span></span>

> [!TIP]
> <span data-ttu-id="f6d02-1147">[로깅](xref:fundamentals/logging/index)을 사용하도록 설정하여 <xref:Microsoft.AspNetCore.Routing.Route>와 같은 기본 제공 라우팅 구현이 요청과 일치하는 방법을 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1147">Enable [Logging](xref:fundamentals/logging/index) to see how the built-in routing implementations, such as <xref:Microsoft.AspNetCore.Routing.Route>, match requests.</span></span>

## <a name="reserved-routing-names"></a><span data-ttu-id="f6d02-1148">예약된 라우팅 이름</span><span class="sxs-lookup"><span data-stu-id="f6d02-1148">Reserved routing names</span></span>

<span data-ttu-id="f6d02-1149">다음 키워드는 예약된 이름이므로 경로 이름 또는 매개 변수로 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1149">The following keywords are reserved names and can't be used as route names or parameters:</span></span>

* `action`
* `area`
* `controller`
* `handler`
* `page`

## <a name="route-constraint-reference"></a><span data-ttu-id="f6d02-1150">경로 제약 조건 참조</span><span class="sxs-lookup"><span data-stu-id="f6d02-1150">Route constraint reference</span></span>

<span data-ttu-id="f6d02-1151">경로 제약 조건은 들어오는 URL과 일치하고 URL 경로가 경로 값으로 토큰화되면 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1151">Route constraints execute when a match has occurred to the incoming URL and the URL path is tokenized into route values.</span></span> <span data-ttu-id="f6d02-1152">일반적으로 경로 제약 조건은 경로 템플릿을 통해 연결된 경로 값을 검사하고 값 허용 여부에 대한 예/아니요 의사 결정을 내립니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1152">Route constraints generally inspect the route value associated via the route template and make a yes/no decision about whether or not the value is acceptable.</span></span> <span data-ttu-id="f6d02-1153">일부 경로 제약 조건은 경로 값 외부의 데이터를 사용하여 요청을 라우팅할 수 있는지 여부를 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1153">Some route constraints use data outside the route value to consider whether the request can be routed.</span></span> <span data-ttu-id="f6d02-1154">예를 들어 <xref:Microsoft.AspNetCore.Routing.Constraints.HttpMethodRouteConstraint>는 해당 HTTP 동사에 따라 요청을 허용하거나 거부할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1154">For example, the <xref:Microsoft.AspNetCore.Routing.Constraints.HttpMethodRouteConstraint> can accept or reject a request based on its HTTP verb.</span></span> <span data-ttu-id="f6d02-1155">제약 조건은 라우팅 요청 및 링크 생성에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1155">Constraints are used in routing requests and link generation.</span></span>

> [!WARNING]
> <span data-ttu-id="f6d02-1156">제약 조건을 **입력 유효성 검사**에 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1156">Don't use constraints for **input validation**.</span></span> <span data-ttu-id="f6d02-1157">제약 조건이 **입력 유효성 검사**에 사용되는 경우 잘못된 입력으로 인해 적절한 오류 메시지와 함께 *400 - 잘못된 요청* 대신 *404 - 찾을 수 없음* 응답이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1157">If constraints are used for **input validation**, invalid input results in a *404 - Not Found* response instead of a *400 - Bad Request* with an appropriate error message.</span></span> <span data-ttu-id="f6d02-1158">경로 제약 조건은 특정 경로에 대한 입력의 유효성을 검사하는 것이 아니라 비슷한 경로를 **명확하게 구분하는 데** 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1158">Route constraints are used to **disambiguate** similar routes, not to validate the inputs for a particular route.</span></span>

<span data-ttu-id="f6d02-1159">다음 표에서는 경로 제약 조건 예제 및 예상되는 해당 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1159">The following table demonstrates example route constraints and their expected behavior.</span></span>

| <span data-ttu-id="f6d02-1160">제약 조건</span><span class="sxs-lookup"><span data-stu-id="f6d02-1160">constraint</span></span> | <span data-ttu-id="f6d02-1161">예제</span><span class="sxs-lookup"><span data-stu-id="f6d02-1161">Example</span></span> | <span data-ttu-id="f6d02-1162">일치하는 예제</span><span class="sxs-lookup"><span data-stu-id="f6d02-1162">Example Matches</span></span> | <span data-ttu-id="f6d02-1163">참고</span><span class="sxs-lookup"><span data-stu-id="f6d02-1163">Notes</span></span> |
| ---------- | ------- | --------------- | ----- |
| `int` | `{id:int}` | <span data-ttu-id="f6d02-1164">`123456789`, `-123456789`</span><span class="sxs-lookup"><span data-stu-id="f6d02-1164">`123456789`, `-123456789`</span></span> | <span data-ttu-id="f6d02-1165">임의의 정수와 일치</span><span class="sxs-lookup"><span data-stu-id="f6d02-1165">Matches any integer.</span></span> |
| `bool` | `{active:bool}` | <span data-ttu-id="f6d02-1166">`true`, `FALSE`</span><span class="sxs-lookup"><span data-stu-id="f6d02-1166">`true`, `FALSE`</span></span> | <span data-ttu-id="f6d02-1167">`true` 또는 \`false와 일치.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1167">Matches `true` or \`false.</span></span> <span data-ttu-id="f6d02-1168">대/소문자 구분하지 않음</span><span class="sxs-lookup"><span data-stu-id="f6d02-1168">Case-insensitive.</span></span> |
| `datetime` | `{dob:datetime}` | <span data-ttu-id="f6d02-1169">`2016-12-31`, `2016-12-31 7:32pm`</span><span class="sxs-lookup"><span data-stu-id="f6d02-1169">`2016-12-31`, `2016-12-31 7:32pm`</span></span> | <span data-ttu-id="f6d02-1170">유효한 `DateTime` 값 일치(고정 문화권에서)</span><span class="sxs-lookup"><span data-stu-id="f6d02-1170">Matches a valid `DateTime` value in the invariant culture.</span></span> <span data-ttu-id="f6d02-1171">이전 경고를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1171">See  preceding warning.</span></span>|
| `decimal` | `{price:decimal}` | <span data-ttu-id="f6d02-1172">`49.99`, `-1,000.01`</span><span class="sxs-lookup"><span data-stu-id="f6d02-1172">`49.99`, `-1,000.01`</span></span> | <span data-ttu-id="f6d02-1173">유효한 `decimal` 값 일치(고정 문화권에서)</span><span class="sxs-lookup"><span data-stu-id="f6d02-1173">Matches a valid `decimal` value in the invariant culture.</span></span> <span data-ttu-id="f6d02-1174">이전 경고를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1174">See  preceding warning.</span></span>|
| `double` | `{weight:double}` | <span data-ttu-id="f6d02-1175">`1.234`, `-1,001.01e8`</span><span class="sxs-lookup"><span data-stu-id="f6d02-1175">`1.234`, `-1,001.01e8`</span></span> | <span data-ttu-id="f6d02-1176">유효한 `double` 값 일치(고정 문화권에서)</span><span class="sxs-lookup"><span data-stu-id="f6d02-1176">Matches a valid `double` value in the invariant culture.</span></span> <span data-ttu-id="f6d02-1177">이전 경고를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1177">See  preceding warning.</span></span>|
| `float` | `{weight:float}` | <span data-ttu-id="f6d02-1178">`1.234`, `-1,001.01e8`</span><span class="sxs-lookup"><span data-stu-id="f6d02-1178">`1.234`, `-1,001.01e8`</span></span> | <span data-ttu-id="f6d02-1179">유효한 `float` 값 일치(고정 문화권에서)</span><span class="sxs-lookup"><span data-stu-id="f6d02-1179">Matches a valid `float` value in the invariant culture.</span></span> <span data-ttu-id="f6d02-1180">이전 경고를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1180">See  preceding warning.</span></span>|
| `guid` | `{id:guid}` | <span data-ttu-id="f6d02-1181">`CD2C1638-1638-72D5-1638-DEADBEEF1638`, `{CD2C1638-1638-72D5-1638-DEADBEEF1638}`</span><span class="sxs-lookup"><span data-stu-id="f6d02-1181">`CD2C1638-1638-72D5-1638-DEADBEEF1638`, `{CD2C1638-1638-72D5-1638-DEADBEEF1638}`</span></span> | <span data-ttu-id="f6d02-1182">유효한 `Guid` 값과 일치</span><span class="sxs-lookup"><span data-stu-id="f6d02-1182">Matches a valid `Guid` value.</span></span> |
| `long` | `{ticks:long}` | <span data-ttu-id="f6d02-1183">`123456789`, `-123456789`</span><span class="sxs-lookup"><span data-stu-id="f6d02-1183">`123456789`, `-123456789`</span></span> | <span data-ttu-id="f6d02-1184">유효한 `long` 값과 일치</span><span class="sxs-lookup"><span data-stu-id="f6d02-1184">Matches a valid `long` value.</span></span> |
| `minlength(value)` | `{username:minlength(4)}` | `Rick` | <span data-ttu-id="f6d02-1185">문자열은 4자 이상이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1185">String must be at least 4 characters.</span></span> |
| `maxlength(value)` | `{filename:maxlength(8)}` | `MyFile` | <span data-ttu-id="f6d02-1186">문자열의 최대 크기는 8자입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1186">String has maximum of 8 characters.</span></span> |
| `length(length)` | `{filename:length(12)}` | `somefile.txt` | <span data-ttu-id="f6d02-1187">문자열은 정확히 12자여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1187">String must be exactly 12 characters long.</span></span> |
| `length(min,max)` | `{filename:length(8,16)}` | `somefile.txt` | <span data-ttu-id="f6d02-1188">문자열은 8자 이상이어야 하며 최대 16자여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1188">String must be at least 8 and has maximum of 16 characters.</span></span> |
| `min(value)` | `{age:min(18)}` | `19` | <span data-ttu-id="f6d02-1189">정수 값은 18 이상이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1189">Integer value must be at least 18.</span></span> |
| `max(value)` | `{age:max(120)}` | `91` | <span data-ttu-id="f6d02-1190">정수 값의 최댓값은 120입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1190">Integer value maximum of 120.</span></span> |
| `range(min,max)` | `{age:range(18,120)}` | `91` | <span data-ttu-id="f6d02-1191">정수 값은 18 이상이고 최대값은 120이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1191">Integer value must be at least 18 and maximum of 120.</span></span> |
| `alpha` | `{name:alpha}` | `Rick` | <span data-ttu-id="f6d02-1192">문자열은 하나 이상의 영문자(`a`-`z`)로 구성되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1192">String must consist of one or more alphabetical characters `a`-`z`.</span></span>  <span data-ttu-id="f6d02-1193">대/소문자 구분하지 않음</span><span class="sxs-lookup"><span data-stu-id="f6d02-1193">Case-insensitive.</span></span> |
| `regex(expression)` | `{ssn:regex(^\\d{{3}}-\\d{{2}}-\\d{{4}}$)}` | `123-45-6789` | <span data-ttu-id="f6d02-1194">문자열은 정규식과 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1194">String must match the regular expression.</span></span> <span data-ttu-id="f6d02-1195">정규식을 정의하는 방법에 대한 팁을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1195">See tips about defining a regular expression.</span></span> |
| `required` | `{name:required}` | `Rick` | <span data-ttu-id="f6d02-1196">URL을 생성하는 동안 비-매개 변수 값이 존재하도록 강제하는 데 사용됨</span><span class="sxs-lookup"><span data-stu-id="f6d02-1196">Used to enforce that a non-parameter value is present during URL generation.</span></span> |

<span data-ttu-id="f6d02-1197">콜론으로 구분된 여러 개의 제약 조건을 단일 매개 변수에 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1197">Multiple, colon-delimited constraints can be applied to a single parameter.</span></span> <span data-ttu-id="f6d02-1198">예를 들어 다음 제약 조건은 매개 변수를 1 이상의 정수 값으로 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1198">For example, the following constraint restricts a parameter to an integer value of 1 or greater:</span></span>

```csharp
[Route("users/{id:int:min(1)}")]
public User GetUserById(int id) { }
```

> [!WARNING]
> <span data-ttu-id="f6d02-1199">CLR 형식(예: `int` 또는 `DateTime`)으로 변환되는 URL을 확인하는 경로 제약 조건은 항상 고정 문화권을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1199">Route constraints that verify the URL and are converted to a CLR type (such as `int` or `DateTime`) always use the invariant culture.</span></span> <span data-ttu-id="f6d02-1200">이러한 제약 조건은 URL은 지역화될 수 없다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1200">These constraints assume that the URL is non-localizable.</span></span> <span data-ttu-id="f6d02-1201">프레임워크에서 제공한 경로 제약 조건은 경로 값에 저장된 값을 수정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1201">The framework-provided route constraints don't modify the values stored in route values.</span></span> <span data-ttu-id="f6d02-1202">URL에서 구문 분석되는 모든 경로 값은 문자열로 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1202">All route values parsed from the URL are stored as strings.</span></span> <span data-ttu-id="f6d02-1203">예를 들어 `float` 제약 조건은 경로 값을 부동으로 변환하려고 하지만 변환된 값은 부동으로 변환될 수 있는지 확인하는 데만 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1203">For example, the `float` constraint attempts to convert the route value to a float, but the converted value is used only to verify it can be converted to a float.</span></span>

## <a name="regular-expressions"></a><span data-ttu-id="f6d02-1204">정규식</span><span class="sxs-lookup"><span data-stu-id="f6d02-1204">Regular expressions</span></span>

<span data-ttu-id="f6d02-1205">ASP.NET Core 프레임워크는 정규식 생성자에 `RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.CultureInvariant`를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1205">The ASP.NET Core framework adds `RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.CultureInvariant` to the regular expression constructor.</span></span> <span data-ttu-id="f6d02-1206">이러한 멤버에 대한 설명은 <xref:System.Text.RegularExpressions.RegexOptions>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1206">See <xref:System.Text.RegularExpressions.RegexOptions> for a description of these members.</span></span>

<span data-ttu-id="f6d02-1207">정규식은 라우팅 및 C# 언어에서 사용하는 것과 유사한 구분 기호 및 토큰을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1207">Regular expressions use delimiters and tokens similar to those used by routing and the C# language.</span></span> <span data-ttu-id="f6d02-1208">정규식 토큰은 이스케이프되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1208">Regular expression tokens must be escaped.</span></span> <span data-ttu-id="f6d02-1209">라우팅에서 정규식 `^\d{3}-\d{2}-\d{4}$`을 사용하려면:</span><span class="sxs-lookup"><span data-stu-id="f6d02-1209">To use the regular expression `^\d{3}-\d{2}-\d{4}$` in routing:</span></span>

* <span data-ttu-id="f6d02-1210">식에는 문자열에 제공된 단일 백슬래시 `\` 문자가 소스 코드의 이중 백슬래시 `\\` 문자로 포함되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1210">The expression must have the single backslash `\` characters provided in the string as double backslash `\\` characters in the source code.</span></span>
* <span data-ttu-id="f6d02-1211">정규식에서는 `\` 문자열 이스케이프 문자를 이스케이프하기 위해 `\\`를 사용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1211">The regular expression must us `\\` in order to escape the `\` string escape character.</span></span>
* <span data-ttu-id="f6d02-1212">정규식에서 [축자 문자열 리터럴](/dotnet/csharp/language-reference/keywords/string)을 사용하는 경우 `\\`가 필요하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1212">The regular expression doesn't require `\\` when using [verbatim string literals](/dotnet/csharp/language-reference/keywords/string).</span></span>

<span data-ttu-id="f6d02-1213">라우팅 매개 변수 구분 기호 문자(`{`, `}`, `[`, `]`)를 이스케이프하려면 식에서 해당 문자를 이중으로 사용합니다(`{{`, `}`, `[[`, `]]`).</span><span class="sxs-lookup"><span data-stu-id="f6d02-1213">To escape routing parameter delimiter characters `{`, `}`, `[`, `]`, double the characters in the expression `{{`, `}`, `[[`, `]]`.</span></span> <span data-ttu-id="f6d02-1214">다음 표는 정규식 및 이스케이프된 버전을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1214">The following table shows a regular expression and the escaped version:</span></span>

| <span data-ttu-id="f6d02-1215">정규식</span><span class="sxs-lookup"><span data-stu-id="f6d02-1215">Regular Expression</span></span>    | <span data-ttu-id="f6d02-1216">이스케이프된 정규식</span><span class="sxs-lookup"><span data-stu-id="f6d02-1216">Escaped Regular Expression</span></span>     |
| --------------------- | ------------------------------ |
| `^\d{3}-\d{2}-\d{4}$` | `^\\d{{3}}-\\d{{2}}-\\d{{4}}$` |
| `^[a-z]{2}$`          | `^[[a-z]]{{2}}$`               |

<span data-ttu-id="f6d02-1217">라우팅에 사용되는 정규식은 캐럿(`^`) 문자로 시작하고 문자열의 시작 위치와 일치하는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1217">Regular expressions used in routing often start with the caret `^` character and match starting position of the string.</span></span> <span data-ttu-id="f6d02-1218">식은 달러 기호(`$`) 문자로 끝나고 문자열의 끝과 일치하는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1218">The expressions often end with the dollar sign `$` character and match end of the string.</span></span> <span data-ttu-id="f6d02-1219">`^` 및 `$` 문자는 정규식이 전체 경로 매개 변수 값과 일치하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1219">The `^` and `$` characters ensure that the regular expression match the entire route parameter value.</span></span> <span data-ttu-id="f6d02-1220">`^` 및 `$` 문자가 없는 정규식은 문자열 내의 모든 하위 문자열과 일치하는데, 이는 종종 원하는 것이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1220">Without the `^` and `$` characters, the regular expression match any substring within the string, which is often undesirable.</span></span> <span data-ttu-id="f6d02-1221">다음 표에서는 예제를 제공하고, 일치하거나 일치에 실패하는 이유를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1221">The following table provides examples and explains why they match or fail to match.</span></span>

| <span data-ttu-id="f6d02-1222">식</span><span class="sxs-lookup"><span data-stu-id="f6d02-1222">Expression</span></span>   | <span data-ttu-id="f6d02-1223">String</span><span class="sxs-lookup"><span data-stu-id="f6d02-1223">String</span></span>    | <span data-ttu-id="f6d02-1224">일치</span><span class="sxs-lookup"><span data-stu-id="f6d02-1224">Match</span></span> | <span data-ttu-id="f6d02-1225">주석</span><span class="sxs-lookup"><span data-stu-id="f6d02-1225">Comment</span></span>               |
| ------------ | --------- | :---: |  -------------------- |
| `[a-z]{2}`   | <span data-ttu-id="f6d02-1226">hello</span><span class="sxs-lookup"><span data-stu-id="f6d02-1226">hello</span></span>     | <span data-ttu-id="f6d02-1227">예</span><span class="sxs-lookup"><span data-stu-id="f6d02-1227">Yes</span></span>   | <span data-ttu-id="f6d02-1228">부분 문자열 일치</span><span class="sxs-lookup"><span data-stu-id="f6d02-1228">Substring matches</span></span>     |
| `[a-z]{2}`   | <span data-ttu-id="f6d02-1229">123abc456</span><span class="sxs-lookup"><span data-stu-id="f6d02-1229">123abc456</span></span> | <span data-ttu-id="f6d02-1230">예</span><span class="sxs-lookup"><span data-stu-id="f6d02-1230">Yes</span></span>   | <span data-ttu-id="f6d02-1231">부분 문자열 일치</span><span class="sxs-lookup"><span data-stu-id="f6d02-1231">Substring matches</span></span>     |
| `[a-z]{2}`   | <span data-ttu-id="f6d02-1232">mz</span><span class="sxs-lookup"><span data-stu-id="f6d02-1232">mz</span></span>        | <span data-ttu-id="f6d02-1233">예</span><span class="sxs-lookup"><span data-stu-id="f6d02-1233">Yes</span></span>   | <span data-ttu-id="f6d02-1234">식 일치</span><span class="sxs-lookup"><span data-stu-id="f6d02-1234">Matches expression</span></span>    |
| `[a-z]{2}`   | <span data-ttu-id="f6d02-1235">MZ</span><span class="sxs-lookup"><span data-stu-id="f6d02-1235">MZ</span></span>        | <span data-ttu-id="f6d02-1236">예</span><span class="sxs-lookup"><span data-stu-id="f6d02-1236">Yes</span></span>   | <span data-ttu-id="f6d02-1237">대/소문자 구분하지 않음</span><span class="sxs-lookup"><span data-stu-id="f6d02-1237">Not case sensitive</span></span>    |
| `^[a-z]{2}$` | <span data-ttu-id="f6d02-1238">hello</span><span class="sxs-lookup"><span data-stu-id="f6d02-1238">hello</span></span>     | <span data-ttu-id="f6d02-1239">아니요</span><span class="sxs-lookup"><span data-stu-id="f6d02-1239">No</span></span>    | <span data-ttu-id="f6d02-1240">위의 `^` 및 `$` 참조</span><span class="sxs-lookup"><span data-stu-id="f6d02-1240">See `^` and `$` above</span></span> |
| `^[a-z]{2}$` | <span data-ttu-id="f6d02-1241">123abc456</span><span class="sxs-lookup"><span data-stu-id="f6d02-1241">123abc456</span></span> | <span data-ttu-id="f6d02-1242">아니요</span><span class="sxs-lookup"><span data-stu-id="f6d02-1242">No</span></span>    | <span data-ttu-id="f6d02-1243">위의 `^` 및 `$` 참조</span><span class="sxs-lookup"><span data-stu-id="f6d02-1243">See `^` and `$` above</span></span> |

<span data-ttu-id="f6d02-1244">정규식 구문에 대한 자세한 내용은 [.NET Framework 정규식](/dotnet/standard/base-types/regular-expression-language-quick-reference)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1244">For more information on regular expression syntax, see [.NET Framework Regular Expressions](/dotnet/standard/base-types/regular-expression-language-quick-reference).</span></span>

<span data-ttu-id="f6d02-1245">가능한 값의 알려진 집합으로 매개 변수를 제한하려면 정규식을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1245">To constrain a parameter to a known set of possible values, use a regular expression.</span></span> <span data-ttu-id="f6d02-1246">예를 들어 `{action:regex(^(list|get|create)$)}`는 `action` 경로 값을 `list`, `get` 또는 `create`으로만 일치시킵니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1246">For example, `{action:regex(^(list|get|create)$)}` only matches the `action` route value to `list`, `get`, or `create`.</span></span> <span data-ttu-id="f6d02-1247">제약 조건 사전으로 전달되면 `^(list|get|create)$` 문자열은 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1247">If passed into the constraints dictionary, the string `^(list|get|create)$` is equivalent.</span></span> <span data-ttu-id="f6d02-1248">알려진 제약 조건 중 하나와 일치하지 않는 제약 조건 사전(템플릿 내 인라인이 아님)에서 전달되는 제약 조건도 정규식으로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1248">Constraints that are passed in the constraints dictionary (not inline within a template) that don't match one of the known constraints are also treated as regular expressions.</span></span>

## <a name="custom-route-constraints"></a><span data-ttu-id="f6d02-1249">사용자 지정 경로 제약 조건</span><span class="sxs-lookup"><span data-stu-id="f6d02-1249">Custom route constraints</span></span>

<span data-ttu-id="f6d02-1250">기본 제공 경로 제약 조건 외에도 <xref:Microsoft.AspNetCore.Routing.IRouteConstraint> 인터페이스를 구현하여 사용자 지정 경로 제약 조건을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1250">In addition to the built-in route constraints, custom route constraints can be created by implementing the <xref:Microsoft.AspNetCore.Routing.IRouteConstraint> interface.</span></span> <span data-ttu-id="f6d02-1251"><xref:Microsoft.AspNetCore.Routing.IRouteConstraint> 인터페이스에는 제약 조건이 충족되는 경우 `true`를 반환하고 그렇지 않은 경우 `false`를 반환하는 `Match` 단일 메서드가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1251">The <xref:Microsoft.AspNetCore.Routing.IRouteConstraint> interface contains a single method, `Match`, which returns `true` if the constraint is satisfied and `false` otherwise.</span></span>

<span data-ttu-id="f6d02-1252">사용자 지정 <xref:Microsoft.AspNetCore.Routing.IRouteConstraint>를 사용하려면 앱의 서비스 컨테이너에 있는 앱의 <xref:Microsoft.AspNetCore.Routing.RouteOptions.ConstraintMap>에 경로 제약 조건 형식을 등록해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1252">To use a custom <xref:Microsoft.AspNetCore.Routing.IRouteConstraint>, the route constraint type must be registered with the app's <xref:Microsoft.AspNetCore.Routing.RouteOptions.ConstraintMap> in the app's service container.</span></span> <span data-ttu-id="f6d02-1253"><xref:Microsoft.AspNetCore.Routing.RouteOptions.ConstraintMap>은 경로 제약 조건 키를 해당 제약 조건의 유효성을 검사하는 <xref:Microsoft.AspNetCore.Routing.IRouteConstraint> 구현과 매핑하는 사전입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1253">A <xref:Microsoft.AspNetCore.Routing.RouteOptions.ConstraintMap> is a dictionary that maps route constraint keys to <xref:Microsoft.AspNetCore.Routing.IRouteConstraint> implementations that validate those constraints.</span></span> <span data-ttu-id="f6d02-1254">`Startup.ConfigureServices`에서 [services.AddRouting](xref:Microsoft.Extensions.DependencyInjection.RoutingServiceCollectionExtensions.AddRouting*) 호출의 일부로 또는 `services.Configure<RouteOptions>`를 사용하여 직접 <xref:Microsoft.AspNetCore.Routing.RouteOptions>를 구성하여 앱의 <xref:Microsoft.AspNetCore.Routing.RouteOptions.ConstraintMap>을 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1254">An app's <xref:Microsoft.AspNetCore.Routing.RouteOptions.ConstraintMap> can be updated in `Startup.ConfigureServices` either as part of a [services.AddRouting](xref:Microsoft.Extensions.DependencyInjection.RoutingServiceCollectionExtensions.AddRouting*) call or by configuring <xref:Microsoft.AspNetCore.Routing.RouteOptions> directly with `services.Configure<RouteOptions>`.</span></span> <span data-ttu-id="f6d02-1255">예를 들어:</span><span class="sxs-lookup"><span data-stu-id="f6d02-1255">For example:</span></span>

```csharp
services.AddRouting(options =>
{
    options.ConstraintMap.Add("customName", typeof(MyCustomConstraint));
});
```

<span data-ttu-id="f6d02-1256">이제 제약 조건 형식을 등록할 때 지정한 이름을 사용하여 일반적인 방식으로 제약 조건을 경로에 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1256">The constraint can then be applied to routes in the usual manner, using the name specified when registering the constraint type.</span></span> <span data-ttu-id="f6d02-1257">예를 들어:</span><span class="sxs-lookup"><span data-stu-id="f6d02-1257">For example:</span></span>

```csharp
[HttpGet("{id:customName}")]
public ActionResult<string> Get(string id)
```

## <a name="parameter-transformer-reference"></a><span data-ttu-id="f6d02-1258">매개 변수 변환기 참조</span><span class="sxs-lookup"><span data-stu-id="f6d02-1258">Parameter transformer reference</span></span>

<span data-ttu-id="f6d02-1259">매개 변수 변환기는:</span><span class="sxs-lookup"><span data-stu-id="f6d02-1259">Parameter transformers:</span></span>

* <span data-ttu-id="f6d02-1260"><xref:Microsoft.AspNetCore.Routing.Route>에 대한 링크를 생성할 때 실행합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1260">Execute when generating a link for a <xref:Microsoft.AspNetCore.Routing.Route>.</span></span>
* <span data-ttu-id="f6d02-1261">`Microsoft.AspNetCore.Routing.IOutboundParameterTransformer`를 구현해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1261">Implement `Microsoft.AspNetCore.Routing.IOutboundParameterTransformer`.</span></span>
* <span data-ttu-id="f6d02-1262"><xref:Microsoft.AspNetCore.Routing.RouteOptions.ConstraintMap>을 사용하여 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1262">Are configured using <xref:Microsoft.AspNetCore.Routing.RouteOptions.ConstraintMap>.</span></span>
* <span data-ttu-id="f6d02-1263">매개 변수의 경로 값을 가져와서 새 문자열 값으로 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1263">Take the parameter's route value and transform it to a new string value.</span></span>
* <span data-ttu-id="f6d02-1264">생성된 링크에서 변환된 값을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1264">Result in using the transformed value in the generated link.</span></span>

<span data-ttu-id="f6d02-1265">예를 들어, `Url.Action(new { article = "MyTestArticle" })`을 사용하는 경로 패턴 `blog\{article:slugify}`의 사용자 지정 `slugify` 매개 변수 변환기는 `blog\my-test-article`을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1265">For example, a custom `slugify` parameter transformer in route pattern `blog\{article:slugify}` with `Url.Action(new { article = "MyTestArticle" })` generates `blog\my-test-article`.</span></span>

<span data-ttu-id="f6d02-1266">경로 패턴에서 매개 변수 변환기를 사용하려면 먼저 `Startup.ConfigureServices`의 <xref:Microsoft.AspNetCore.Routing.RouteOptions.ConstraintMap>을 사용하여 구성합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1266">To use a parameter transformer in a route pattern, configure it first using <xref:Microsoft.AspNetCore.Routing.RouteOptions.ConstraintMap> in `Startup.ConfigureServices`:</span></span>

```csharp
services.AddRouting(options =>
{
    // Replace the type and the name used to refer to it with your own
    // IOutboundParameterTransformer implementation
    options.ConstraintMap["slugify"] = typeof(SlugifyParameterTransformer);
});
```

<span data-ttu-id="f6d02-1267">매개 변수 변환기는 프레임워크에 의해 사용되어 엔드포인트가 해결되는 URI를 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1267">Parameter transformers are used by the framework to transform the URI where an endpoint resolves.</span></span> <span data-ttu-id="f6d02-1268">예를 들어 ASP.NET Core MVC는 매개 변수 변환기를 사용하여 `area` , `controller` , `action` 및 `page`와 일치하도록 사용되는 경로 값을 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1268">For example, ASP.NET Core MVC uses parameter transformers to transform the route value used to match an `area`, `controller`, `action`, and `page`.</span></span>

```csharp
routes.MapRoute(
    name: "default",
    template: "{controller:slugify=Home}/{action:slugify=Index}/{id?}");
```

<span data-ttu-id="f6d02-1269">위의 경로를 사용하면 `SubscriptionManagementController.GetAll` 작업이 URI `/subscription-management/get-all`과 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1269">With the preceding route, the action `SubscriptionManagementController.GetAll` is matched with the URI `/subscription-management/get-all`.</span></span> <span data-ttu-id="f6d02-1270">매개 변수 변환기는 링크를 생성하는 데 사용되는 경로 값을 변경하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1270">A parameter transformer doesn't change the route values used to generate a link.</span></span> <span data-ttu-id="f6d02-1271">예를 들어 `Url.Action("GetAll", "SubscriptionManagement")`는 `/subscription-management/get-all`을 출력합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1271">For example, `Url.Action("GetAll", "SubscriptionManagement")` outputs `/subscription-management/get-all`.</span></span>

<span data-ttu-id="f6d02-1272">ASP.NET Core는 생성된 경로와 함께 매개 변수 변환기를 사용하기 위한 API 규칙을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1272">ASP.NET Core provides API conventions for using a parameter transformers with generated routes:</span></span>

* <span data-ttu-id="f6d02-1273">ASP.NET Core MVC에는 `Microsoft.AspNetCore.Mvc.ApplicationModels.RouteTokenTransformerConvention` API 규칙이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1273">ASP.NET Core MVC has the `Microsoft.AspNetCore.Mvc.ApplicationModels.RouteTokenTransformerConvention` API convention.</span></span> <span data-ttu-id="f6d02-1274">이 규칙은 앱의 모든 특성 경로에 지정된 매개 변수 변환기를 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1274">This convention applies a specified parameter transformer to all attribute routes in the app.</span></span> <span data-ttu-id="f6d02-1275">매개 변수 변환기는 특성 경로 토큰이 교체될 때 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1275">The parameter transformer transforms attribute route tokens as they are replaced.</span></span> <span data-ttu-id="f6d02-1276">자세한 내용은 [매개 변수 변환기를 사용하여 토큰 교체 사용자 지정](/aspnet/core/mvc/controllers/routing#use-a-parameter-transformer-to-customize-token-replacement)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1276">For more information, see [Use a parameter transformer to customize token replacement](/aspnet/core/mvc/controllers/routing#use-a-parameter-transformer-to-customize-token-replacement).</span></span>
* <span data-ttu-id="f6d02-1277">Razor Pages에는 `Microsoft.AspNetCore.Mvc.ApplicationModels.PageRouteTransformerConvention` API 규칙이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1277">Razor Pages has the `Microsoft.AspNetCore.Mvc.ApplicationModels.PageRouteTransformerConvention` API convention.</span></span> <span data-ttu-id="f6d02-1278">이 규칙은 자동으로 검색된 모든 Razor Pages에 지정된 매개 변수 변환기를 적용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1278">This convention applies a specified parameter transformer to all automatically discovered Razor Pages.</span></span> <span data-ttu-id="f6d02-1279">매개 변수 변환기는 Razor Pages 경로의 폴더와 파일 이름 부분을 변환합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1279">The parameter transformer transforms the folder and file name segments of Razor Pages routes.</span></span> <span data-ttu-id="f6d02-1280">자세한 내용은 [매개 변수 변환기를 사용하여 페이지 경로 사용자 지정](/aspnet/core/razor-pages/razor-pages-conventions#use-a-parameter-transformer-to-customize-page-routes)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1280">For more information, see [Use a parameter transformer to customize page routes](/aspnet/core/razor-pages/razor-pages-conventions#use-a-parameter-transformer-to-customize-page-routes).</span></span>

## <a name="url-generation-reference"></a><span data-ttu-id="f6d02-1281">URL 생성 참조</span><span class="sxs-lookup"><span data-stu-id="f6d02-1281">URL generation reference</span></span>

<span data-ttu-id="f6d02-1282">다음 예제에서는 경로 값의 사전 및 <xref:Microsoft.AspNetCore.Routing.RouteCollection>이 지정된 경로에 대한 링크를 생성하는 방법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1282">The following example shows how to generate a link to a route given a dictionary of route values and a <xref:Microsoft.AspNetCore.Routing.RouteCollection>.</span></span>

[!code-csharp[](routing/samples/2.x/RoutingSample/Startup.cs?name=snippet_Dictionary)]

<span data-ttu-id="f6d02-1283">위의 샘플 끝부분에서 생성된 <xref:Microsoft.AspNetCore.Routing.VirtualPathData.VirtualPath>는 `/package/create/123`입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1283">The <xref:Microsoft.AspNetCore.Routing.VirtualPathData.VirtualPath> generated at the end of the preceding sample is `/package/create/123`.</span></span> <span data-ttu-id="f6d02-1284">사전은 "Track Package Route" 템플릿인 `package/{operation}/{id}`의 `operation` 및 `id` 경로 값을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1284">The dictionary supplies the `operation` and `id` route values of the "Track Package Route" template, `package/{operation}/{id}`.</span></span> <span data-ttu-id="f6d02-1285">자세한 내용은 [라우팅 미들웨어 사용](#use-routing-middleware) 섹션의 샘플 코드 또는 [샘플 앱](https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/routing/samples)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1285">For details, see the sample code in the [Use Routing Middleware](#use-routing-middleware) section or the [sample app](https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/routing/samples).</span></span>

<span data-ttu-id="f6d02-1286"><xref:Microsoft.AspNetCore.Routing.VirtualPathContext> 생성자에 대한 두 번째 매개 변수는 *앰비언트 값*의 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1286">The second parameter to the <xref:Microsoft.AspNetCore.Routing.VirtualPathContext> constructor is a collection of *ambient values*.</span></span> <span data-ttu-id="f6d02-1287">개발자가 요청 컨텍스트 내에서 지정해야 하는 값의 수를 제한하므로 앰비언트 값은 사용하기 편리합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1287">Ambient values are convenient to use because they limit the number of values a developer must specify within a request context.</span></span> <span data-ttu-id="f6d02-1288">현재 요청의 현재 경로 값은 링크 생성에 대한 앰비언트 값으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1288">The current route values of the current request are considered ambient values for link generation.</span></span> <span data-ttu-id="f6d02-1289">ASP.NET Core MVC 앱의 `HomeController`에 대한 `About` 작업에서는 `Index` 작업에 연결하기 위해 컨트롤러 경로 값을 지정할 필요가 없으며, `Home`이라는 앰비언트 값이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1289">In an ASP.NET Core MVC app's `About` action of the `HomeController`, you don't need to specify the controller route value to link to the `Index` action&mdash;the ambient value of `Home` is used.</span></span>

<span data-ttu-id="f6d02-1290">매개 변수와 일치하지 않는 앰비언트 값은 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1290">Ambient values that don't match a parameter are ignored.</span></span> <span data-ttu-id="f6d02-1291">명시적으로 제공된 값이 앰비언트 값을 재정의하는 경우에도 앰비언트 값이 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1291">Ambient values are also ignored when an explicitly provided value overrides the ambient value.</span></span> <span data-ttu-id="f6d02-1292">URL에서 일치는 왼쪽에서 오른쪽으로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1292">Matching occurs from left to right in the URL.</span></span>

<span data-ttu-id="f6d02-1293">명시적으로 제공되지만 경로의 세그먼트와 일치하지 않는 값은 쿼리 문자열에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1293">Values explicitly provided but that don't match a segment of the route are added to the query string.</span></span> <span data-ttu-id="f6d02-1294">다음 표에서 경로 템플릿 `{controller}/{action}/{id?}`를 사용하는 경우 결과를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1294">The following table shows the result when using the route template `{controller}/{action}/{id?}`.</span></span>

| <span data-ttu-id="f6d02-1295">앰비언트 값</span><span class="sxs-lookup"><span data-stu-id="f6d02-1295">Ambient Values</span></span>                     | <span data-ttu-id="f6d02-1296">명시적 값</span><span class="sxs-lookup"><span data-stu-id="f6d02-1296">Explicit Values</span></span>                        | <span data-ttu-id="f6d02-1297">결과</span><span class="sxs-lookup"><span data-stu-id="f6d02-1297">Result</span></span>                  |
| ---------------------------------- | -------------------------------------- | ----------------------- |
| <span data-ttu-id="f6d02-1298">controller = "Home"</span><span class="sxs-lookup"><span data-stu-id="f6d02-1298">controller = "Home"</span></span>                | <span data-ttu-id="f6d02-1299">action = "About"</span><span class="sxs-lookup"><span data-stu-id="f6d02-1299">action = "About"</span></span>                       | `/Home/About`           |
| <span data-ttu-id="f6d02-1300">controller = "Home"</span><span class="sxs-lookup"><span data-stu-id="f6d02-1300">controller = "Home"</span></span>                | <span data-ttu-id="f6d02-1301">controller = "Order", action = "About"</span><span class="sxs-lookup"><span data-stu-id="f6d02-1301">controller = "Order", action = "About"</span></span> | `/Order/About`          |
| <span data-ttu-id="f6d02-1302">controller = "Home", color = "Red"</span><span class="sxs-lookup"><span data-stu-id="f6d02-1302">controller = "Home", color = "Red"</span></span> | <span data-ttu-id="f6d02-1303">action = "About"</span><span class="sxs-lookup"><span data-stu-id="f6d02-1303">action = "About"</span></span>                       | `/Home/About`           |
| <span data-ttu-id="f6d02-1304">controller = "Home"</span><span class="sxs-lookup"><span data-stu-id="f6d02-1304">controller = "Home"</span></span>                | <span data-ttu-id="f6d02-1305">action = "About", color = "Red"</span><span class="sxs-lookup"><span data-stu-id="f6d02-1305">action = "About", color = "Red"</span></span>        | `/Home/About?color=Red` |

<span data-ttu-id="f6d02-1306">경로에 매개 변수에 해당하지 않고 값이 명시적으로 제공된 기본값이 있는 경우 기본값과 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1306">If a route has a default value that doesn't correspond to a parameter and that value is explicitly provided, it must match the default value:</span></span>

```csharp
routes.MapRoute("blog_route", "blog/{*slug}",
    defaults: new { controller = "Blog", action = "ReadPost" });
```

<span data-ttu-id="f6d02-1307">`controller` 및 `action`에 대해 일치하는 값이 제공되는 경우에만 링크 생성에서 이 경로에 대한 링크를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1307">Link generation only generates a link for this route when the matching values for `controller` and `action` are provided.</span></span>

## <a name="complex-segments"></a><span data-ttu-id="f6d02-1308">복잡한 세그먼트</span><span class="sxs-lookup"><span data-stu-id="f6d02-1308">Complex segments</span></span>

<span data-ttu-id="f6d02-1309">복잡한 세그먼트(예: `[Route("/x{token}y")]`)는 non-greedy 방식으로 오른쪽에서 왼쪽으로 리터럴을 매칭하여 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1309">Complex segments (for example `[Route("/x{token}y")]`) are processed by matching up literals from right to left in a non-greedy way.</span></span> <span data-ttu-id="f6d02-1310">복잡한 세그먼트 일치 방법에 대한 자세한 설명은 [이 코드](https://github.com/dotnet/AspNetCore/blob/release/2.2/src/Http/Routing/src/Patterns/RoutePatternMatcher.cs#L293)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1310">See [this code](https://github.com/dotnet/AspNetCore/blob/release/2.2/src/Http/Routing/src/Patterns/RoutePatternMatcher.cs#L293) for a detailed explanation of how complex segments are matched.</span></span> <span data-ttu-id="f6d02-1311">[코드 샘플](https://github.com/dotnet/AspNetCore/blob/release/2.2/src/Http/Routing/src/Patterns/RoutePatternMatcher.cs#L293)은 ASP.NET Core에서 사용되지 않지만 복잡한 세그먼트에 대한 적절한 설명을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1311">The [code sample](https://github.com/dotnet/AspNetCore/blob/release/2.2/src/Http/Routing/src/Patterns/RoutePatternMatcher.cs#L293) is not used by ASP.NET Core, but it provides a good explanation of complex segments.</span></span>
<!-- While that code is no longer used by ASP.NET Core for complex segment matching, it provides a good match to the current algorithm. The [current code](https://github.com/dotnet/AspNetCore/blob/91514c9af7e0f4c44029b51f05a01c6fe4c96e4c/src/Http/Routing/src/Matching/DfaMatcherBuilder.cs#L227-L244) is too abstracted from matching to be useful for understanding complex segment matching.
-->

::: moniker-end

::: moniker range="< aspnetcore-2.2"

<span data-ttu-id="f6d02-1312">라우팅은 요청 URI를 경로 처리기에 매핑하고 들어오는 요청을 디스패치합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1312">Routing is responsible for mapping request URIs to route handlers and dispatching an incoming requests.</span></span> <span data-ttu-id="f6d02-1313">경로는 앱에서 정의되고 앱 시작 시 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1313">Routes are defined in the app and configured when the app starts.</span></span> <span data-ttu-id="f6d02-1314">경로는 요청에 포함된 URL에서 필요에 따라 값을 추출할 수 있으며 이러한 값은 요청 처리를 위해 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1314">A route can optionally extract values from the URL contained in the request, and these values can then be used for request processing.</span></span> <span data-ttu-id="f6d02-1315">라우팅은 앱에 구성된 경로를 사용하여 경로 처리기에 매핑되는 URL을 생성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1315">Using configured routes from the app, routing is able to generate URLs that map to route handlers.</span></span>

<span data-ttu-id="f6d02-1316">ASP.NET Core 2.1에서 최신 라우팅 시나리오를 사용하려면 `Startup.ConfigureServices`의 MVC 서비스 등록에 [호환성 버전](xref:mvc/compatibility-version)을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1316">To use the latest routing scenarios in ASP.NET Core 2.1, specify the [compatibility version](xref:mvc/compatibility-version) to the MVC services registration in `Startup.ConfigureServices`:</span></span>

```csharp
services.AddMvc()
    .SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
```

> [!IMPORTANT]
> <span data-ttu-id="f6d02-1317">이 문서에서는 낮은 수준의 ASP.NET Core 라우팅을 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1317">This document covers low-level ASP.NET Core routing.</span></span> <span data-ttu-id="f6d02-1318">ASP.NET Core MVC 라우팅에 대한 내용은 <xref:mvc/controllers/routing>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1318">For information on ASP.NET Core MVC routing, see <xref:mvc/controllers/routing>.</span></span> <span data-ttu-id="f6d02-1319">Razor Pages의 라우팅 규칙에 대한 내용은 <xref:razor-pages/razor-pages-conventions>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1319">For information on routing conventions in Razor Pages, see <xref:razor-pages/razor-pages-conventions>.</span></span>

<span data-ttu-id="f6d02-1320">[예제 코드 살펴보기 및 다운로드](https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/routing/samples) ([다운로드 방법](xref:index#how-to-download-a-sample))</span><span class="sxs-lookup"><span data-stu-id="f6d02-1320">[View or download sample code](https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/routing/samples) ([how to download](xref:index#how-to-download-a-sample))</span></span>

## <a name="routing-basics"></a><span data-ttu-id="f6d02-1321">라우팅 기본 사항</span><span class="sxs-lookup"><span data-stu-id="f6d02-1321">Routing basics</span></span>

<span data-ttu-id="f6d02-1322">대부분의 앱은 URL을 읽을 수 있고 의미를 담고 있도록 기본적이고 서술적인 라우팅 체계를 선택해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1322">Most apps should choose a basic and descriptive routing scheme so that URLs are readable and meaningful.</span></span> <span data-ttu-id="f6d02-1323">기본 기존 경로인 `{controller=Home}/{action=Index}/{id?}`는:</span><span class="sxs-lookup"><span data-stu-id="f6d02-1323">The default conventional route `{controller=Home}/{action=Index}/{id?}`:</span></span>

* <span data-ttu-id="f6d02-1324">기본적이고 서술적인 라우팅 체계를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1324">Supports a basic and descriptive routing scheme.</span></span>
* <span data-ttu-id="f6d02-1325">UI 기반 앱에 대한 유용한 시작점입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1325">Is a useful starting point for UI-based apps.</span></span>

<span data-ttu-id="f6d02-1326">일반적으로 개발자는 [특성 라우팅](xref:mvc/controllers/routing#attribute-routing) 또는 전용 기존 경로를 사용하여 특수한 상황에서 앱의 트래픽이 높은 영역(예: 블로그 및 전자 상거래 엔드포인트)에 간결한 추가 경로를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1326">Developers commonly add additional terse routes to high-traffic areas of an app in specialized situations (for example, blog and ecommerce endpoints) using [attribute routing](xref:mvc/controllers/routing#attribute-routing) or dedicated conventional routes.</span></span>

<span data-ttu-id="f6d02-1327">Web API는 특성 라우팅을 사용하여 작업이 HTTP 동사로 표현되는 리소스 집합으로 앱의 기능을 모델링해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1327">Web APIs should use attribute routing to model the app's functionality as a set of resources where operations are represented by HTTP verbs.</span></span> <span data-ttu-id="f6d02-1328">이는 동일한 논리 리소스의 많은 작업(예: GET, POST)이 동일한 URL을 사용한다는 뜻입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1328">This means that many operations (for example, GET, POST) on the same logical resource will use the same URL.</span></span> <span data-ttu-id="f6d02-1329">특성 라우팅은 API의 공개 엔드포인트 레이아웃을 신중하게 설계하는 데 필요한 제어 수준을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1329">Attribute routing provides a level of control that's needed to carefully design an API's public endpoint layout.</span></span>

<span data-ttu-id="f6d02-1330">Razor Pages 앱은 기본 기존 라우팅을 사용하여 앱의 *Pages* 폴더에서 명명된 리소스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1330">Razor Pages apps use default conventional routing to serve named resources in the *Pages* folder of an app.</span></span> <span data-ttu-id="f6d02-1331">Razor Pages 라우팅 동작을 사용자 지정할 수 있는 추가 규칙을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1331">Additional conventions are available that allow you to customize Razor Pages routing behavior.</span></span> <span data-ttu-id="f6d02-1332">자세한 내용은 <xref:razor-pages/index> 및 <xref:razor-pages/razor-pages-conventions>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1332">For more information, see <xref:razor-pages/index> and <xref:razor-pages/razor-pages-conventions>.</span></span>

<span data-ttu-id="f6d02-1333">URL 생성 지원을 사용하면 URL을 하드 코딩하지 않고 앱을 개발하여 앱을 서로 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1333">URL generation support allows the app to be developed without hard-coding URLs to link the app together.</span></span> <span data-ttu-id="f6d02-1334">이 지원을 사용하면 기본 라우팅 구성으로 시작하고 앱의 리소스 레이아웃이 결정된 후에 해당 경로를 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1334">This support allows for starting with a basic routing configuration and modifying the routes after the app's resource layout is determined.</span></span>

<span data-ttu-id="f6d02-1335">라우팅은 <xref:Microsoft.AspNetCore.Routing.IRouter>의 경로 구현을 사용하여 다음 작업을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1335">Routing uses routes implementations of <xref:Microsoft.AspNetCore.Routing.IRouter> to:</span></span>

* <span data-ttu-id="f6d02-1336">들어오는 요청을 *경로 처리기*에 매핑합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1336">Map incoming requests to *route handlers*.</span></span>
* <span data-ttu-id="f6d02-1337">응답에 사용되는 URL을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1337">Generate the URLs used in responses.</span></span>

<span data-ttu-id="f6d02-1338">기본적으로 앱에는 단일 경로 컬렉션이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1338">By default, an app has a single collection of routes.</span></span> <span data-ttu-id="f6d02-1339">요청이 도착하면 컬렉션의 경로가 컬렉션에 존재하는 순서대로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1339">When a request arrives, the routes in the collection are processed in the order that they exist in the collection.</span></span> <span data-ttu-id="f6d02-1340">프레임워크는 컬렉션의 각 경로에서 <xref:Microsoft.AspNetCore.Routing.IRouter.RouteAsync*> 메서드를 호출하여 들어오는 요청 URL을 컬렉션의 경로와 일치시키려고 시도합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1340">The framework attempts to match an incoming request URL to a route in the collection by calling the <xref:Microsoft.AspNetCore.Routing.IRouter.RouteAsync*> method on each route in the collection.</span></span> <span data-ttu-id="f6d02-1341">응답은 라우팅을 사용하여 경로 정보에 따라 URL을 생성(예: 리디렉션 또는 링크)하므로 하드 코딩된 URL을 방지하여 유지 관리에 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1341">A response can use routing to generate URLs (for example, for redirection or links) based on route information and thus avoid hard-coded URLs, which helps maintainability.</span></span>

<span data-ttu-id="f6d02-1342">라우팅 시스템에는 다음과 같은 특징이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1342">The routing system has the following characteristics:</span></span>

* <span data-ttu-id="f6d02-1343">경로 템플릿 구문은 토큰화된 경로 매개 변수를 사용하여 경로를 정의하는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1343">Route template syntax is used to define routes with tokenized route parameters.</span></span>
* <span data-ttu-id="f6d02-1344">기본 방식 스타일 및 특성 스타일 엔드포인트 구성이 허용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1344">Conventional-style and attribute-style endpoint configuration is permitted.</span></span>
* <span data-ttu-id="f6d02-1345"><xref:Microsoft.AspNetCore.Routing.IRouteConstraint>는 URL 매개 변수가 지정한 엔드포인트 제약 조건에 대해 유효한 값을 포함하고 있는지 알아내는 데 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1345"><xref:Microsoft.AspNetCore.Routing.IRouteConstraint> is used to determine whether a URL parameter contains a valid value for a given endpoint constraint.</span></span>
* <span data-ttu-id="f6d02-1346">MVC/Razor Pages와 같은 앱 모델은 라우팅 시나리오의 예측 가능한 구현을 가진 모든 경로를 등록합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1346">App models, such as MVC/Razor Pages, register all of their routes, which have a predictable implementation of routing scenarios.</span></span>
* <span data-ttu-id="f6d02-1347">응답은 라우팅을 사용하여 경로 정보에 따라 URL을 생성(예: 리디렉션 또는 링크)하므로 하드 코딩된 URL을 방지하여 유지 관리에 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1347">A response can use routing to generate URLs (for example, for redirection or links) based on route information and thus avoid hard-coded URLs, which helps maintainability.</span></span>
* <span data-ttu-id="f6d02-1348">URL 생성은 임의의 확장성을 지원하는 경로를 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1348">URL generation is based on routes, which support arbitrary extensibility.</span></span> <span data-ttu-id="f6d02-1349"><xref:Microsoft.AspNetCore.Mvc.IUrlHelper>는 URL을 작성하는 메서드를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1349"><xref:Microsoft.AspNetCore.Mvc.IUrlHelper> offers methods to build URLs.</span></span>
<!-- fix [middleware](xref:fundamentals/middleware/index) -->
<span data-ttu-id="f6d02-1350">라우팅은 <xref:Microsoft.AspNetCore.Builder.RouterMiddleware> 클래스에 의해 [미들웨어](xref:fundamentals/middleware/index) 파이프라인에 연결되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1350">Routing is connected to the [middleware](xref:fundamentals/middleware/index) pipeline by the <xref:Microsoft.AspNetCore.Builder.RouterMiddleware> class.</span></span> <span data-ttu-id="f6d02-1351">[ASP.NET Core MVC](xref:mvc/overview)는 라우팅을 해당 구성의 일부로 미들웨어 파이프라인에 추가하고, MVC 및 Razor Pages 앱에서 라우팅을 처리합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1351">[ASP.NET Core MVC](xref:mvc/overview) adds routing to the middleware pipeline as part of its configuration and handles routing in MVC and Razor Pages apps.</span></span> <span data-ttu-id="f6d02-1352">라우팅을 독립 실행형 구성 요소로 사용하는 방법을 알아보려면 [라우팅 미들웨어 사용](#use-routing-middleware) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1352">To learn how to use routing as a standalone component, see the [Use Routing Middleware](#use-routing-middleware) section.</span></span>

### <a name="url-matching"></a><span data-ttu-id="f6d02-1353">URL 일치</span><span class="sxs-lookup"><span data-stu-id="f6d02-1353">URL matching</span></span>

<span data-ttu-id="f6d02-1354">URL 일치는 라우팅이 들어오는 요청을 *처리기*로 디스패치하는 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1354">URL matching is the process by which routing dispatches an incoming request to a *handler*.</span></span> <span data-ttu-id="f6d02-1355">이 프로세스는 URL 경로의 데이터를 기반으로 하지만 요청에 있는 모든 데이터를 고려하도록 확장될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1355">This process is based on data in the URL path but can be extended to consider any data in the request.</span></span> <span data-ttu-id="f6d02-1356">요청을 별도의 처리기로 디스패치하는 기능은 앱의 크기와 복잡성을 확장하는 핵심입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1356">The ability to dispatch requests to separate handlers is key to scaling the size and complexity of an app.</span></span>

<span data-ttu-id="f6d02-1357">들어오는 요청이 <xref:Microsoft.AspNetCore.Builder.RouterMiddleware>에 진입하면 순차적으로 각 경로의 <xref:Microsoft.AspNetCore.Routing.IRouter.RouteAsync*> 메서드를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1357">Incoming requests enter the <xref:Microsoft.AspNetCore.Builder.RouterMiddleware>, which calls the <xref:Microsoft.AspNetCore.Routing.IRouter.RouteAsync*> method on each route in sequence.</span></span> <span data-ttu-id="f6d02-1358"><xref:Microsoft.AspNetCore.Routing.IRouter> 인스턴스는 [RouteContext.Handler](xref:Microsoft.AspNetCore.Routing.RouteContext.Handler*)를 null이 아닌 <xref:Microsoft.AspNetCore.Http.RequestDelegate>로 설정하여 요청을 *처리*할지 여부를 선택합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1358">The <xref:Microsoft.AspNetCore.Routing.IRouter> instance chooses whether to *handle* the request by setting the [RouteContext.Handler](xref:Microsoft.AspNetCore.Routing.RouteContext.Handler*) to a non-null <xref:Microsoft.AspNetCore.Http.RequestDelegate>.</span></span> <span data-ttu-id="f6d02-1359">경로가 요청에 대한 처리기를 설정하는 경우 경로 처리가 중지되고 해당 처리기가 요청을 처리하기 위해 호출됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1359">If a route sets a handler for the request, route processing stops, and the handler is invoked to process the request.</span></span> <span data-ttu-id="f6d02-1360">요청을 처리할 경로 처리기가 없는 경우 미들웨어는 요청을 요청 파이프라인의 다음 미들웨어에 전달합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1360">If no route handler is found to process the request, the middleware hands the request off to the next middleware in the request pipeline.</span></span>

<span data-ttu-id="f6d02-1361"><xref:Microsoft.AspNetCore.Routing.IRouter.RouteAsync*>에 대한 기본 입력은 현재 요청과 연결된 [RouteContext.HttpContext](xref:Microsoft.AspNetCore.Routing.RouteContext.HttpContext*)입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1361">The primary input to <xref:Microsoft.AspNetCore.Routing.IRouter.RouteAsync*> is the [RouteContext.HttpContext](xref:Microsoft.AspNetCore.Routing.RouteContext.HttpContext*) associated with the current request.</span></span> <span data-ttu-id="f6d02-1362">[RouteContext.Handler](xref:Microsoft.AspNetCore.Routing.RouteContext.Handler) 및 [RouteContext.RouteData](xref:Microsoft.AspNetCore.Routing.RouteContext.RouteData*)는 경로가 일치된 후에 설정되는 출력입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1362">The [RouteContext.Handler](xref:Microsoft.AspNetCore.Routing.RouteContext.Handler) and [RouteContext.RouteData](xref:Microsoft.AspNetCore.Routing.RouteContext.RouteData*) are outputs set after a route is matched.</span></span>

<span data-ttu-id="f6d02-1363"><xref:Microsoft.AspNetCore.Routing.IRouter.RouteAsync*>를 호출하는 일치는 [RouteContext.RouteData](xref:Microsoft.AspNetCore.Routing.RouteContext.RouteData)의 속성도 지금까지 수행된 요청 처리에 따라 적절한 값으로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1363">A match that calls <xref:Microsoft.AspNetCore.Routing.IRouter.RouteAsync*> also sets the properties of the [RouteContext.RouteData](xref:Microsoft.AspNetCore.Routing.RouteContext.RouteData) to appropriate values based on the request processing performed thus far.</span></span>

<span data-ttu-id="f6d02-1364">[RouteData.Values](xref:Microsoft.AspNetCore.Routing.RouteData.Values*)는 경로에서 생성된 *경로 값*의 사전입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1364">[RouteData.Values](xref:Microsoft.AspNetCore.Routing.RouteData.Values*) is a dictionary of *route values* produced from the route.</span></span> <span data-ttu-id="f6d02-1365">이러한 값은 일반적으로 URL을 토큰화하여 결정되고, 사용자 입력을 수락하거나 앱 내부의 추가 디스패치 결정을 내리는 데 사용될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1365">These values are usually determined by tokenizing the URL and can be used to accept user input or to make further dispatching decisions inside the app.</span></span>

<span data-ttu-id="f6d02-1366">[RouteData.DataTokens](xref:Microsoft.AspNetCore.Routing.RouteData.DataTokens*)는 일치하는 경로와 관련된 추가 데이터의 속성 모음입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1366">[RouteData.DataTokens](xref:Microsoft.AspNetCore.Routing.RouteData.DataTokens*) is a property bag of additional data related to the matched route.</span></span> <span data-ttu-id="f6d02-1367"><xref:Microsoft.AspNetCore.Routing.RouteData.DataTokens*>는 앱에서 일치된 경로에 따라 결정할 수 있도록 각 경로와 상태 데이터의 연결을 지원하기 위해 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1367"><xref:Microsoft.AspNetCore.Routing.RouteData.DataTokens*> are provided to support associating state data with each route so that the app can make decisions based on which route matched.</span></span> <span data-ttu-id="f6d02-1368">이러한 값은 개발자 정의되고 어떤 방식으로든 라우팅의 동작에 영향을 주지 **않습니다**.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1368">These values are developer-defined and do **not** affect the behavior of routing in any way.</span></span> <span data-ttu-id="f6d02-1369">또한 [RouteData.DataTokens](xref:Microsoft.AspNetCore.Routing.RouteData.DataTokens*)에 안전하게 배치되는(stashed) 값은 [RouteData.Values](xref:Microsoft.AspNetCore.Routing.RouteData.Values)와는 달리 문자열 간에 변환될 수 있어야 하는 모든 형식일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1369">Additionally, values stashed in [RouteData.DataTokens](xref:Microsoft.AspNetCore.Routing.RouteData.DataTokens*) can be of any type, in contrast to [RouteData.Values](xref:Microsoft.AspNetCore.Routing.RouteData.Values), which must be convertible to and from strings.</span></span>

<span data-ttu-id="f6d02-1370">[RouteData.Routers](xref:Microsoft.AspNetCore.Routing.RouteData.Routers)는 요청을 성공적으로 일치하는 데 참여한 경로의 목록입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1370">[RouteData.Routers](xref:Microsoft.AspNetCore.Routing.RouteData.Routers) is a list of the routes that took part in successfully matching the request.</span></span> <span data-ttu-id="f6d02-1371">경로는 서로 중첩될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1371">Routes can be nested inside of one another.</span></span> <span data-ttu-id="f6d02-1372"><xref:Microsoft.AspNetCore.Routing.RouteData.Routers> 속성은 일치한 경로의 논리 트리를 통해 경로를 반영합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1372">The <xref:Microsoft.AspNetCore.Routing.RouteData.Routers> property reflects the path through the logical tree of routes that resulted in a match.</span></span> <span data-ttu-id="f6d02-1373">일반적으로 <xref:Microsoft.AspNetCore.Routing.RouteData.Routers>의 첫 번째 항목은 경로 컬렉션이며 URL 생성을 위해 사용되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1373">Generally, the first item in <xref:Microsoft.AspNetCore.Routing.RouteData.Routers> is the route collection and should be used for URL generation.</span></span> <span data-ttu-id="f6d02-1374"><xref:Microsoft.AspNetCore.Routing.RouteData.Routers>의 마지막 항목은 일치한 경로 처리기입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1374">The last item in <xref:Microsoft.AspNetCore.Routing.RouteData.Routers> is the route handler that matched.</span></span>

<a name="lg"></a>

### <a name="url-generation"></a><span data-ttu-id="f6d02-1375">URL 생성</span><span class="sxs-lookup"><span data-stu-id="f6d02-1375">URL generation</span></span>

<span data-ttu-id="f6d02-1376">URL 생성은 라우팅이 경로 값의 집합을 기반으로 하는 URL 경로를 만들 수 있는 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1376">URL generation is the process by which routing can create a URL path based on a set of route values.</span></span> <span data-ttu-id="f6d02-1377">이렇게 하면 경로 처리기와 이에 액세스하는 URL을 논리적으로 구분할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1377">This allows for a logical separation between route handlers and the URLs that access them.</span></span>

<span data-ttu-id="f6d02-1378">URL 생성은 비슷한 반복적인 프로세스를 따르지만 경로 컬렉션의 <xref:Microsoft.AspNetCore.Routing.IRouter.GetVirtualPath*> 메서드로 호출하는 사용자 또는 프레임워크 코드로 시작합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1378">URL generation follows a similar iterative process, but it starts with user or framework code calling into the <xref:Microsoft.AspNetCore.Routing.IRouter.GetVirtualPath*> method of the route collection.</span></span> <span data-ttu-id="f6d02-1379">각 *경로*에는 null이 아닌 <xref:Microsoft.AspNetCore.Routing.VirtualPathData>가 반환될 때까지 순차적으로 호출되는 <xref:Microsoft.AspNetCore.Routing.IRouter.GetVirtualPath*> 메서드가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1379">Each *route* has its <xref:Microsoft.AspNetCore.Routing.IRouter.GetVirtualPath*> method called in sequence until a non-null <xref:Microsoft.AspNetCore.Routing.VirtualPathData> is returned.</span></span>

<span data-ttu-id="f6d02-1380"><xref:Microsoft.AspNetCore.Routing.IRouter.GetVirtualPath*>에 대한 기본 입력은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1380">The primary inputs to <xref:Microsoft.AspNetCore.Routing.IRouter.GetVirtualPath*> are:</span></span>

* [<span data-ttu-id="f6d02-1381">VirtualPathContext.HttpContext</span><span class="sxs-lookup"><span data-stu-id="f6d02-1381">VirtualPathContext.HttpContext</span></span>](xref:Microsoft.AspNetCore.Routing.VirtualPathContext.HttpContext)
* [<span data-ttu-id="f6d02-1382">VirtualPathContext.Values</span><span class="sxs-lookup"><span data-stu-id="f6d02-1382">VirtualPathContext.Values</span></span>](xref:Microsoft.AspNetCore.Routing.VirtualPathContext.Values)
* [<span data-ttu-id="f6d02-1383">VirtualPathContext.AmbientValues</span><span class="sxs-lookup"><span data-stu-id="f6d02-1383">VirtualPathContext.AmbientValues</span></span>](xref:Microsoft.AspNetCore.Routing.VirtualPathContext.AmbientValues)

<span data-ttu-id="f6d02-1384">경로는 주로 <xref:Microsoft.AspNetCore.Routing.VirtualPathContext.Values> 및 <xref:Microsoft.AspNetCore.Routing.VirtualPathContext.AmbientValues>에서 제공하는 경로 값을 사용하여 URL을 생성할 수 있는지 여부와 포함할 값을 결정합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1384">Routes primarily use the route values provided by <xref:Microsoft.AspNetCore.Routing.VirtualPathContext.Values> and <xref:Microsoft.AspNetCore.Routing.VirtualPathContext.AmbientValues> to decide whether it's possible to generate a URL and what values to include.</span></span> <span data-ttu-id="f6d02-1385"><xref:Microsoft.AspNetCore.Routing.VirtualPathContext.AmbientValues>는 현재 요청 일치로부터 생성된 경로 값의 세트입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1385">The <xref:Microsoft.AspNetCore.Routing.VirtualPathContext.AmbientValues> are the set of route values that were produced from matching the current request.</span></span> <span data-ttu-id="f6d02-1386">반면, <xref:Microsoft.AspNetCore.Routing.VirtualPathContext.Values>는 현재 작업에 대한 원하는 URL을 생성하는 방법을 지정하는 경로 값입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1386">In contrast, <xref:Microsoft.AspNetCore.Routing.VirtualPathContext.Values> are the route values that specify how to generate the desired URL for the current operation.</span></span> <span data-ttu-id="f6d02-1387"><xref:Microsoft.AspNetCore.Routing.VirtualPathContext.HttpContext>는 경로가 서비스 또는 현재 컨텍스트와 연결된 추가 데이터를 가져와야 하는 경우에 제공됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1387">The <xref:Microsoft.AspNetCore.Routing.VirtualPathContext.HttpContext> is provided in case a route should obtain services or additional data associated with the current context.</span></span>

> [!TIP]
> <span data-ttu-id="f6d02-1388">[VirtualPathContext.Values](xref:Microsoft.AspNetCore.Routing.VirtualPathContext.Values*)를 [VirtualPathContext.AmbientValues](xref:Microsoft.AspNetCore.Routing.VirtualPathContext.AmbientValues*)에 대한 재정의 세트로 간주하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1388">Think of [VirtualPathContext.Values](xref:Microsoft.AspNetCore.Routing.VirtualPathContext.Values*) as a set of overrides for the [VirtualPathContext.AmbientValues](xref:Microsoft.AspNetCore.Routing.VirtualPathContext.AmbientValues*).</span></span> <span data-ttu-id="f6d02-1389">URL 생성은 동일한 경로 또는 경로 값을 사용하는 링크에 대한 URL을 생성하기 위해 현재 요청의 경로 값을 다시 사용하려고 시도합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1389">URL generation attempts to reuse route values from the current request to generate URLs for links using the same route or route values.</span></span>

<span data-ttu-id="f6d02-1390"><xref:Microsoft.AspNetCore.Routing.IRouter.GetVirtualPath*>의 출력은 <xref:Microsoft.AspNetCore.Routing.VirtualPathData>입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1390">The output of <xref:Microsoft.AspNetCore.Routing.IRouter.GetVirtualPath*> is a <xref:Microsoft.AspNetCore.Routing.VirtualPathData>.</span></span> <span data-ttu-id="f6d02-1391"><xref:Microsoft.AspNetCore.Routing.VirtualPathData>는 <xref:Microsoft.AspNetCore.Routing.RouteData>와 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1391"><xref:Microsoft.AspNetCore.Routing.VirtualPathData> is a parallel of <xref:Microsoft.AspNetCore.Routing.RouteData>.</span></span> <span data-ttu-id="f6d02-1392"><xref:Microsoft.AspNetCore.Routing.VirtualPathData>는 출력 URL 및 경로에 의해 설정되어야 하는 몇 가지 추가 속성에 대한 <xref:Microsoft.AspNetCore.Routing.VirtualPathData.VirtualPath>를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1392"><xref:Microsoft.AspNetCore.Routing.VirtualPathData> contains the <xref:Microsoft.AspNetCore.Routing.VirtualPathData.VirtualPath> for the output URL and some additional properties that should be set by the route.</span></span>

<span data-ttu-id="f6d02-1393">[VirtualPathData.VirtualPath](xref:Microsoft.AspNetCore.Routing.VirtualPathData.VirtualPath*) 속성은 경로에 의해 생성된 *가상 경로*를 포함합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1393">The [VirtualPathData.VirtualPath](xref:Microsoft.AspNetCore.Routing.VirtualPathData.VirtualPath*) property contains the *virtual path* produced by the route.</span></span> <span data-ttu-id="f6d02-1394">필요에 따라 경로를 추가로 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1394">Depending on your needs, you may need to process the path further.</span></span> <span data-ttu-id="f6d02-1395">HTML에서 생성된 URL을 렌더링하려는 경우 앱의 기본 경로를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1395">If you want to render the generated URL in HTML, prepend the base path of the app.</span></span>

<span data-ttu-id="f6d02-1396">[VirtualPathData.Router](xref:Microsoft.AspNetCore.Routing.VirtualPathData.Router*)는 성공적으로 URL을 생성한 경로에 대한 참조입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1396">The [VirtualPathData.Router](xref:Microsoft.AspNetCore.Routing.VirtualPathData.Router*) is a reference to the route that successfully generated the URL.</span></span>

<span data-ttu-id="f6d02-1397">[VirtualPathData.DataTokens](xref:Microsoft.AspNetCore.Routing.VirtualPathData.DataTokens*) 속성은 URL을 생성한 경로와 관련된 추가 데이터의 사전입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1397">The [VirtualPathData.DataTokens](xref:Microsoft.AspNetCore.Routing.VirtualPathData.DataTokens*) properties is a dictionary of additional data related to the route that generated the URL.</span></span> <span data-ttu-id="f6d02-1398">이 속성은 [RouteData.DataTokens](xref:Microsoft.AspNetCore.Routing.RouteData.DataTokens*)와 유사합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1398">This is the parallel of [RouteData.DataTokens](xref:Microsoft.AspNetCore.Routing.RouteData.DataTokens*).</span></span>

### <a name="create-routes"></a><span data-ttu-id="f6d02-1399">경로 만들기</span><span class="sxs-lookup"><span data-stu-id="f6d02-1399">Create routes</span></span>

<span data-ttu-id="f6d02-1400">라우팅은 <xref:Microsoft.AspNetCore.Routing.IRouter>의 표준 구현으로 <xref:Microsoft.AspNetCore.Routing.Route> 클래스를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1400">Routing provides the <xref:Microsoft.AspNetCore.Routing.Route> class as the standard implementation of <xref:Microsoft.AspNetCore.Routing.IRouter>.</span></span> <span data-ttu-id="f6d02-1401"><xref:Microsoft.AspNetCore.Routing.Route>는 *경로 템플릿* 구문을 사용하여 <xref:Microsoft.AspNetCore.Routing.IRouter.RouteAsync*>가 호출될 때 URL 경로와 일치하는 패턴을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1401"><xref:Microsoft.AspNetCore.Routing.Route> uses the *route template* syntax to define patterns to match against the URL path when <xref:Microsoft.AspNetCore.Routing.IRouter.RouteAsync*> is called.</span></span> <span data-ttu-id="f6d02-1402"><xref:Microsoft.AspNetCore.Routing.Route>는 동일한 경로 템플릿을 사용하여 <xref:Microsoft.AspNetCore.Routing.IRouter.GetVirtualPath*>가 호출되었을 때 URL을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1402"><xref:Microsoft.AspNetCore.Routing.Route> uses the same route template to generate a URL when <xref:Microsoft.AspNetCore.Routing.IRouter.GetVirtualPath*> is called.</span></span>

<span data-ttu-id="f6d02-1403">대부분의 앱은 <xref:Microsoft.AspNetCore.Builder.MapRouteRouteBuilderExtensions.MapRoute*> 또는 <xref:Microsoft.AspNetCore.Routing.IRouteBuilder>에 정의된 유사한 확장 메서드 중 하나를 호출하여 경로를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1403">Most apps create routes by calling <xref:Microsoft.AspNetCore.Builder.MapRouteRouteBuilderExtensions.MapRoute*> or one of the similar extension methods defined on <xref:Microsoft.AspNetCore.Routing.IRouteBuilder>.</span></span> <span data-ttu-id="f6d02-1404">모든 <xref:Microsoft.AspNetCore.Routing.IRouteBuilder> 확장 메서드는 <xref:Microsoft.AspNetCore.Routing.Route>의 인스턴스를 만들고, 경로 컬렉션에 이를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1404">Any of the <xref:Microsoft.AspNetCore.Routing.IRouteBuilder> extension methods create an instance of <xref:Microsoft.AspNetCore.Routing.Route> and add it to the route collection.</span></span>

<span data-ttu-id="f6d02-1405"><xref:Microsoft.AspNetCore.Builder.MapRouteRouteBuilderExtensions.MapRoute*>는 경로 처리기 매개 변수를 허용하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1405"><xref:Microsoft.AspNetCore.Builder.MapRouteRouteBuilderExtensions.MapRoute*> doesn't accept a route handler parameter.</span></span> <span data-ttu-id="f6d02-1406"><xref:Microsoft.AspNetCore.Builder.MapRouteRouteBuilderExtensions.MapRoute*>는 <xref:Microsoft.AspNetCore.Routing.RouteBuilder.DefaultHandler*>에 의해 처리되는 경로만 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1406"><xref:Microsoft.AspNetCore.Builder.MapRouteRouteBuilderExtensions.MapRoute*> only adds routes that are handled by the <xref:Microsoft.AspNetCore.Routing.RouteBuilder.DefaultHandler*>.</span></span> <span data-ttu-id="f6d02-1407">기본 처리기는 `IRouter`이며, 처리기에서 요청을 처리하지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1407">The default handler is an `IRouter`, and the handler might not handle the request.</span></span> <span data-ttu-id="f6d02-1408">예를 들어 ASP.NET Core MVC는 일반적으로 사용 가능한 컨트롤러 및 작업과 일치하는 요청만 처리하는 기본 처리기로 구성됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1408">For example, ASP.NET Core MVC is typically configured as a default handler that only handles requests that match an available controller and action.</span></span> <span data-ttu-id="f6d02-1409">MVC의 라우팅에 대해 자세히 알아보려면 <xref:mvc/controllers/routing>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1409">To learn more about routing in MVC, see <xref:mvc/controllers/routing>.</span></span>

<span data-ttu-id="f6d02-1410">다음 코드 예제는 일반적인 ASP.NET Core MVC 경로 정의에서 사용되는 <xref:Microsoft.AspNetCore.Builder.MapRouteRouteBuilderExtensions.MapRoute*> 호출의 예제입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1410">The following code example is an example of a <xref:Microsoft.AspNetCore.Builder.MapRouteRouteBuilderExtensions.MapRoute*> call used by a typical ASP.NET Core MVC route definition:</span></span>

```csharp
routes.MapRoute(
    name: "default",
    template: "{controller=Home}/{action=Index}/{id?}");
```

<span data-ttu-id="f6d02-1411">이 템플릿은 URL 경로와 일치시키고 경로 값을 추출합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1411">This template matches a URL path and extracts the route values.</span></span> <span data-ttu-id="f6d02-1412">예를 들어 `/Products/Details/17` 경로는 `{ controller = Products, action = Details, id = 17 }` 경로 값을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1412">For example, the path `/Products/Details/17` generates the following route values: `{ controller = Products, action = Details, id = 17 }`.</span></span>

<span data-ttu-id="f6d02-1413">경로 값은 URL 경로를 세그먼트로 분할하고 각 세그먼트를 경로 템플릿의 *경로 매개 변수* 이름과 일치시켜 결정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1413">Route values are determined by splitting the URL path into segments and matching each segment with the *route parameter* name in the route template.</span></span> <span data-ttu-id="f6d02-1414">경로 매개 변수는 이름이 지정됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1414">Route parameters are named.</span></span> <span data-ttu-id="f6d02-1415">매개 변수는 매개 변수 이름을 `{ ... }` 중괄호로 묶어 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1415">The parameters defined by enclosing the parameter name in braces `{ ... }`.</span></span>

<span data-ttu-id="f6d02-1416">또한 위의 템플릿은 `/` URL 경로와 일치시키고 `{ controller = Home, action = Index }` 값을 생성할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1416">The preceding template could also match the URL path `/` and produce the values `{ controller = Home, action = Index }`.</span></span> <span data-ttu-id="f6d02-1417">이는 `{controller}` 및 `{action}` 경로 매개 변수에 기본값이 있으며 `id` 경로 매개 변수는 선택 사항이기 때문에 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1417">This occurs because the `{controller}` and `{action}` route parameters have default values and the `id` route parameter is optional.</span></span> <span data-ttu-id="f6d02-1418">경로 매개 변수 이름 뒤에 있는 값이 뒤따르는 등호(`=`)는 매개 변수에 대한 기본값을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1418">An equals sign (`=`) followed by a value after the route parameter name defines a default value for the parameter.</span></span> <span data-ttu-id="f6d02-1419">경로 매개 변수 이름 뒤에 있는 물음표(`?`)는 선택적 매개 변수를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1419">A question mark (`?`) after the route parameter name defines an optional parameter.</span></span>

<span data-ttu-id="f6d02-1420">기본 값을 사용하는 경로 매개 변수는 경로가 일치하는 경우 *항상* 경로 값을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1420">Route parameters with a default value *always* produce a route value when the route matches.</span></span> <span data-ttu-id="f6d02-1421">해당 URL 경로 세그먼트가 없는 경우 선택적 매개 변수는 경로 값을 생성하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1421">Optional parameters don't produce a route value if there is no corresponding URL path segment.</span></span> <span data-ttu-id="f6d02-1422">경로 템플릿 시나리오 및 구문에 대한 자세한 설명은 [경로 템플릿 참조](#route-template-reference) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1422">See the [Route template reference](#route-template-reference) section for a thorough description of route template scenarios and syntax.</span></span>

<span data-ttu-id="f6d02-1423">다음 예제에서 `{id:int}` 경로 매개 변수 정의는 `id` 경로 매개 변수에 대한 [경로 제약 조건](#route-constraint-reference)을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1423">In the following example, the route parameter definition `{id:int}` defines a [route constraint](#route-constraint-reference) for the `id` route parameter:</span></span>

```csharp
routes.MapRoute(
    name: "default",
    template: "{controller=Home}/{action=Index}/{id:int}");
```

<span data-ttu-id="f6d02-1424">이 템플릿은 `/Products/Details/Apples`가 아닌 `/Products/Details/17`과 같은 URL 경로와 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1424">This template matches a URL path like `/Products/Details/17` but not `/Products/Details/Apples`.</span></span> <span data-ttu-id="f6d02-1425">경로 제약 조건은 <xref:Microsoft.AspNetCore.Routing.IRouteConstraint>를 구현하고 경로 값을 검사하여 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1425">Route constraints implement <xref:Microsoft.AspNetCore.Routing.IRouteConstraint> and inspect route values to verify them.</span></span> <span data-ttu-id="f6d02-1426">이 예제에서 경로 값 `id`는 정수로 변환할 수 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1426">In this example, the route value `id` must be convertible to an integer.</span></span> <span data-ttu-id="f6d02-1427">프레임워크에서 제공하는 경로 제약 조건에 대한 설명은 [경로 제약 조건 참조](#route-constraint-reference)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1427">See [route-constraint-reference](#route-constraint-reference) for an explanation of route constraints provided by the framework.</span></span>

<span data-ttu-id="f6d02-1428"><xref:Microsoft.AspNetCore.Builder.MapRouteRouteBuilderExtensions.MapRoute*>의 추가 오버로드는 `constraints`, `dataTokens` 및 `defaults`에 대한 값을 허용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1428">Additional overloads of <xref:Microsoft.AspNetCore.Builder.MapRouteRouteBuilderExtensions.MapRoute*> accept values for `constraints`, `dataTokens`, and `defaults`.</span></span> <span data-ttu-id="f6d02-1429">이러한 매개 변수의 일반적인 사용법은 익명 형식의 속성 이름이 경로 매개 변수 이름과 일치하는 익명 형식의 개체를 전달하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1429">The typical usage of these parameters is to pass an anonymously typed object, where the property names of the anonymous type match route parameter names.</span></span>

<span data-ttu-id="f6d02-1430">다음 <xref:Microsoft.AspNetCore.Builder.MapRouteRouteBuilderExtensions.MapRoute*> 예제에서는 동등한 경로를 만듭니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1430">The following <xref:Microsoft.AspNetCore.Builder.MapRouteRouteBuilderExtensions.MapRoute*> examples create equivalent routes:</span></span>

```csharp
routes.MapRoute(
    name: "default_route",
    template: "{controller}/{action}/{id?}",
    defaults: new { controller = "Home", action = "Index" });

routes.MapRoute(
    name: "default_route",
    template: "{controller=Home}/{action=Index}/{id?}");
```

> [!TIP]
> <span data-ttu-id="f6d02-1431">제약 조건 및 기본값을 정의하기 위한 인라인 구문은 단순 경로에 편리할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1431">The inline syntax for defining constraints and defaults can be convenient for simple routes.</span></span> <span data-ttu-id="f6d02-1432">그러나 데이터 토큰과 같이 인라인 구문에서는 지원되지 않는 시나리오가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1432">However, there are scenarios, such as data tokens, that aren't supported by inline syntax.</span></span>

<span data-ttu-id="f6d02-1433">다음 예제에서는 몇 가지 추가 시나리오를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1433">The following example demonstrates a few additional scenarios:</span></span>

```csharp
routes.MapRoute(
    name: "blog",
    template: "Blog/{*article}",
    defaults: new { controller = "Blog", action = "ReadArticle" });
```

<span data-ttu-id="f6d02-1434">위의 템플릿은 `/Blog/All-About-Routing/Introduction`과 같은 URL 경로와 일치하고 `{ controller = Blog, action = ReadArticle, article = All-About-Routing/Introduction }` 값을 추출합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1434">The preceding template matches a URL path like `/Blog/All-About-Routing/Introduction` and extracts the values `{ controller = Blog, action = ReadArticle, article = All-About-Routing/Introduction }`.</span></span> <span data-ttu-id="f6d02-1435">`controller` 및 `action`에 대한 기본 경로 값은 템플릿에 해당 경로 매개 변수가 없는 경우에도 경로에 의해 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1435">The default route values for `controller` and `action` are produced by the route even though there are no corresponding route parameters in the template.</span></span> <span data-ttu-id="f6d02-1436">기본값은 경로 템플릿에서 지정될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1436">Default values can be specified in the route template.</span></span> <span data-ttu-id="f6d02-1437">`article` 경로 매개 변수는 경로 매개 변수 이름 앞에 별표(`*`)를 표시하여 *범용*으로 정의됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1437">The `article` route parameter is defined as a *catch-all* by the appearance of an asterisk (`*`) before the route parameter name.</span></span> <span data-ttu-id="f6d02-1438">범용 경로 매개 변수는 URL 경로의 나머지를 캡처하고 빈 문자열과도 일치시킬 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1438">Catch-all route parameters capture the remainder of the URL path and can also match the empty string.</span></span>

<span data-ttu-id="f6d02-1439">다음 예제에서는 경로 제약 조건 및 데이터 토큰을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1439">The following example adds route constraints and data tokens:</span></span>

```csharp
routes.MapRoute(
    name: "us_english_products",
    template: "en-US/Products/{id}",
    defaults: new { controller = "Products", action = "Details" },
    constraints: new { id = new IntRouteConstraint() },
    dataTokens: new { locale = "en-US" });
```

<span data-ttu-id="f6d02-1440">앞의 템플릿은 `/en-US/Products/5`와 같은 URL 경로와 일치하고, `{ controller = Products, action = Details, id = 5 }` 값 및 `{ locale = en-US }` 데이터 토큰을 추출합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1440">The preceding template matches a URL path like `/en-US/Products/5` and extracts the values `{ controller = Products, action = Details, id = 5 }` and the data tokens `{ locale = en-US }`.</span></span>

![지역 Windows 토큰](routing/_static/tokens.png)

### <a name="route-class-url-generation"></a><span data-ttu-id="f6d02-1442">Route 클래스 URL 생성</span><span class="sxs-lookup"><span data-stu-id="f6d02-1442">Route class URL generation</span></span>

<span data-ttu-id="f6d02-1443"><xref:Microsoft.AspNetCore.Routing.Route> 클래스는 경로 값의 집합을 해당 경로 템플릿과 결합하여 URL 생성을 수행할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1443">The <xref:Microsoft.AspNetCore.Routing.Route> class can also perform URL generation by combining a set of route values with its route template.</span></span> <span data-ttu-id="f6d02-1444">이는 논리적으로 URL 경로와 일치시키는 역방향 프로세스입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1444">This is logically the reverse process of matching the URL path.</span></span>

> [!TIP]
> <span data-ttu-id="f6d02-1445">URL 생성을 보다 잘 이해하려면 생성하려는 URL을 가정한 다음, 경로 템플릿을 해당 URL과 일치시키는 방법을 생각합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1445">To better understand URL generation, imagine what URL you want to generate and then think about how a route template would match that URL.</span></span> <span data-ttu-id="f6d02-1446">어떤 값이 생성되나요?</span><span class="sxs-lookup"><span data-stu-id="f6d02-1446">What values would be produced?</span></span> <span data-ttu-id="f6d02-1447">이는 URL 생성이 <xref:Microsoft.AspNetCore.Routing.Route> 클래스에서 작동하는 방식과 대략적으로 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1447">This is the rough equivalent of how URL generation works in the <xref:Microsoft.AspNetCore.Routing.Route> class.</span></span>

<span data-ttu-id="f6d02-1448">다음 예제에서는 일반적인 ASP.NET Core MVC 기본 경로를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1448">The following example uses a general ASP.NET Core MVC default route:</span></span>

```csharp
routes.MapRoute(
    name: "default",
    template: "{controller=Home}/{action=Index}/{id?}");
```

<span data-ttu-id="f6d02-1449">`{ controller = Products, action = List }` 경로 값을 사용하면 `/Products/List` URL이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1449">With the route values `{ controller = Products, action = List }`, the URL `/Products/List` is generated.</span></span> <span data-ttu-id="f6d02-1450">경로 값은 URL 경로를 구성하기 위해 해당 경로 매개 변수에 대해 대체됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1450">The route values are substituted for the corresponding route parameters to form the URL path.</span></span> <span data-ttu-id="f6d02-1451">`id`는 선택적 경로 매개 변수이므로 `id`에 대한 값 없이 URL이 성공적으로 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1451">Since `id` is an optional route parameter, the URL is successfully generated without a value for `id`.</span></span>

<span data-ttu-id="f6d02-1452">`{ controller = Home, action = Index }` 경로 값을 사용하면 `/` URL이 생성됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1452">With the route values `{ controller = Home, action = Index }`, the URL `/` is generated.</span></span> <span data-ttu-id="f6d02-1453">제공된 경로 값이 기본값과 일치하고, 기본값에 해당하는 세그먼트는 안전하게 생략됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1453">The provided route values match the default values, and the segments corresponding to the default values are safely omitted.</span></span>

<span data-ttu-id="f6d02-1454">뒤이어 언급된 경로 정의(`/Home/Index` 및 `/`)를 사용하는 URL 생성 왕복 모두에서는 URL을 생성하기 위해 사용된 것과 동일한 경로 값을 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1454">Both URLs generated round-trip with the following route definition (`/Home/Index` and `/`) produce the same route values that were used to generate the URL.</span></span>

> [!NOTE]
> <span data-ttu-id="f6d02-1455">ASP.NET Core MVC를 사용하는 앱은 라우팅을 직접 호출하는 대신 <xref:Microsoft.AspNetCore.Mvc.Routing.UrlHelper>를 사용하여 URL을 생성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1455">An app using ASP.NET Core MVC should use <xref:Microsoft.AspNetCore.Mvc.Routing.UrlHelper> to generate URLs instead of calling into routing directly.</span></span>

<span data-ttu-id="f6d02-1456">URL 생성에 대한 자세한 내용은 [URL 생성 참조](#url-generation-reference) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1456">For more information on URL generation, see the [Url generation reference](#url-generation-reference) section.</span></span>

## <a name="use-routing-middleware"></a><span data-ttu-id="f6d02-1457">라우팅 미들웨어 사용</span><span class="sxs-lookup"><span data-stu-id="f6d02-1457">Use routing middleware</span></span>

<span data-ttu-id="f6d02-1458">앱의 프로젝트 파일에서 [Microsoft.AspNetCore.App 메타패키지](xref:fundamentals/metapackage-app)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1458">Reference the [Microsoft.AspNetCore.App metapackage](xref:fundamentals/metapackage-app) in the app's project file.</span></span>

<span data-ttu-id="f6d02-1459">`Startup.ConfigureServices`의 서비스 컨테이너에 라우팅을 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1459">Add routing to the service container in `Startup.ConfigureServices`:</span></span>

[!code-csharp[](routing/samples/2.x/RoutingSample/Startup.cs?name=snippet_ConfigureServices&highlight=3)]

<span data-ttu-id="f6d02-1460">경로는 `Startup.Configure` 메서드에서 구성되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1460">Routes must be configured in the `Startup.Configure` method.</span></span> <span data-ttu-id="f6d02-1461">샘플 앱에서 사용하는 API는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1461">The sample app uses the following APIs:</span></span>

* <xref:Microsoft.AspNetCore.Routing.RouteBuilder>
* <span data-ttu-id="f6d02-1462"><xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapGet*> &ndash; HTTP GET 요청만 일치시킵니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1462"><xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapGet*> &ndash; Matches only HTTP GET requests.</span></span>
* <xref:Microsoft.AspNetCore.Builder.RoutingBuilderExtensions.UseRouter*>

[!code-csharp[](routing/samples/2.x/RoutingSample/Startup.cs?name=snippet_RouteHandler)]

<span data-ttu-id="f6d02-1463">다음 표는 지정된 URI에 대한 응답을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1463">The following table shows the responses with the given URIs.</span></span>

| <span data-ttu-id="f6d02-1464">URI</span><span class="sxs-lookup"><span data-stu-id="f6d02-1464">URI</span></span>                    | <span data-ttu-id="f6d02-1465">응답</span><span class="sxs-lookup"><span data-stu-id="f6d02-1465">Response</span></span>                                          |
| ---------------------- | ------------------------------------------------- |
| `/package/create/3`    | <span data-ttu-id="f6d02-1466">Hello!</span><span class="sxs-lookup"><span data-stu-id="f6d02-1466">Hello!</span></span> <span data-ttu-id="f6d02-1467">Route values: [operation, create], [id, 3]</span><span class="sxs-lookup"><span data-stu-id="f6d02-1467">Route values: [operation, create], [id, 3]</span></span> |
| `/package/track/-3`    | <span data-ttu-id="f6d02-1468">Hello!</span><span class="sxs-lookup"><span data-stu-id="f6d02-1468">Hello!</span></span> <span data-ttu-id="f6d02-1469">Route values: [operation, track], [id, -3]</span><span class="sxs-lookup"><span data-stu-id="f6d02-1469">Route values: [operation, track], [id, -3]</span></span> |
| `/package/track/-3/`   | <span data-ttu-id="f6d02-1470">Hello!</span><span class="sxs-lookup"><span data-stu-id="f6d02-1470">Hello!</span></span> <span data-ttu-id="f6d02-1471">Route values: [operation, track], [id, -3]</span><span class="sxs-lookup"><span data-stu-id="f6d02-1471">Route values: [operation, track], [id, -3]</span></span> |
| `/package/track/`      | <span data-ttu-id="f6d02-1472">일치하는 경로가 없으므로, 요청이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1472">The request falls through, no match.</span></span>              |
| `GET /hello/Joe`       | <span data-ttu-id="f6d02-1473">Hi, Joe!</span><span class="sxs-lookup"><span data-stu-id="f6d02-1473">Hi, Joe!</span></span>                                          |
| `POST /hello/Joe`      | <span data-ttu-id="f6d02-1474">HTTP GET만 일치하므로, 요청이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1474">The request falls through, matches HTTP GET only.</span></span> |
| `GET /hello/Joe/Smith` | <span data-ttu-id="f6d02-1475">일치하는 경로가 없으므로, 요청이 실패합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1475">The request falls through, no match.</span></span>              |

<span data-ttu-id="f6d02-1476">단일 경로를 구성하는 경우 `IRouter` 인스턴스를 전달하는 <xref:Microsoft.AspNetCore.Builder.RoutingBuilderExtensions.UseRouter*>를 호출합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1476">If you're configuring a single route, call <xref:Microsoft.AspNetCore.Builder.RoutingBuilderExtensions.UseRouter*> passing in an `IRouter` instance.</span></span> <span data-ttu-id="f6d02-1477"><xref:Microsoft.AspNetCore.Routing.RouteBuilder>는 사용할 필요가 없습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1477">You won't need to use <xref:Microsoft.AspNetCore.Routing.RouteBuilder>.</span></span>

<span data-ttu-id="f6d02-1478">프레임워크는 경로를 만드는 확장 메서드 모음(<xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions>)을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1478">The framework provides a set of extension methods for creating routes (<xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions>):</span></span>

* <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapDelete*>
* <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapGet*>
* <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapMiddlewareDelete*>
* <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapMiddlewareGet*>
* <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapMiddlewarePost*>
* <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapMiddlewarePut*>
* <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapMiddlewareRoute*>
* <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapMiddlewareVerb*>
* <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapPost*>
* <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapPut*>
* <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapRoute*>
* <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapVerb*>

<span data-ttu-id="f6d02-1479"><xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapGet*>과 같은 나열된 메서드 중 일부는 <xref:Microsoft.AspNetCore.Http.RequestDelegate>를 필요로 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1479">Some of listed methods, such as <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapGet*>, require a <xref:Microsoft.AspNetCore.Http.RequestDelegate>.</span></span> <span data-ttu-id="f6d02-1480"><xref:Microsoft.AspNetCore.Http.RequestDelegate>는 경로가 일치하는 경우 *경로 처리기*로 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1480">The <xref:Microsoft.AspNetCore.Http.RequestDelegate> is used as the *route handler* when the route matches.</span></span> <span data-ttu-id="f6d02-1481">이 모음의 다른 메서드를 사용하면 경로 처리기로 사용할 미들웨어 파이프라인을 구성할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1481">Other methods in this family allow configuring a middleware pipeline for use as the route handler.</span></span> <span data-ttu-id="f6d02-1482">`Map*` 메서드에서 <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapRoute*>와 같은 처리기를 허용하지 않는 경우 <xref:Microsoft.AspNetCore.Routing.RouteBuilder.DefaultHandler*>를 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1482">If the `Map*` method doesn't accept a handler, such as <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapRoute*>, it uses the <xref:Microsoft.AspNetCore.Routing.RouteBuilder.DefaultHandler*>.</span></span>

<span data-ttu-id="f6d02-1483">`Map[Verb]` 메서드는 제약 조건을 사용하여 메서드 이름에 지정된 HTTP 동사에 대한 경로로 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1483">The `Map[Verb]` methods use constraints to limit the route to the HTTP Verb in the method name.</span></span> <span data-ttu-id="f6d02-1484">예제는 <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapGet*> 및 <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapVerb*>을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1484">For example, see <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapGet*> and <xref:Microsoft.AspNetCore.Routing.RequestDelegateRouteBuilderExtensions.MapVerb*>.</span></span>

## <a name="route-template-reference"></a><span data-ttu-id="f6d02-1485">경로 템플릿 참조</span><span class="sxs-lookup"><span data-stu-id="f6d02-1485">Route template reference</span></span>

<span data-ttu-id="f6d02-1486">중괄호(`{ ... }`) 내의 토큰은 경로가 일치하는 경우 바인딩될 *경로 매개 변수*를 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1486">Tokens within curly braces (`{ ... }`) define *route parameters* that are bound if the route is matched.</span></span> <span data-ttu-id="f6d02-1487">경로 세그먼트에 둘 이상의 경로 매개 변수를 정의할 수 있지만 리터럴 값으로 분리되어 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1487">You can define more than one route parameter in a route segment, but they must be separated by a literal value.</span></span> <span data-ttu-id="f6d02-1488">예를 들어 `{controller=Home}{action=Index}`는 `{controller}` 및 `{action}` 사이에 리터럴 값이 없으므로 유효한 경로가 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1488">For example, `{controller=Home}{action=Index}` isn't a valid route, since there's no literal value between `{controller}` and `{action}`.</span></span> <span data-ttu-id="f6d02-1489">이러한 경로 매개 변수는 이름이 있어야 하며 지정된 추가 특성을 가질 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1489">These route parameters must have a name and may have additional attributes specified.</span></span>

<span data-ttu-id="f6d02-1490">경로 매개 변수 이외의 리터럴 텍스트(예: `{id}`) 및 경로 구분 기호(`/`)는 URL의 텍스트와 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1490">Literal text other than route parameters (for example, `{id}`) and the path separator `/` must match the text in the URL.</span></span> <span data-ttu-id="f6d02-1491">텍스트 일치는 대/소문자를 구분하지 않으며 URL 경로의 디코딩된 표현을 기반으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1491">Text matching is case-insensitive and based on the decoded representation of the URLs path.</span></span> <span data-ttu-id="f6d02-1492">리터럴 경로 매개 변수 구분 기호(`{` 또는 `}`)와 일치시키려면 문자를 반복하여(`{{` 또는 `}}`) 구분 기호를 이스케이프합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1492">To match a literal route parameter delimiter (`{` or `}`), escape the delimiter by repeating the character (`{{` or `}}`).</span></span>

<span data-ttu-id="f6d02-1493">선택적 파일 확장명이 있는 파일 이름을 캡처하려고 시도하는 URL 패턴에는 추가 고려 사항이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1493">URL patterns that attempt to capture a file name with an optional file extension have additional considerations.</span></span> <span data-ttu-id="f6d02-1494">예를 들어 템플릿 `files/{filename}.{ext?}`를 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1494">For example, consider the template `files/{filename}.{ext?}`.</span></span> <span data-ttu-id="f6d02-1495">`filename` 및 `ext` 모두에 대한 값이 있으면 두 값이 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1495">When values for both `filename` and `ext` exist, both values are populated.</span></span> <span data-ttu-id="f6d02-1496">URL에 `filename`에 대한 값만 있으면 후행 마침표(`.`)가 선택 사항이므로 경로가 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1496">If only a value for `filename` exists in the URL, the route matches because the trailing period (`.`) is  optional.</span></span> <span data-ttu-id="f6d02-1497">다음 URL은 이 경로와 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1497">The following URLs match this route:</span></span>

* `/files/myFile.txt`
* `/files/myFile`

<span data-ttu-id="f6d02-1498">별표(`*`)를 경로 매개 변수의 접두사로 사용하여 URI의 나머지 부분에 바인딩할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1498">You can use the asterisk (`*`) as a prefix to a route parameter to bind to the rest of the URI.</span></span> <span data-ttu-id="f6d02-1499">이를 *범용* 매개 변수라고 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1499">This is called a *catch-all* parameter.</span></span> <span data-ttu-id="f6d02-1500">예를 들어 `blog/{*slug}`는 `/blog`로 시작하고 모든 값(`slug` 경로 값에 할당된)이 뒤따르는 모든 URI와 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1500">For example, `blog/{*slug}` matches any URI that starts with `/blog` and has any value following it, which is assigned to the `slug` route value.</span></span> <span data-ttu-id="f6d02-1501">범용 매개 변수는 빈 문자열과 일치시킬 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1501">Catch-all parameters can also match the empty string.</span></span>

<span data-ttu-id="f6d02-1502">catch-all 매개 변수는 경로 구분 기호(`/`) 문자를 포함하여 URL을 생성하는 데 경로가 사용될 때 적절한 문자를 이스케이프합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1502">The catch-all parameter escapes the appropriate characters when the route is used to generate a URL, including path separator (`/`) characters.</span></span> <span data-ttu-id="f6d02-1503">예를 들어 경로 값이 `{ path = "my/path" }`인 경로 `foo/{*path}`는 `foo/my%2Fpath`를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1503">For example, the route `foo/{*path}` with route values `{ path = "my/path" }` generates `foo/my%2Fpath`.</span></span> <span data-ttu-id="f6d02-1504">이스케이프된 슬래시에 주의하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1504">Note the escaped forward slash.</span></span>

<span data-ttu-id="f6d02-1505">경로 매개 변수에는 등호(`=`)로 구분된 매개 변수 이름 뒤에 기본값을 지정하여 지정된 *기본값*이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1505">Route parameters may have *default values* designated by specifying the default value after the parameter name separated by an equals sign (`=`).</span></span> <span data-ttu-id="f6d02-1506">예를 들어 `{controller=Home}`은 `controller`에 대한 기본값으로 `Home`을 정의합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1506">For example, `{controller=Home}` defines `Home` as the default value for `controller`.</span></span> <span data-ttu-id="f6d02-1507">URL에 매개 변수에 대한 값이 없는 경우 기본값이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1507">The default value is used if no value is present in the URL for the parameter.</span></span> <span data-ttu-id="f6d02-1508">경로 매개 변수는 `id?`와 같이 매개 변수 이름의 끝에 물음표(`?`)를 추가하면 선택적이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1508">Route parameters are made optional by appending a question mark (`?`) to the end of the parameter name, as in `id?`.</span></span> <span data-ttu-id="f6d02-1509">선택적 값과 기본 경로 매개 변수 간의 차이점은 기본값이 있는 경로 매개 변수는 항상 값을 생성한다는 것입니다. 선택적 매개 변수에는 요청 URL에서 값을 제공하는 경우에만 값이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1509">The difference between optional values and default route parameters is that a route parameter with a default value always produces a value&mdash;an optional parameter has a value only when a value is provided by the request URL.</span></span>

<span data-ttu-id="f6d02-1510">경로 매개 변수에는 URL에서 바인딩된 경로 값과 일치해야 한다는 제약 조건이 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1510">Route parameters may have constraints that must match the route value bound from the URL.</span></span> <span data-ttu-id="f6d02-1511">경로 매개 변수 이름 뒤에 콜론(`:`)과 제약 조건 이름을 추가하여 경로 매개 변수에서 *인라인 제약 조건*을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1511">Adding a colon (`:`) and constraint name after the route parameter name specifies an *inline constraint* on a route parameter.</span></span> <span data-ttu-id="f6d02-1512">제약 조건에 인수가 필요한 경우 제약 조건 이름 뒤에 인수를 괄호(`(...)`)로 묶습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1512">If the constraint requires arguments, they're enclosed in parentheses (`(...)`) after the constraint name.</span></span> <span data-ttu-id="f6d02-1513">또 다른 콜론(`:`) 및 제약 조건 이름을 추가하여 여러 인라인 제약 조건을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1513">Multiple inline constraints can be specified by appending another colon (`:`) and constraint name.</span></span>

<span data-ttu-id="f6d02-1514">제약 조건 이름 및 인수는 <xref:Microsoft.AspNetCore.Routing.IRouteConstraint>의 인스턴스를 만드는 <xref:Microsoft.AspNetCore.Routing.IInlineConstraintResolver> 서비스로 전달되어 URL 처리에서 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1514">The constraint name and arguments are passed to the <xref:Microsoft.AspNetCore.Routing.IInlineConstraintResolver> service to create an instance of <xref:Microsoft.AspNetCore.Routing.IRouteConstraint> to use in URL processing.</span></span> <span data-ttu-id="f6d02-1515">예를 들어 경로 템플릿 `blog/{article:minlength(10)}`는 인수 `10`으로 `minlength` 제약 조건을 지정합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1515">For example, the route template `blog/{article:minlength(10)}` specifies a `minlength` constraint with the argument `10`.</span></span> <span data-ttu-id="f6d02-1516">경로 제약 조건 및 프레임워크에서 제공하는 제약 조건 목록에 대한 자세한 내용은 [경로 제약 조건 참조](#route-constraint-reference) 섹션을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1516">For more information on route constraints and a list of the constraints provided by the framework, see the [Route constraint reference](#route-constraint-reference) section.</span></span>

<span data-ttu-id="f6d02-1517">다음 표에서는 경로 템플릿 예제 및 해당 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1517">The following table demonstrates example route templates and their behavior.</span></span>

| <span data-ttu-id="f6d02-1518">경로 템플릿</span><span class="sxs-lookup"><span data-stu-id="f6d02-1518">Route Template</span></span>                           | <span data-ttu-id="f6d02-1519">URI 일치 예제</span><span class="sxs-lookup"><span data-stu-id="f6d02-1519">Example Matching URI</span></span>    | <span data-ttu-id="f6d02-1520">요청 URI&hellip;</span><span class="sxs-lookup"><span data-stu-id="f6d02-1520">The request URI&hellip;</span></span>                                                    |
| ---------------------------------------- | ----------------------- | -------------------------------------------------------------------------- |
| `hello`                                  | `/hello`                | <span data-ttu-id="f6d02-1521">`/hello` 단일 경로만 일치합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1521">Only matches the single path `/hello`.</span></span>                                     |
| `{Page=Home}`                            | `/`                     | <span data-ttu-id="f6d02-1522">일치하고, `Page`를 `Home`으로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1522">Matches and sets `Page` to `Home`.</span></span>                                         |
| `{Page=Home}`                            | `/Contact`              | <span data-ttu-id="f6d02-1523">일치하고, `Page`를 `Contact`로 설정합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1523">Matches and sets `Page` to `Contact`.</span></span>                                      |
| `{controller}/{action}/{id?}`            | `/Products/List`        | <span data-ttu-id="f6d02-1524">`Products` 컨트롤러 및 `List` 작업에 매핑합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1524">Maps to the `Products` controller and `List` action.</span></span>                       |
| `{controller}/{action}/{id?}`            | `/Products/Details/123` | <span data-ttu-id="f6d02-1525">`Products` 컨트롤러 및 `Details` 작업에 매핑합니다(`id`가 123으로 설정됨).</span><span class="sxs-lookup"><span data-stu-id="f6d02-1525">Maps to the `Products` controller and  `Details` action (`id` set to 123).</span></span> |
| `{controller=Home}/{action=Index}/{id?}` | `/`                     | <span data-ttu-id="f6d02-1526">`Home` 컨트롤러 및 `Index` 메서드에 매핑합니다(`id`가 무시됨).</span><span class="sxs-lookup"><span data-stu-id="f6d02-1526">Maps to the `Home` controller and `Index` method (`id` is ignored).</span></span>        |

<span data-ttu-id="f6d02-1527">템플릿을 사용하는 것은 일반적으로 라우팅에 대한 가장 간단한 방식입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1527">Using a template is generally the simplest approach to routing.</span></span> <span data-ttu-id="f6d02-1528">제약 조건 및 기본값을 경로 템플릿 외부에서 지정할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1528">Constraints and defaults can also be specified outside the route template.</span></span>

> [!TIP]
> <span data-ttu-id="f6d02-1529">[로깅](xref:fundamentals/logging/index)을 사용하도록 설정하여 <xref:Microsoft.AspNetCore.Routing.Route>와 같은 기본 제공 라우팅 구현이 요청과 일치하는 방법을 확인하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1529">Enable [Logging](xref:fundamentals/logging/index) to see how the built-in routing implementations, such as <xref:Microsoft.AspNetCore.Routing.Route>, match requests.</span></span>

## <a name="route-constraint-reference"></a><span data-ttu-id="f6d02-1530">경로 제약 조건 참조</span><span class="sxs-lookup"><span data-stu-id="f6d02-1530">Route constraint reference</span></span>

<span data-ttu-id="f6d02-1531">경로 제약 조건은 들어오는 URL과 일치하고 URL 경로가 경로 값으로 토큰화되면 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1531">Route constraints execute when a match has occurred to the incoming URL and the URL path is tokenized into route values.</span></span> <span data-ttu-id="f6d02-1532">일반적으로 경로 제약 조건은 경로 템플릿을 통해 연결된 경로 값을 검사하고 값 허용 여부에 대한 예/아니요 의사 결정을 내립니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1532">Route constraints generally inspect the route value associated via the route template and make a yes/no decision about whether or not the value is acceptable.</span></span> <span data-ttu-id="f6d02-1533">일부 경로 제약 조건은 경로 값 외부의 데이터를 사용하여 요청을 라우팅할 수 있는지 여부를 고려합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1533">Some route constraints use data outside the route value to consider whether the request can be routed.</span></span> <span data-ttu-id="f6d02-1534">예를 들어 <xref:Microsoft.AspNetCore.Routing.Constraints.HttpMethodRouteConstraint>는 해당 HTTP 동사에 따라 요청을 허용하거나 거부할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1534">For example, the <xref:Microsoft.AspNetCore.Routing.Constraints.HttpMethodRouteConstraint> can accept or reject a request based on its HTTP verb.</span></span> <span data-ttu-id="f6d02-1535">제약 조건은 라우팅 요청 및 링크 생성에 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1535">Constraints are used in routing requests and link generation.</span></span>

> [!WARNING]
> <span data-ttu-id="f6d02-1536">제약 조건을 **입력 유효성 검사**에 사용하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1536">Don't use constraints for **input validation**.</span></span> <span data-ttu-id="f6d02-1537">제약 조건이 **입력 유효성 검사**에 사용되는 경우 잘못된 입력으로 인해 적절한 오류 메시지와 함께 *400 - 잘못된 요청* 대신 *404 - 찾을 수 없음* 응답이 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1537">If constraints are used for **input validation**, invalid input results in a *404 - Not Found* response instead of a *400 - Bad Request* with an appropriate error message.</span></span> <span data-ttu-id="f6d02-1538">경로 제약 조건은 특정 경로에 대한 입력의 유효성을 검사하는 것이 아니라 비슷한 경로를 **명확하게 구분하는 데** 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1538">Route constraints are used to **disambiguate** similar routes, not to validate the inputs for a particular route.</span></span>

<span data-ttu-id="f6d02-1539">다음 표에서는 경로 제약 조건 예제 및 예상되는 해당 동작을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1539">The following table demonstrates example route constraints and their expected behavior.</span></span>

| <span data-ttu-id="f6d02-1540">제약 조건</span><span class="sxs-lookup"><span data-stu-id="f6d02-1540">constraint</span></span> | <span data-ttu-id="f6d02-1541">예제</span><span class="sxs-lookup"><span data-stu-id="f6d02-1541">Example</span></span> | <span data-ttu-id="f6d02-1542">일치하는 예제</span><span class="sxs-lookup"><span data-stu-id="f6d02-1542">Example Matches</span></span> | <span data-ttu-id="f6d02-1543">참고</span><span class="sxs-lookup"><span data-stu-id="f6d02-1543">Notes</span></span> |
| ---------- | ------- | --------------- | ----- |
| `int` | `{id:int}` | <span data-ttu-id="f6d02-1544">`123456789`, `-123456789`</span><span class="sxs-lookup"><span data-stu-id="f6d02-1544">`123456789`, `-123456789`</span></span> | <span data-ttu-id="f6d02-1545">임의의 정수와 일치</span><span class="sxs-lookup"><span data-stu-id="f6d02-1545">Matches any integer</span></span> |
| `bool` | `{active:bool}` | <span data-ttu-id="f6d02-1546">`true`, `FALSE`</span><span class="sxs-lookup"><span data-stu-id="f6d02-1546">`true`, `FALSE`</span></span> | <span data-ttu-id="f6d02-1547">`true` 또는 `false` 일치(대/소문자 구분하지 않음)</span><span class="sxs-lookup"><span data-stu-id="f6d02-1547">Matches `true` or `false` (case-insensitive)</span></span> |
| `datetime` | `{dob:datetime}` | <span data-ttu-id="f6d02-1548">`2016-12-31`, `2016-12-31 7:32pm`</span><span class="sxs-lookup"><span data-stu-id="f6d02-1548">`2016-12-31`, `2016-12-31 7:32pm`</span></span> | <span data-ttu-id="f6d02-1549">유효한 `DateTime` 값 일치(고정 문화권에서)</span><span class="sxs-lookup"><span data-stu-id="f6d02-1549">Matches a valid `DateTime` value in the invariant culture.</span></span> <span data-ttu-id="f6d02-1550">이전 경고를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1550">See  preceding warning.</span></span>|
| `decimal` | `{price:decimal}` | <span data-ttu-id="f6d02-1551">`49.99`, `-1,000.01`</span><span class="sxs-lookup"><span data-stu-id="f6d02-1551">`49.99`, `-1,000.01`</span></span> | <span data-ttu-id="f6d02-1552">유효한 `decimal` 값 일치(고정 문화권에서)</span><span class="sxs-lookup"><span data-stu-id="f6d02-1552">Matches a valid `decimal` value in the invariant culture.</span></span> <span data-ttu-id="f6d02-1553">이전 경고를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1553">See  preceding warning.</span></span>|
| `double` | `{weight:double}` | <span data-ttu-id="f6d02-1554">`1.234`, `-1,001.01e8`</span><span class="sxs-lookup"><span data-stu-id="f6d02-1554">`1.234`, `-1,001.01e8`</span></span> | <span data-ttu-id="f6d02-1555">유효한 `double` 값 일치(고정 문화권에서)</span><span class="sxs-lookup"><span data-stu-id="f6d02-1555">Matches a valid `double` value in the invariant culture.</span></span> <span data-ttu-id="f6d02-1556">이전 경고를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1556">See  preceding warning.</span></span>|
| `float` | `{weight:float}` | <span data-ttu-id="f6d02-1557">`1.234`, `-1,001.01e8`</span><span class="sxs-lookup"><span data-stu-id="f6d02-1557">`1.234`, `-1,001.01e8`</span></span> | <span data-ttu-id="f6d02-1558">유효한 `float` 값 일치(고정 문화권에서)</span><span class="sxs-lookup"><span data-stu-id="f6d02-1558">Matches a valid `float` value in the invariant culture.</span></span> <span data-ttu-id="f6d02-1559">이전 경고를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1559">See  preceding warning.</span></span>|
| `guid` | `{id:guid}` | <span data-ttu-id="f6d02-1560">`CD2C1638-1638-72D5-1638-DEADBEEF1638`, `{CD2C1638-1638-72D5-1638-DEADBEEF1638}`</span><span class="sxs-lookup"><span data-stu-id="f6d02-1560">`CD2C1638-1638-72D5-1638-DEADBEEF1638`, `{CD2C1638-1638-72D5-1638-DEADBEEF1638}`</span></span> | <span data-ttu-id="f6d02-1561">유효한 `Guid` 값 일치</span><span class="sxs-lookup"><span data-stu-id="f6d02-1561">Matches a valid `Guid` value</span></span> |
| `long` | `{ticks:long}` | <span data-ttu-id="f6d02-1562">`123456789`, `-123456789`</span><span class="sxs-lookup"><span data-stu-id="f6d02-1562">`123456789`, `-123456789`</span></span> | <span data-ttu-id="f6d02-1563">유효한 `long` 값 일치</span><span class="sxs-lookup"><span data-stu-id="f6d02-1563">Matches a valid `long` value</span></span> |
| `minlength(value)` | `{username:minlength(4)}` | `Rick` | <span data-ttu-id="f6d02-1564">문자열은 4자 이상이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1564">String must be at least 4 characters</span></span> |
| `maxlength(value)` | `{filename:maxlength(8)}` | `Richard` | <span data-ttu-id="f6d02-1565">문자열은 8자 이하여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1565">String must be no more than 8 characters</span></span> |
| `length(length)` | `{filename:length(12)}` | `somefile.txt` | <span data-ttu-id="f6d02-1566">문자열은 정확히 12자여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1566">String must be exactly 12 characters long</span></span> |
| `length(min,max)` | `{filename:length(8,16)}` | `somefile.txt` | <span data-ttu-id="f6d02-1567">문자열의 길이는 8자 이상이며 16자 이하여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1567">String must be at least 8 and no more than 16 characters long</span></span> |
| `min(value)` | `{age:min(18)}` | `19` | <span data-ttu-id="f6d02-1568">정수 값은 18 이상이어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1568">Integer value must be at least 18</span></span> |
| `max(value)` | `{age:max(120)}` | `91` | <span data-ttu-id="f6d02-1569">정수 값은 120 이하여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1569">Integer value must be no more than 120</span></span> |
| `range(min,max)` | `{age:range(18,120)}` | `91` | <span data-ttu-id="f6d02-1570">정수 값은 18 이상이며 120 이하여야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1570">Integer value must be at least 18 but no more than 120</span></span> |
| `alpha` | `{name:alpha}` | `Rick` | <span data-ttu-id="f6d02-1571">문자열은 하나 이상의 알파벳 문자(`a`-`z`, 대/소문자 구분)로 구성되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1571">String must consist of one or more alphabetical characters (`a`-`z`, case-insensitive)</span></span> |
| `regex(expression)` | `{ssn:regex(^\\d{{3}}-\\d{{2}}-\\d{{4}}$)}` | `123-45-6789` | <span data-ttu-id="f6d02-1572">문자열은 정규식과 일치해야 합니다(정규식 정의에 대한 팁 참조).</span><span class="sxs-lookup"><span data-stu-id="f6d02-1572">String must match the regular expression (see tips about defining a regular expression)</span></span> |
| `required` | `{name:required}` | `Rick` | <span data-ttu-id="f6d02-1573">URL을 생성하는 동안 비-매개 변수 값이 존재하도록 강제하는 데 사용됨</span><span class="sxs-lookup"><span data-stu-id="f6d02-1573">Used to enforce that a non-parameter value is present during URL generation</span></span> |

<span data-ttu-id="f6d02-1574">콜론으로 구분된 여러 개의 제약 조건을 단일 매개 변수에 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1574">Multiple, colon-delimited constraints can be applied to a single parameter.</span></span> <span data-ttu-id="f6d02-1575">예를 들어 다음 제약 조건은 매개 변수를 1 이상의 정수 값으로 제한합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1575">For example, the following constraint restricts a parameter to an integer value of 1 or greater:</span></span>

```csharp
[Route("users/{id:int:min(1)}")]
public User GetUserById(int id) { }
```

> [!WARNING]
> <span data-ttu-id="f6d02-1576">CLR 형식(예: `int` 또는 `DateTime`)으로 변환되는 URL을 확인하는 경로 제약 조건은 항상 고정 문화권을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1576">Route constraints that verify the URL and are converted to a CLR type (such as `int` or `DateTime`) always use the invariant culture.</span></span> <span data-ttu-id="f6d02-1577">이러한 제약 조건은 URL은 지역화될 수 없다고 가정합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1577">These constraints assume that the URL is non-localizable.</span></span> <span data-ttu-id="f6d02-1578">프레임워크에서 제공한 경로 제약 조건은 경로 값에 저장된 값을 수정하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1578">The framework-provided route constraints don't modify the values stored in route values.</span></span> <span data-ttu-id="f6d02-1579">URL에서 구문 분석되는 모든 경로 값은 문자열로 저장됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1579">All route values parsed from the URL are stored as strings.</span></span> <span data-ttu-id="f6d02-1580">예를 들어 `float` 제약 조건은 경로 값을 부동으로 변환하려고 하지만 변환된 값은 부동으로 변환될 수 있는지 확인하는 데만 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1580">For example, the `float` constraint attempts to convert the route value to a float, but the converted value is used only to verify it can be converted to a float.</span></span>

## <a name="regular-expressions"></a><span data-ttu-id="f6d02-1581">정규식</span><span class="sxs-lookup"><span data-stu-id="f6d02-1581">Regular expressions</span></span>

<span data-ttu-id="f6d02-1582">ASP.NET Core 프레임워크는 정규식 생성자에 `RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.CultureInvariant`를 추가합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1582">The ASP.NET Core framework adds `RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.CultureInvariant` to the regular expression constructor.</span></span> <span data-ttu-id="f6d02-1583">이러한 멤버에 대한 설명은 <xref:System.Text.RegularExpressions.RegexOptions>를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1583">See <xref:System.Text.RegularExpressions.RegexOptions> for a description of these members.</span></span>

<span data-ttu-id="f6d02-1584">정규식은 라우팅 및 C# 언어에서 사용하는 것과 유사한 구분 기호 및 토큰을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1584">Regular expressions use delimiters and tokens similar to those used by Routing and the C# language.</span></span> <span data-ttu-id="f6d02-1585">정규식 토큰은 이스케이프되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1585">Regular expression tokens must be escaped.</span></span> <span data-ttu-id="f6d02-1586">라우팅에서 `^\d{3}-\d{2}-\d{4}$`라는 정규식을 사용하려면, C# 소스 파일에서는 `\` 문자열 이스케이프 문자를 이스케이프하기 위해서 식 문자열의 `\`(단일 백슬래시) 문자를 `\\`(이중 백슬래시) 문자로 제공해야 합니다([약어 문자열 리터럴](/dotnet/csharp/language-reference/keywords/string)을 사용하지 않는 한).</span><span class="sxs-lookup"><span data-stu-id="f6d02-1586">To use the regular expression `^\d{3}-\d{2}-\d{4}$` in routing, the expression must have the `\` (single backslash) characters provided in the string as `\\` (double backslash) characters in the C# source file in order to escape the `\` string escape character (unless using [verbatim string literals](/dotnet/csharp/language-reference/keywords/string)).</span></span> <span data-ttu-id="f6d02-1587">라우팅 매개 변수 구분 기호 문자(`{`, `}`, `[`, `]`)를 이스케이프하려면 식에서 해당 문자를 이중으로 사용합니다(`{{`, `}`, `[[`, `]]`).</span><span class="sxs-lookup"><span data-stu-id="f6d02-1587">To escape routing parameter delimiter characters (`{`, `}`, `[`, `]`), double the characters in the expression (`{{`, `}`, `[[`, `]]`).</span></span> <span data-ttu-id="f6d02-1588">다음 표는 정규식 및 이스케이프된 버전을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1588">The following table shows a regular expression and the escaped version.</span></span>

| <span data-ttu-id="f6d02-1589">정규식</span><span class="sxs-lookup"><span data-stu-id="f6d02-1589">Regular Expression</span></span>    | <span data-ttu-id="f6d02-1590">이스케이프된 정규식</span><span class="sxs-lookup"><span data-stu-id="f6d02-1590">Escaped Regular Expression</span></span>     |
| --------------------- | ------------------------------ |
| `^\d{3}-\d{2}-\d{4}$` | `^\\d{{3}}-\\d{{2}}-\\d{{4}}$` |
| `^[a-z]{2}$`          | `^[[a-z]]{{2}}$`               |

<span data-ttu-id="f6d02-1591">라우팅에 사용되는 정규식은 캐럿(`^`) 문자로 시작하고 문자열의 시작 위치와 일치하는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1591">Regular expressions used in routing often start with the caret (`^`) character and match starting position of the string.</span></span> <span data-ttu-id="f6d02-1592">식은 달러 기호(`$`) 문자로 끝나고 문자열의 끝과 일치하는 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1592">The expressions often end with the dollar sign (`$`) character and match end of the string.</span></span> <span data-ttu-id="f6d02-1593">`^` 및 `$` 문자는 정규식이 전체 경로 매개 변수 값과 일치하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1593">The `^` and `$` characters ensure that the regular expression match the entire route parameter value.</span></span> <span data-ttu-id="f6d02-1594">`^` 및 `$` 문자가 없는 정규식은 문자열 내의 모든 하위 문자열과 일치하는데, 이는 종종 원하는 것이 아닙니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1594">Without the `^` and `$` characters, the regular expression match any substring within the string, which is often undesirable.</span></span> <span data-ttu-id="f6d02-1595">다음 표에서는 예제를 제공하고, 일치하거나 일치에 실패하는 이유를 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1595">The following table provides examples and explains why they match or fail to match.</span></span>

| <span data-ttu-id="f6d02-1596">식</span><span class="sxs-lookup"><span data-stu-id="f6d02-1596">Expression</span></span>   | <span data-ttu-id="f6d02-1597">String</span><span class="sxs-lookup"><span data-stu-id="f6d02-1597">String</span></span>    | <span data-ttu-id="f6d02-1598">일치</span><span class="sxs-lookup"><span data-stu-id="f6d02-1598">Match</span></span> | <span data-ttu-id="f6d02-1599">주석</span><span class="sxs-lookup"><span data-stu-id="f6d02-1599">Comment</span></span>               |
| ------------ | --------- | :---: |  -------------------- |
| `[a-z]{2}`   | <span data-ttu-id="f6d02-1600">hello</span><span class="sxs-lookup"><span data-stu-id="f6d02-1600">hello</span></span>     | <span data-ttu-id="f6d02-1601">예</span><span class="sxs-lookup"><span data-stu-id="f6d02-1601">Yes</span></span>   | <span data-ttu-id="f6d02-1602">부분 문자열 일치</span><span class="sxs-lookup"><span data-stu-id="f6d02-1602">Substring matches</span></span>     |
| `[a-z]{2}`   | <span data-ttu-id="f6d02-1603">123abc456</span><span class="sxs-lookup"><span data-stu-id="f6d02-1603">123abc456</span></span> | <span data-ttu-id="f6d02-1604">예</span><span class="sxs-lookup"><span data-stu-id="f6d02-1604">Yes</span></span>   | <span data-ttu-id="f6d02-1605">부분 문자열 일치</span><span class="sxs-lookup"><span data-stu-id="f6d02-1605">Substring matches</span></span>     |
| `[a-z]{2}`   | <span data-ttu-id="f6d02-1606">mz</span><span class="sxs-lookup"><span data-stu-id="f6d02-1606">mz</span></span>        | <span data-ttu-id="f6d02-1607">예</span><span class="sxs-lookup"><span data-stu-id="f6d02-1607">Yes</span></span>   | <span data-ttu-id="f6d02-1608">식 일치</span><span class="sxs-lookup"><span data-stu-id="f6d02-1608">Matches expression</span></span>    |
| `[a-z]{2}`   | <span data-ttu-id="f6d02-1609">MZ</span><span class="sxs-lookup"><span data-stu-id="f6d02-1609">MZ</span></span>        | <span data-ttu-id="f6d02-1610">예</span><span class="sxs-lookup"><span data-stu-id="f6d02-1610">Yes</span></span>   | <span data-ttu-id="f6d02-1611">대/소문자 구분하지 않음</span><span class="sxs-lookup"><span data-stu-id="f6d02-1611">Not case sensitive</span></span>    |
| `^[a-z]{2}$` | <span data-ttu-id="f6d02-1612">hello</span><span class="sxs-lookup"><span data-stu-id="f6d02-1612">hello</span></span>     | <span data-ttu-id="f6d02-1613">아니요</span><span class="sxs-lookup"><span data-stu-id="f6d02-1613">No</span></span>    | <span data-ttu-id="f6d02-1614">위의 `^` 및 `$` 참조</span><span class="sxs-lookup"><span data-stu-id="f6d02-1614">See `^` and `$` above</span></span> |
| `^[a-z]{2}$` | <span data-ttu-id="f6d02-1615">123abc456</span><span class="sxs-lookup"><span data-stu-id="f6d02-1615">123abc456</span></span> | <span data-ttu-id="f6d02-1616">아니요</span><span class="sxs-lookup"><span data-stu-id="f6d02-1616">No</span></span>    | <span data-ttu-id="f6d02-1617">위의 `^` 및 `$` 참조</span><span class="sxs-lookup"><span data-stu-id="f6d02-1617">See `^` and `$` above</span></span> |

<span data-ttu-id="f6d02-1618">정규식 구문에 대한 자세한 내용은 [.NET Framework 정규식](/dotnet/standard/base-types/regular-expression-language-quick-reference)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1618">For more information on regular expression syntax, see [.NET Framework Regular Expressions](/dotnet/standard/base-types/regular-expression-language-quick-reference).</span></span>

<span data-ttu-id="f6d02-1619">가능한 값의 알려진 집합으로 매개 변수를 제한하려면 정규식을 사용합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1619">To constrain a parameter to a known set of possible values, use a regular expression.</span></span> <span data-ttu-id="f6d02-1620">예를 들어 `{action:regex(^(list|get|create)$)}`는 `action` 경로 값을 `list`, `get` 또는 `create`으로만 일치시킵니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1620">For example, `{action:regex(^(list|get|create)$)}` only matches the `action` route value to `list`, `get`, or `create`.</span></span> <span data-ttu-id="f6d02-1621">제약 조건 사전으로 전달되면 `^(list|get|create)$` 문자열은 동일합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1621">If passed into the constraints dictionary, the string `^(list|get|create)$` is equivalent.</span></span> <span data-ttu-id="f6d02-1622">알려진 제약 조건 중 하나와 일치하지 않는 제약 조건 사전(템플릿 내 인라인이 아님)에서 전달되는 제약 조건도 정규식으로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1622">Constraints that are passed in the constraints dictionary (not inline within a template) that don't match one of the known constraints are also treated as regular expressions.</span></span>

## <a name="custom-route-constraints"></a><span data-ttu-id="f6d02-1623">사용자 지정 경로 제약 조건</span><span class="sxs-lookup"><span data-stu-id="f6d02-1623">Custom Route Constraints</span></span>

<span data-ttu-id="f6d02-1624">기본 제공 경로 제약 조건 외에도 <xref:Microsoft.AspNetCore.Routing.IRouteConstraint> 인터페이스를 구현하여 사용자 지정 경로 제약 조건을 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1624">In addition to the built-in route constraints, custom route constraints can be created by implementing the <xref:Microsoft.AspNetCore.Routing.IRouteConstraint> interface.</span></span> <span data-ttu-id="f6d02-1625"><xref:Microsoft.AspNetCore.Routing.IRouteConstraint> 인터페이스에는 제약 조건이 충족되는 경우 `true`를 반환하고 그렇지 않은 경우 `false`를 반환하는 `Match` 단일 메서드가 포함됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1625">The <xref:Microsoft.AspNetCore.Routing.IRouteConstraint> interface contains a single method, `Match`, which returns `true` if the constraint is satisfied and `false` otherwise.</span></span>

<span data-ttu-id="f6d02-1626">사용자 지정 <xref:Microsoft.AspNetCore.Routing.IRouteConstraint>를 사용하려면 앱의 서비스 컨테이너에 있는 앱의 <xref:Microsoft.AspNetCore.Routing.RouteOptions.ConstraintMap>에 경로 제약 조건 형식을 등록해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1626">To use a custom <xref:Microsoft.AspNetCore.Routing.IRouteConstraint>, the route constraint type must be registered with the app's <xref:Microsoft.AspNetCore.Routing.RouteOptions.ConstraintMap> in the app's service container.</span></span> <span data-ttu-id="f6d02-1627"><xref:Microsoft.AspNetCore.Routing.RouteOptions.ConstraintMap>은 경로 제약 조건 키를 해당 제약 조건의 유효성을 검사하는 <xref:Microsoft.AspNetCore.Routing.IRouteConstraint> 구현과 매핑하는 사전입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1627">A <xref:Microsoft.AspNetCore.Routing.RouteOptions.ConstraintMap> is a dictionary that maps route constraint keys to <xref:Microsoft.AspNetCore.Routing.IRouteConstraint> implementations that validate those constraints.</span></span> <span data-ttu-id="f6d02-1628">`Startup.ConfigureServices`에서 [services.AddRouting](xref:Microsoft.Extensions.DependencyInjection.RoutingServiceCollectionExtensions.AddRouting*) 호출의 일부로 또는 `services.Configure<RouteOptions>`를 사용하여 직접 <xref:Microsoft.AspNetCore.Routing.RouteOptions>를 구성하여 앱의 <xref:Microsoft.AspNetCore.Routing.RouteOptions.ConstraintMap>을 수정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1628">An app's <xref:Microsoft.AspNetCore.Routing.RouteOptions.ConstraintMap> can be updated in `Startup.ConfigureServices` either as part of a [services.AddRouting](xref:Microsoft.Extensions.DependencyInjection.RoutingServiceCollectionExtensions.AddRouting*) call or by configuring <xref:Microsoft.AspNetCore.Routing.RouteOptions> directly with `services.Configure<RouteOptions>`.</span></span> <span data-ttu-id="f6d02-1629">예를 들어:</span><span class="sxs-lookup"><span data-stu-id="f6d02-1629">For example:</span></span>

```csharp
services.AddRouting(options =>
{
    options.ConstraintMap.Add("customName", typeof(MyCustomConstraint));
});
```

<span data-ttu-id="f6d02-1630">이제 제약 조건 형식을 등록할 때 지정한 이름을 사용하여 일반적인 방식으로 제약 조건을 경로에 적용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1630">The constraint can then be applied to routes in the usual manner, using the name specified when registering the constraint type.</span></span> <span data-ttu-id="f6d02-1631">예를 들어:</span><span class="sxs-lookup"><span data-stu-id="f6d02-1631">For example:</span></span>

```csharp
[HttpGet("{id:customName}")]
public ActionResult<string> Get(string id)
```

## <a name="url-generation-reference"></a><span data-ttu-id="f6d02-1632">URL 생성 참조</span><span class="sxs-lookup"><span data-stu-id="f6d02-1632">URL generation reference</span></span>

<span data-ttu-id="f6d02-1633">다음 예제에서는 경로 값의 사전 및 <xref:Microsoft.AspNetCore.Routing.RouteCollection>이 지정된 경로에 대한 링크를 생성하는 방법을 보여줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1633">The following example shows how to generate a link to a route given a dictionary of route values and a <xref:Microsoft.AspNetCore.Routing.RouteCollection>.</span></span>

[!code-csharp[](routing/samples/2.x/RoutingSample/Startup.cs?name=snippet_Dictionary)]

<span data-ttu-id="f6d02-1634">위의 샘플 끝부분에서 생성된 <xref:Microsoft.AspNetCore.Routing.VirtualPathData.VirtualPath>는 `/package/create/123`입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1634">The <xref:Microsoft.AspNetCore.Routing.VirtualPathData.VirtualPath> generated at the end of the preceding sample is `/package/create/123`.</span></span> <span data-ttu-id="f6d02-1635">사전은 "Track Package Route" 템플릿인 `package/{operation}/{id}`의 `operation` 및 `id` 경로 값을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1635">The dictionary supplies the `operation` and `id` route values of the "Track Package Route" template, `package/{operation}/{id}`.</span></span> <span data-ttu-id="f6d02-1636">자세한 내용은 [라우팅 미들웨어 사용](#use-routing-middleware) 섹션의 샘플 코드 또는 [샘플 앱](https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/routing/samples)을 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1636">For details, see the sample code in the [Use Routing Middleware](#use-routing-middleware) section or the [sample app](https://github.com/dotnet/AspNetCore.Docs/tree/master/aspnetcore/fundamentals/routing/samples).</span></span>

<span data-ttu-id="f6d02-1637"><xref:Microsoft.AspNetCore.Routing.VirtualPathContext> 생성자에 대한 두 번째 매개 변수는 *앰비언트 값*의 컬렉션입니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1637">The second parameter to the <xref:Microsoft.AspNetCore.Routing.VirtualPathContext> constructor is a collection of *ambient values*.</span></span> <span data-ttu-id="f6d02-1638">개발자가 요청 컨텍스트 내에서 지정해야 하는 값의 수를 제한하므로 앰비언트 값은 사용하기 편리합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1638">Ambient values are convenient to use because they limit the number of values a developer must specify within a request context.</span></span> <span data-ttu-id="f6d02-1639">현재 요청의 현재 경로 값은 링크 생성에 대한 앰비언트 값으로 간주됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1639">The current route values of the current request are considered ambient values for link generation.</span></span> <span data-ttu-id="f6d02-1640">ASP.NET Core MVC 앱의 `HomeController`에 대한 `About` 작업에서는 `Index` 작업에 연결하기 위해 컨트롤러 경로 값을 지정할 필요가 없으며, `Home`이라는 앰비언트 값이 사용됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1640">In an ASP.NET Core MVC app's `About` action of the `HomeController`, you don't need to specify the controller route value to link to the `Index` action&mdash;the ambient value of `Home` is used.</span></span>

<span data-ttu-id="f6d02-1641">매개 변수와 일치하지 않는 앰비언트 값은 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1641">Ambient values that don't match a parameter are ignored.</span></span> <span data-ttu-id="f6d02-1642">명시적으로 제공된 값이 앰비언트 값을 재정의하는 경우에도 앰비언트 값이 무시됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1642">Ambient values are also ignored when an explicitly provided value overrides the ambient value.</span></span> <span data-ttu-id="f6d02-1643">URL에서 일치는 왼쪽에서 오른쪽으로 수행됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1643">Matching occurs from left to right in the URL.</span></span>

<span data-ttu-id="f6d02-1644">명시적으로 제공되지만 경로의 세그먼트와 일치하지 않는 값은 쿼리 문자열에 추가됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1644">Values explicitly provided but that don't match a segment of the route are added to the query string.</span></span> <span data-ttu-id="f6d02-1645">다음 표에서 경로 템플릿 `{controller}/{action}/{id?}`를 사용하는 경우 결과를 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1645">The following table shows the result when using the route template `{controller}/{action}/{id?}`.</span></span>

| <span data-ttu-id="f6d02-1646">앰비언트 값</span><span class="sxs-lookup"><span data-stu-id="f6d02-1646">Ambient Values</span></span>                     | <span data-ttu-id="f6d02-1647">명시적 값</span><span class="sxs-lookup"><span data-stu-id="f6d02-1647">Explicit Values</span></span>                        | <span data-ttu-id="f6d02-1648">결과</span><span class="sxs-lookup"><span data-stu-id="f6d02-1648">Result</span></span>                  |
| ---------------------------------- | -------------------------------------- | ----------------------- |
| <span data-ttu-id="f6d02-1649">controller = "Home"</span><span class="sxs-lookup"><span data-stu-id="f6d02-1649">controller = "Home"</span></span>                | <span data-ttu-id="f6d02-1650">action = "About"</span><span class="sxs-lookup"><span data-stu-id="f6d02-1650">action = "About"</span></span>                       | `/Home/About`           |
| <span data-ttu-id="f6d02-1651">controller = "Home"</span><span class="sxs-lookup"><span data-stu-id="f6d02-1651">controller = "Home"</span></span>                | <span data-ttu-id="f6d02-1652">controller = "Order", action = "About"</span><span class="sxs-lookup"><span data-stu-id="f6d02-1652">controller = "Order", action = "About"</span></span> | `/Order/About`          |
| <span data-ttu-id="f6d02-1653">controller = "Home", color = "Red"</span><span class="sxs-lookup"><span data-stu-id="f6d02-1653">controller = "Home", color = "Red"</span></span> | <span data-ttu-id="f6d02-1654">action = "About"</span><span class="sxs-lookup"><span data-stu-id="f6d02-1654">action = "About"</span></span>                       | `/Home/About`           |
| <span data-ttu-id="f6d02-1655">controller = "Home"</span><span class="sxs-lookup"><span data-stu-id="f6d02-1655">controller = "Home"</span></span>                | <span data-ttu-id="f6d02-1656">action = "About", color = "Red"</span><span class="sxs-lookup"><span data-stu-id="f6d02-1656">action = "About", color = "Red"</span></span>        | `/Home/About?color=Red` |

<span data-ttu-id="f6d02-1657">경로에 매개 변수에 해당하지 않고 값이 명시적으로 제공된 기본값이 있는 경우 기본값과 일치해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1657">If a route has a default value that doesn't correspond to a parameter and that value is explicitly provided, it must match the default value:</span></span>

```csharp
routes.MapRoute("blog_route", "blog/{*slug}",
    defaults: new { controller = "Blog", action = "ReadPost" });
```

<span data-ttu-id="f6d02-1658">`controller` 및 `action`에 대해 일치하는 값이 제공되는 경우에만 링크 생성에서 이 경로에 대한 링크를 생성합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1658">Link generation only generates a link for this route when the matching values for `controller` and `action` are provided.</span></span>

## <a name="complex-segments"></a><span data-ttu-id="f6d02-1659">복잡한 세그먼트</span><span class="sxs-lookup"><span data-stu-id="f6d02-1659">Complex segments</span></span>

<span data-ttu-id="f6d02-1660">복잡한 세그먼트(예: `[Route("/x{token}y")]`)는 non-greedy 방식으로 오른쪽에서 왼쪽으로 리터럴을 매칭하여 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1660">Complex segments (for example `[Route("/x{token}y")]`) are processed by matching up literals from right to left in a non-greedy way.</span></span> <span data-ttu-id="f6d02-1661">복잡한 세그먼트 일치 방법에 대한 자세한 설명은 [이 코드](https://github.com/aspnet/AspNetCore/blob/release/2.2/src/Http/Routing/src/Patterns/RoutePatternMatcher.cs#L293)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1661">See [this code](https://github.com/aspnet/AspNetCore/blob/release/2.2/src/Http/Routing/src/Patterns/RoutePatternMatcher.cs#L293) for a detailed explanation of how complex segments are matched.</span></span> <span data-ttu-id="f6d02-1662">[코드 샘플](https://github.com/aspnet/AspNetCore/blob/release/2.2/src/Http/Routing/src/Patterns/RoutePatternMatcher.cs#L293)은 ASP.NET Core에서 사용되지 않지만 복잡한 세그먼트에 대한 적절한 설명을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="f6d02-1662">The [code sample](https://github.com/aspnet/AspNetCore/blob/release/2.2/src/Http/Routing/src/Patterns/RoutePatternMatcher.cs#L293) is not used by ASP.NET Core, but it provides a good explanation of complex segments.</span></span>

::: moniker-end
