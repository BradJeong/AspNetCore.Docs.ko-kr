---
uid: web-api/overview/error-handling/web-api-global-error-handling
title: "ASP.NET Web API 2 처리 하는 전역 오류 | Microsoft Docs"
author: davidmatson
description: 
ms.author: aspnetcontent
manager: wpickett
ms.date: 02/03/2014
ms.topic: article
ms.assetid: bffd7863-f63b-4b23-a13c-372b5492e9fb
ms.technology: dotnet-webapi
ms.prod: .net-framework
msc.legacyurl: /web-api/overview/error-handling/web-api-global-error-handling
msc.type: authoredcontent
ms.openlocfilehash: d2bdf04b4da2a099f3a2af100b16682c68f946f2
ms.sourcegitcommit: 9a9483aceb34591c97451997036a9120c3fe2baf
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/10/2017
---
<a name="global-error-handling-in-aspnet-web-api-2"></a><span data-ttu-id="346e8-102">ASP.NET Web API 2 처리 하는 전역 오류</span><span class="sxs-lookup"><span data-stu-id="346e8-102">Global Error Handling in ASP.NET Web API 2</span></span>
====================
<span data-ttu-id="346e8-103">여 [David Matson](https://github.com/davidmatson), [Rick Anderson](https://github.com/Rick-Anderson)</span><span class="sxs-lookup"><span data-stu-id="346e8-103">by [David Matson](https://github.com/davidmatson), [Rick Anderson](https://github.com/Rick-Anderson)</span></span>

<span data-ttu-id="346e8-104">오늘날에 없는 경우 쉽게 웹 API를 로그 또는 오류를 전체적으로 처리</span><span class="sxs-lookup"><span data-stu-id="346e8-104">Today there's no easy way in Web API to log or handle errors globally.</span></span> <span data-ttu-id="346e8-105">일부 처리 되지 않은 예외를 통해 처리할 수 [예외 필터](exception-handling.md), 하지만 예외 필터를 처리할 수 없는 사례의 수는 있습니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-105">Some unhandled exceptions can be processed via [exception filters](exception-handling.md), but there are a number of cases that exception filters can't handle.</span></span> <span data-ttu-id="346e8-106">예:</span><span class="sxs-lookup"><span data-stu-id="346e8-106">For example:</span></span>

1. <span data-ttu-id="346e8-107">컨트롤러 생성자에서 throw 된 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-107">Exceptions thrown from controller constructors.</span></span>
2. <span data-ttu-id="346e8-108">메시지 처리기에서 throw 된 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-108">Exceptions thrown from message handlers.</span></span>
3. <span data-ttu-id="346e8-109">라우팅 중 발생 한 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-109">Exceptions thrown during routing.</span></span>
4. <span data-ttu-id="346e8-110">응답 콘텐츠 직렬화 하는 동안 발생 한 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-110">Exceptions thrown during response content serialization .</span></span>

<span data-ttu-id="346e8-111">로그 (사용 가능한) 위치를 처리 하는 간단 하 고 일관 된 방법을 제공 하고자 합니다. 이러한 예외입니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-111">We want to provide a simple, consistent way to log and handle (where possible) these exceptions.</span></span> 

<span data-ttu-id="346e8-112">예외 처리, 오류 응답을 보낼 수 있는 모든 할 수 있는 하는 경우에는 로그의 예외는 경우 두 가지 주요 사례가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-112">There are two major cases for handling exceptions, the case where we are able to send an error response and the case where all we can do is log the exception.</span></span> <span data-ttu-id="346e8-113">후자의 경우에 대 한 예로 응답 콘텐츠; 스트리밍 도중에 예외가 발생 한 경우 이 경우에 너무 늦었습니다 상태 코드, 헤더 및 부분 콘텐츠 이미 인스턴스용으로 통해 연결 중단 되므로 이후 새 응답 메시지를 보내려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-113">An example for the latter case is when an exception is thrown in the middle of streaming response content; in that case it is too late to send a new response message since the status code, headers, and partial content have already gone across the wire, so we simply abort the connection.</span></span> <span data-ttu-id="346e8-114">예외를 새 응답 메시지를 생성 하기 위해 처리할 수 없는 경우에 여전히 지원에서 예외 기록입니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-114">Even though the exception can't be handled to produce a new response message, we still support logging the exception.</span></span> <span data-ttu-id="346e8-115">오류가 탐지 수의 경우에서 다음에 표시 된 대로 적절 한 오류 응답을 반환할 수 있습니다 했습니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-115">In cases where we can detect an error, we can return an appropriate error response as shown in the following:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample1.cs?highlight=6)]

### <a name="existing-options"></a><span data-ttu-id="346e8-116">기존 옵션</span><span class="sxs-lookup"><span data-stu-id="346e8-116">Existing Options</span></span>

<span data-ttu-id="346e8-117">외에 [예외 필터](exception-handling.md), [메시지 처리기](../advanced/http-message-handlers.md) 모든 500 수준 응답을 관찰 하려면 현재 사용할 수 있지만 해당 응답에서 작업 어렵습니다 원래 오류에 대 한 컨텍스트를 부족으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-117">In addition to [exception filters](exception-handling.md), [message handlers](../advanced/http-message-handlers.md) can be used today to observe all 500-level responses, but acting on those responses is difficult, as they lack context about the original error.</span></span> <span data-ttu-id="346e8-118">메시지 처리기 갖게 몇몇 처리할 수 있도록 하는 경우와 관련 된 예외 필터와 동일한 제한 사항이 적용 됩니다. 웹 API에는 오류 상태를 캡처하는 추적 인프라는 동안 추적 인프라는 진단 하기 위한 것 및은 not 설계 또는 프로덕션 환경에서 실행 하는 데 적합 합니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-118">Message handlers also have some of the same limitations as exception filters regarding the cases they can handle.While Web API does have tracing infrastructure that captures error conditions the tracing infrastructure is for diagnostics purposes and is not designed or suited for running in production environments.</span></span> <span data-ttu-id="346e8-119">전역 예외 처리 및 로깅 서비스를 프로덕션에 실행할 수 있으며 기존 모니터링 솔루션에 연결할 수 있어야 합니다. (예를 들어 [ELMAH](https://code.google.com/p/elmah/) ).</span><span class="sxs-lookup"><span data-stu-id="346e8-119">Global exception handling and logging should be services that can run during production and be plugged into existing monitoring solutions (for example, [ELMAH](https://code.google.com/p/elmah/) ).</span></span>

### <a name="solution-overview"></a><span data-ttu-id="346e8-120">솔루션 개요</span><span class="sxs-lookup"><span data-stu-id="346e8-120">Solution Overview</span></span>

 <span data-ttu-id="346e8-121">두 가지 새 사용자를 바꿀 수 있는 서비스 제공 [IExceptionLogger](../releases/whats-new-in-aspnet-web-api-21.md) IExceptionHandler 로그 처리 되지 않은 예외를 처리 하 고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-121">We provide two new user-replaceable services, [IExceptionLogger](../releases/whats-new-in-aspnet-web-api-21.md) and IExceptionHandler, to log and handle unhandled exceptions.</span></span> <span data-ttu-id="346e8-122">서비스는 두 가지 주요 차이점은 있지만 매우 유사 합니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-122">The services are very similar, with two main differences:</span></span>

1. <span data-ttu-id="346e8-123">예외로 거를 여러 개 있지만 한 개의 예외 처리기 등록을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-123">We support registering multiple exception loggers but only a single exception handler.</span></span>
2. <span data-ttu-id="346e8-124">예외로 거 항상 호출 연결을 중단 하려고 하는 경우에 합니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-124">Exception loggers always get called, even if we're about to abort the connection.</span></span> <span data-ttu-id="346e8-125">예외 처리기만 호출 여전히 보낼 응답 메시지를 선택할 수 있을 때.</span><span class="sxs-lookup"><span data-stu-id="346e8-125">Exception handlers only get called when we're still able to choose which response message to send.</span></span>

<span data-ttu-id="346e8-126">두 서비스 모두 예외 감지 되었으며 지점에서 관련 정보를 포함 하는 예외 컨텍스트에 대 한 액세스를 제공 특히 [HttpRequestMessage](https://msdn.microsoft.com/en-us/library/system.net.http.httprequestmessage(v=vs.110).aspx), [HttpRequestContext](https://msdn.microsoft.com/en-us/library/system.web.http.controllers.httprequestcontext(v=vs.118).aspx), 예외 및 예외 원본 (아래의 세부 정보)를 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-126">Both services provide access to an exception context containing relevant information from the point where the exception was detected, particularly the [HttpRequestMessage](https://msdn.microsoft.com/en-us/library/system.net.http.httprequestmessage(v=vs.110).aspx), the [HttpRequestContext](https://msdn.microsoft.com/en-us/library/system.web.http.controllers.httprequestcontext(v=vs.118).aspx), the thrown exception and the exception source (details below).</span></span>

### <a name="design-principles"></a><span data-ttu-id="346e8-127">디자인 원칙</span><span class="sxs-lookup"><span data-stu-id="346e8-127">Design Principles</span></span>

1. <span data-ttu-id="346e8-128">**주요 변경 내용이 없습니다** 이 기능은 중요 한 한 솔루션에 영향을 주지는 중요 한 제약 조건이 있을 다음 주요 변경 내용이 없습니다, 계약을 입력 하도록 하는 릴리스 또는 동작에 추가 되 고 않기 때문입니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-128">**No breaking changes** Because this functionality is being added in a minor release, one important constraint impacting the solution is that there be no breaking changes, either to type contracts or to behavior.</span></span> <span data-ttu-id="346e8-129">이 제약 조건은 500 응답에 예외를 설정 하는 기존 catch 블록의 관점에서 수행 하려는 일부 정리를 제외 합니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-129">This constraint ruled out some cleanup we would like to have done in terms of existing catch blocks turning exceptions into 500 responses.</span></span> <span data-ttu-id="346e8-130">이 추가 정리는 후속 버전에 대 한 것으로 간주 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-130">This additional cleanup is something we might consider for a subsequent major release.</span></span> <span data-ttu-id="346e8-131">이를 중요 한 경우 하십시오 투표에 [ASP.NET Web API 사용자 음성](http://aspnet.uservoice.com/forums/147201-asp-net-web-api/suggestions/5451321-add-flag-to-enable-iexceptionlogger-and-iexception)합니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-131">If this is important to you please vote on it at [ASP.NET Web API user voice](http://aspnet.uservoice.com/forums/147201-asp-net-web-api/suggestions/5451321-add-flag-to-enable-iexceptionlogger-and-iexception).</span></span>
2. <span data-ttu-id="346e8-132">**웹 API와의 일관성을 유지 관리 생성** 웹 API 필터 파이프라인은 특정 작업, 컨트롤러 관련 또는 전역 범위에서 논리를 적용 하는 유연성과 일반적인 문제를 처리할 수 있는 좋은 방법입니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-132">**Maintaining consistency with Web API constructs** Web API's filter pipeline is a great way to handle cross-cutting concerns with the flexibility of applying the logic at an action-specific, controller-specific or global scope.</span></span> <span data-ttu-id="346e8-133">예외 필터를 포함 하 여 필터를 전역 범위에서 등록 하는 경우에 작업 및 컨트롤러 컨텍스트를 항상 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-133">Filters, including exception filters, always have action and controller contexts, even when registered at the global scope.</span></span> <span data-ttu-id="346e8-134">계약에 적합 한 필터를 있지만 예외 필터도 전역 범위가 지정 된 것과 되지 적합 한 경우 작업이 나 컨트롤러 컨텍스트가 없는 경우와 같은 메시지 처리기에서 예외를 처리 하는 일부 예외에 대 한 해당 의미 존재 합니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-134">That contract makes sense for filters, but it means that exception filters, even globally scoped ones, aren't a good fit for some exception handling cases, such as exceptions from message handlers, where no action or controller context exists.</span></span> <span data-ttu-id="346e8-135">예외 처리에 대 한 필터에 의해 제공 유연한 범위 지정을 사용 하고자 하는 경우 예외 필터 여전히 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-135">If we want to use the flexible scoping afforded by filters for exception handling, we still need exception filters.</span></span> <span data-ttu-id="346e8-136">하지만 (항목 합계의 컨트롤러 컨텍스트와 작업 컨텍스트 제약 조건) 없이 전체 전역 오류 처리에는 별도 구문, 컨트롤러 컨텍스트 외부의 예외를 처리 해야 하는 경우도 필요 합니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-136">But if we need to handle exception outside of a controller context, we also need a separate construct for full global error handling (something without the controller context and action context constraints).</span></span>

### <a name="when-to-use"></a><span data-ttu-id="346e8-137">사용 하는 경우</span><span class="sxs-lookup"><span data-stu-id="346e8-137">When to Use</span></span>

- <span data-ttu-id="346e8-138">예외로 거는 Web API에서 발생 하는 모든 처리 되지 않은 예외를 표시할 때 솔루션입니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-138">Exception loggers are the solution to seeing all unhandled exception caught by Web API.</span></span>
- <span data-ttu-id="346e8-139">예외 처리기는 Web API에서 발생 하는 처리 되지 않은 예외에 대 한 모든 가능한 응답을 사용자 지정 하기 위한 솔루션입니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-139">Exception handlers are the solution for customizing all possible responses to unhandled exceptions caught by Web API.</span></span>
- <span data-ttu-id="346e8-140">예외 필터는 특정 작업이 나 컨트롤러에 관련 된 하위 집합 처리 되지 않은 예외 처리를 위한 것이 간편한 해결책입니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-140">Exception filters are the easiest solution for processing the subset unhandled exceptions related to a specific action or controller.</span></span>

### <a name="service-details"></a><span data-ttu-id="346e8-141">서비스 세부 정보</span><span class="sxs-lookup"><span data-stu-id="346e8-141">Service Details</span></span>

 <span data-ttu-id="346e8-142">예외로 거 및 처리기 서비스 인터페이스에는 각 컨텍스트에 라인으로 전환 하는 간단한 비동기 메서드는 같습니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-142">The exception logger and handler service interfaces are simple async methods taking the respective contexts:</span></span> 

[!code-csharp[Main](web-api-global-error-handling/samples/sample2.cs)]

 <span data-ttu-id="346e8-143">두이 인터페이스에 대 한 기본 클래스도 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-143">We also provide base classes for both of these interfaces.</span></span> <span data-ttu-id="346e8-144">코어 (동기화 또는 비동기) 메서드를 재정의 뿐 로깅하거나에 권장 되는 처리 하는 데 걸리는 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-144">Overriding the core (sync or async) methods is all that is required to log or handle at the recommended times.</span></span> <span data-ttu-id="346e8-145">로깅을 위한는 `ExceptionLogger` 기본 클래스는 핵심 로깅 방법 각 예외에 대해 한 번씩 호출 됩니다만 확인 (나중에 전파 하는 경우에 추가로 호출 스택을 하 고 다시 발생 함).</span><span class="sxs-lookup"><span data-stu-id="346e8-145">For logging, the `ExceptionLogger` base class will ensure that the core logging method is only called once for each exception (even if it later propagates further up the call stack and is caught again).</span></span> <span data-ttu-id="346e8-146">`ExceptionHandler` 기본 클래스 핵심 처리 중첩 레거시 무시 하 고는 호출 스택의 맨 위에 있는 예외 catch 블록에 대해서만 메서드를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-146">The `ExceptionHandler` base class will call the core handling method only for exceptions at the top of the call stack, ignoring legacy nested catch blocks.</span></span> <span data-ttu-id="346e8-147">(이러한 기본 클래스의 단순화 된 버전은 아래 부록.) 둘 다 `IExceptionLogger` 및 `IExceptionHandler` 통해 예외에 대 한 정보를 받을 `ExceptionContext`합니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-147">(Simplified versions of these base classes are in the appendix below.) Both `IExceptionLogger` and `IExceptionHandler` receive information about the exception via an `ExceptionContext`.</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample3.cs)]

<span data-ttu-id="346e8-148">항상 제공 프레임 워크는 예외로 거 또는 예외 처리기를 호출 하면 프로그램 `Exception` 및 `Request`합니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-148">When the framework calls an exception logger or an exception handler, it will always provide an `Exception` and a `Request`.</span></span> <span data-ttu-id="346e8-149">단위 테스트의 경우를 제외 하 고 제공 항상 합니다는 `RequestContext`합니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-149">Except for unit testing, it will also always provide a `RequestContext`.</span></span> <span data-ttu-id="346e8-150">거의 제공는 `ControllerContext` 및 `ActionContext` (경우에 예외 필터에 대 한 catch 블록에서 호출).</span><span class="sxs-lookup"><span data-stu-id="346e8-150">It will rarely provide a `ControllerContext` and `ActionContext` (only when calling from the catch block for exception filters).</span></span> <span data-ttu-id="346e8-151">매우 드물게 제공는 `Response`(응답을 기록 하는 동안 중간 특정 IIS 경우)에 해당 합니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-151">It will very rarely provide a `Response`(only in certain IIS cases when in the middle of trying to write the response).</span></span> <span data-ttu-id="346e8-152">이러한 속성 중 일부를 수 있기 때문에 사용자에 게 유의 `null` 를 확인 하려면 소비자가 `null` 예외 클래스의 멤버에 액세스 하기 전에.`CatchBlock`</span><span class="sxs-lookup"><span data-stu-id="346e8-152">Note that because some of these properties may be `null` it is up to the consumer to check for `null` before accessing members of the exception class.`CatchBlock`</span></span> <span data-ttu-id="346e8-153">예외는 catch 블록 보여 준다는 나타내는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-153">is a string indicating which catch block saw the exception.</span></span> <span data-ttu-id="346e8-154">Catch 블록 문자열은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-154">The catch block strings are as follows:</span></span>

- <span data-ttu-id="346e8-155">HttpServer (SendAsync 메서드)</span><span class="sxs-lookup"><span data-stu-id="346e8-155">HttpServer (SendAsync method)</span></span>
- <span data-ttu-id="346e8-156">HttpControllerDispatcher (SendAsync 메서드)</span><span class="sxs-lookup"><span data-stu-id="346e8-156">HttpControllerDispatcher (SendAsync method)</span></span>
- <span data-ttu-id="346e8-157">HttpBatchHandler (SendAsync 메서드)</span><span class="sxs-lookup"><span data-stu-id="346e8-157">HttpBatchHandler (SendAsync method)</span></span>
- <span data-ttu-id="346e8-158">IExceptionFilter (ExecuteAsync의 예외 필터 파이프라인 ApiController의 처리)</span><span class="sxs-lookup"><span data-stu-id="346e8-158">IExceptionFilter (ApiController's processing of the exception filter pipeline in ExecuteAsync)</span></span>
- <span data-ttu-id="346e8-159">OWIN 호스트:</span><span class="sxs-lookup"><span data-stu-id="346e8-159">OWIN host:</span></span>

    - <span data-ttu-id="346e8-160">HttpMessageHandlerAdapter.BufferResponseContentAsync (에 대 한 출력을 버퍼링)</span><span class="sxs-lookup"><span data-stu-id="346e8-160">HttpMessageHandlerAdapter.BufferResponseContentAsync (for buffering output)</span></span>
    - <span data-ttu-id="346e8-161">HttpMessageHandlerAdapter.CopyResponseContentAsync (스트리밍에 대 한 출력)</span><span class="sxs-lookup"><span data-stu-id="346e8-161">HttpMessageHandlerAdapter.CopyResponseContentAsync (for streaming output)</span></span>
- <span data-ttu-id="346e8-162">웹 호스트:</span><span class="sxs-lookup"><span data-stu-id="346e8-162">Web host:</span></span>

    - <span data-ttu-id="346e8-163">HttpControllerHandler.WriteBufferedResponseContentAsync (에 대 한 출력을 버퍼링)</span><span class="sxs-lookup"><span data-stu-id="346e8-163">HttpControllerHandler.WriteBufferedResponseContentAsync (for buffering output)</span></span>
    - <span data-ttu-id="346e8-164">HttpControllerHandler.WriteStreamedResponseContentAsync (스트리밍에 대 한 출력)</span><span class="sxs-lookup"><span data-stu-id="346e8-164">HttpControllerHandler.WriteStreamedResponseContentAsync (for streaming output)</span></span>
    - <span data-ttu-id="346e8-165">HttpControllerHandler.WriteErrorResponseContentAsync (실패에 대 한 오류 복구 버퍼링 된 출력 모드에서)</span><span class="sxs-lookup"><span data-stu-id="346e8-165">HttpControllerHandler.WriteErrorResponseContentAsync (for failures in error recovery under buffered output mode)</span></span>

<span data-ttu-id="346e8-166">Catch 블록 문자열 목록에도 정적 읽기 전용 속성을 통해 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-166">The list of catch block strings is also available via static readonly properties.</span></span> <span data-ttu-id="346e8-167">(코어 catch 블록 문자열 정적 ExceptionCatchBlocks에 있습니다; 하나의 정적 클래스에 각 OWIN 및 웹 호스트에 대 한 나머지 표시) 됩니다.`IsTopLevelCatchBlock`</span><span class="sxs-lookup"><span data-stu-id="346e8-167">(The core catch block string are on the static ExceptionCatchBlocks; the remainder appear on one static class each for OWIN and web host).`IsTopLevelCatchBlock`</span></span> <span data-ttu-id="346e8-168">호출 스택의 위쪽에만 예외 처리의 패턴을 권장 하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-168">is helpful for following the recommended pattern of handling exceptions only at the top of the call stack.</span></span> <span data-ttu-id="346e8-169">원하는 위치에 중첩 된 catch 블록에서 발생 500 응답에 예외를 설정 하는 대신 예외 처리기에서 예외 전파를 호스트에서 볼 수는 때까지 설정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-169">Rather than turning exceptions into 500 responses anywhere a nested catch block occurs, an exception handler can let exceptions propagate until they are about to be seen by the host.</span></span>

<span data-ttu-id="346e8-170">이외에 `ExceptionContext`로 거를 통해 전체 정보의 한 더 많은 요소를 가져옵니다 `ExceptionLoggerContext`:</span><span class="sxs-lookup"><span data-stu-id="346e8-170">In addition to the `ExceptionContext`, a logger gets one more piece of information via the full `ExceptionLoggerContext`:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample4.cs)]

<span data-ttu-id="346e8-171">두 번째 속성 `CanBeHandled`를 처리할 수 없는 예외를 식별 하는 거를 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-171">The second property, `CanBeHandled`, allows a logger to identify an exception that cannot be handled.</span></span> <span data-ttu-id="346e8-172">때 연결이 중단 되 고 없는 새 응답 메시지를 보낼 수, 호출 되는 거 하지 않지만 처리기 ***하지*** 호출할 수는 거는이 시나리오에서이 속성을 식별할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-172">When the connection is about to be aborted and no new response message can be sent, the loggers will be called but the handler will ***not*** be called, and the loggers can identify this scenario from this property.</span></span>

<span data-ttu-id="346e8-173">변수에 대 한 추가 `ExceptionContext`, 처리기 전체에 설정할 수는 한 더 많은 속성을 가져옵니다 `ExceptionHandlerContext` 예외를 처리:</span><span class="sxs-lookup"><span data-stu-id="346e8-173">In additional to the `ExceptionContext`, a handler gets one more property it can set on the full `ExceptionHandlerContext` to handle the exception:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample5.cs)]

<span data-ttu-id="346e8-174">예외 처리기를 설정 하 여 예외가 처리 했음을 나타냅니다는 `Result` 작업 결과를 속성 (예를 들어 한 [ExceptionResult](https://msdn.microsoft.com/en-us/library/system.web.http.results.exceptionresult(v=vs.118).aspx), [InternalServerErrorResult](https://msdn.microsoft.com/en-us/library/system.web.http.results.internalservererrorresult(v=vs.118).aspx), [ StatusCodeResult](https://msdn.microsoft.com/en-us/library/system.web.http.results.statuscoderesult(v=vs.118).aspx), 또는 사용자 지정 결과).</span><span class="sxs-lookup"><span data-stu-id="346e8-174">An exception handler indicates that it has handled an exception by setting the `Result` property to an action result (for example, an [ExceptionResult](https://msdn.microsoft.com/en-us/library/system.web.http.results.exceptionresult(v=vs.118).aspx), [InternalServerErrorResult](https://msdn.microsoft.com/en-us/library/system.web.http.results.internalservererrorresult(v=vs.118).aspx), [StatusCodeResult](https://msdn.microsoft.com/en-us/library/system.web.http.results.statuscoderesult(v=vs.118).aspx), or a custom result).</span></span> <span data-ttu-id="346e8-175">경우는 `Result` 속성이 null 이므로, 예외 처리 되지 않은 및 원래의 예외가 다시 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-175">If the `Result` property is null, the exception is unhandled and the original exception will be re-thrown.</span></span>

<span data-ttu-id="346e8-176">호출 스택의 맨 위에 있는 예외에 대 한 별도 단계 API 호출자에 대 한 적절 한 응답 되는지 했습니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-176">For exceptions at the top of the call stack, we took an extra step to ensure the response is appropriate for API callers.</span></span> <span data-ttu-id="346e8-177">호스트에서 예외 전파를 호출자에 게 사망의 노란색 화면 표시 되는 것 또는 HTML는 일반적으로 응답 하 고 적절 한 API 오류 응답 하지 않는 다른 호스트에서 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-177">If the exception propagates up to the host, the caller would see the yellow screen of death or some other host provided response which is typically HTML and not usually an appropriate API error response.</span></span> <span data-ttu-id="346e8-178">이러한 경우에 null이 아닌 및 사용자 지정 예외 처리기가 명시적으로 설정 하는 경우에 결과 시작 다시 `null` (처리 되지 않은)은 예외 전파는 호스트입니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-178">In these cases, the Result starts out non-null, and only if a custom exception handler explicitly sets it back to `null` (unhandled) will the exception propagate to the host.</span></span> <span data-ttu-id="346e8-179">설정 `Result` 를 `null` 이러한 경우에 유용할 수 두 가지 시나리오:</span><span class="sxs-lookup"><span data-stu-id="346e8-179">Setting `Result` to `null` in such cases can be useful for two scenarios:</span></span>

1. <span data-ttu-id="346e8-180">사용자 지정 예외 처리 하기 전에/외부 웹 API를 등록 하는 미들웨어로 Web API를 호스트 하는 OWIN 합니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-180">OWIN hosted Web API with custom exception handling middleware registered before/outside Web API.</span></span>
2. <span data-ttu-id="346e8-181">로컬 브라우저를 통해 디버깅, 여기서 사망의 노란색 화면은 처리 되지 않은 예외에 대 한 유용한 응답 실제로입니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-181">Local debugging via a browser, where the yellow screen of death is actually a helpful response for an unhandled exception.</span></span>

<span data-ttu-id="346e8-182">예외로 거와 예외 처리기에 대 한로 거 또는 자체 처리기 예외를 throw 한 경우 복구할 수 아무 작업도 수행 하지 마십시오 했습니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-182">For both exception loggers and exception handlers, we don't do anything to recover if the logger or handler itself throws an exception.</span></span> <span data-ttu-id="346e8-183">(전파 하는 경우이 페이지의 맨 아래에 피드백을 두고, 예외로 이외의 있어야 더 나은 방법은.) 예외로 거 및 처리기에 대 한 계약 예외 호출자;까지 전파 하지 통과 시킬 것은 그렇지 않으면 예외 방금에 전파 됩니다, 종종 모든 과정 (예: ASP HTML 오류가 발생 하는 호스트. NET의 노란색 화면)는 클라이언트 (JSON 또는 XML을 예상 하는 API 호출자는 기본적된으로 옵션을 대개 되지 않음)으로 다시 전송 됩니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-183">(Other than letting the exception propagate, leave feedback at the bottom of this page if you have a better approach.) The contract for exception loggers and handlers is that they should not let exceptions propagate up to their callers; otherwise, the exception will just propagate, often all the way to the host resulting in an HTML error (like the ASP.NET's yellow screen) being sent back to the client (which usually isn't the preferred option for API callers that expect JSON or XML).</span></span>

## <a name="examples"></a><span data-ttu-id="346e8-184">예제</span><span class="sxs-lookup"><span data-stu-id="346e8-184">Examples</span></span>

### <a name="tracing-exception-logger"></a><span data-ttu-id="346e8-185">예외로 거를 추적합니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-185">Tracing Exception Logger</span></span>

<span data-ttu-id="346e8-186">아래 예외로 거 (Visual Studio에서 디버그 출력 창 포함)으로 구성 된 추적 소스를 예외 데이터를 보냅니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-186">The exception logger below send exception data to configured Trace sources (including the Debug output window in Visual Studio).</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample6.cs)]

### <a name="custom-error-message-exception-handler"></a><span data-ttu-id="346e8-187">사용자 지정 오류 메시지 예외 처리기</span><span class="sxs-lookup"><span data-stu-id="346e8-187">Custom Error Message Exception Handler</span></span>

<span data-ttu-id="346e8-188">아래에서 다음을 지원 팀에 연락 하는 것에 대 한 전자 메일 주소를 포함 한 클라이언트에 대 한 사용자 지정 오류 응답을 생성 합니다.</span><span class="sxs-lookup"><span data-stu-id="346e8-188">The following below produces a custom error response to clients, including an email address for contacting support.</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample7.cs)]

## <a name="registering-exception-filters"></a><span data-ttu-id="346e8-189">예외 필터를 등록 하는 중</span><span class="sxs-lookup"><span data-stu-id="346e8-189">Registering Exception Filters</span></span>

<span data-ttu-id="346e8-190">"ASP.NET MVC 4 웹 응용 프로그램" 프로젝트 템플릿을 사용 하 여 프로젝트를 만드는 경우 내부 웹 API 구성 코드를 입력의 `WebApiConfig` 클래스에 *앱/시작 (_s)* 폴더:</span><span class="sxs-lookup"><span data-stu-id="346e8-190">If you use the "ASP.NET MVC 4 Web Application" project template to create your project, put your Web API configuration code inside the `WebApiConfig` class, in the *App/_Start* folder:</span></span>

[!code-csharp[Main](exception-handling/samples/sample7.cs?highlight=5)]

## <a name="appendix-base-class-details"></a><span data-ttu-id="346e8-191">부록: 기본 클래스 세부 내용</span><span class="sxs-lookup"><span data-stu-id="346e8-191">Appendix: Base Class Details</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample8.cs)]
