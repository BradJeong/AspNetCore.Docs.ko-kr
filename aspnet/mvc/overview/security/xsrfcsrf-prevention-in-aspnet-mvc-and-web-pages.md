---
uid: mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
title: 웹 페이지 및 ASP.NET MVC에서 XSRF/CSRF 방지 | Microsoft Docs
author: Rick-Anderson
description: 교차 사이트 요청 위조 (XSRF 또는 CSRF 라고도 함)가 악의적인 웹 사이트는 interacti 영향을 줄 수는 그에 따라 웹 호스팅 응용 프로그램에 대 한 공격 중...
ms.author: aspnetcontent
manager: wpickett
ms.date: 03/14/2013
ms.topic: article
ms.assetid: aadc5fa4-8215-4fc7-afd5-bcd2ef879728
ms.technology: dotnet-mvc
ms.prod: .net-framework
msc.legacyurl: /mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
msc.type: authoredcontent
ms.openlocfilehash: 6cf30daa7ed966b11405cec715c5bc803b567249
ms.sourcegitcommit: f8852267f463b62d7f975e56bea9aa3f68fbbdeb
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/10/2018
ms.locfileid: "28033998"
---
<a name="xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages"></a><span data-ttu-id="502b8-103">웹 페이지 및 ASP.NET MVC에서 XSRF/CSRF 방지</span><span class="sxs-lookup"><span data-stu-id="502b8-103">XSRF/CSRF Prevention in ASP.NET MVC and Web Pages</span></span>
====================
<span data-ttu-id="502b8-104">으로 [Rick Anderson](https://github.com/Rick-Anderson)</span><span class="sxs-lookup"><span data-stu-id="502b8-104">by [Rick Anderson](https://github.com/Rick-Anderson)</span></span>

> <span data-ttu-id="502b8-105">교차 사이트 요청 위조 (XSRF 또는 CSRF 라고도 함)가 악의적인 웹 사이트 클라이언트 브라우저와 해당 브라우저에서 신뢰할 수 있는 웹 사이트 간의 상호 작용 영향을 줄 수는 그에 따라 웹 호스팅 응용 프로그램에 대 한 공격입니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-105">Cross-site request forgery (also known as XSRF or CSRF) is an attack against web-hosted applications whereby a malicious web site can influence the interaction between a client browser and a web site trusted by that browser.</span></span> <span data-ttu-id="502b8-106">이러한 공격은 웹 브라우저가 웹 사이트에 대 한 모든 요청에 자동으로 인증 토큰을 전송할 때문에 가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-106">These attacks are made possible because web browsers will send authentication tokens automatically with every request to a web site.</span></span> <span data-ttu-id="502b8-107">정식는 예: ASP 인증 쿠키를 수 있습니다. NET의 폼 인증 티켓입니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-107">The canonical example is an authentication cookie, such as ASP.NET's Forms Authentication ticket.</span></span> <span data-ttu-id="502b8-108">그러나 이러한 공격에 의해 모든 영구 인증 메커니즘 (예: Windows 인증, 기본 및 등)을 사용 하는 웹 사이트를 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-108">However, web sites which use any persistent authentication mechanism (such as Windows Authentication, Basic, and so forth) can be targeted by these attacks.</span></span>
> 
> <span data-ttu-id="502b8-109">XSRF 공격은 피싱 공격과에서 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-109">An XSRF attack is distinct from a phishing attack.</span></span> <span data-ttu-id="502b8-110">피싱 공격 희생자에서 상호 작용을 필요로 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-110">Phishing attacks require interaction from the victim.</span></span> <span data-ttu-id="502b8-111">피싱 공격에서는 악의적인 웹 사이트는 대상 웹 사이트를 모방 됩니다 및 상태가 발생 하 여 공격자에 게 중요 한 정보를 제공 하도록 속일 됩니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-111">In a phishing attack, a malicious web site will mimic the target web site, and the victim is fooled into providing sensitive information to the attacker.</span></span> <span data-ttu-id="502b8-112">XSRF 공격에서 종종 희생자에서 필요한 조작은 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-112">In an XSRF attack, there is often no interaction necessary from the victim.</span></span> <span data-ttu-id="502b8-113">대신, 공격자가 자동으로 대상 웹 사이트에 모든 관련 쿠키를 전송 하는 브라우저에 신뢰 됩니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-113">Rather, the attacker is relying on the browser automatically sending all relevant cookies to the destination web site.</span></span>
> 
> <span data-ttu-id="502b8-114">자세한 내용은 참조는 [웹 응용 프로그램 보안 프로젝트 열기](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF))합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-114">For more information, see the [Open Web Application Security Project](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).</span></span>


## <a name="anatomy-of-an-attack"></a><span data-ttu-id="502b8-115">공격 분석</span><span class="sxs-lookup"><span data-stu-id="502b8-115">Anatomy of an attack</span></span>

<span data-ttu-id="502b8-116">XSRF 공격을 진행 하기 위해 사용자를 일부 온라인 뱅킹 트랜잭션을 수행 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-116">To walk through an XSRF attack, consider a user who wants to perform some online banking transactions.</span></span> <span data-ttu-id="502b8-117">이 사용자는 먼저 WoodgroveBank.com 고에 있는 로그 지점을 응답 헤더 포함 됩니다. 자신의 인증 쿠키 방문:</span><span class="sxs-lookup"><span data-stu-id="502b8-117">This user first visits WoodgroveBank.com and logs in, at which point the response header will contain her authentication cookie:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample1.cmd)]

<span data-ttu-id="502b8-118">인증 쿠키는 세션 쿠키, 때문에 자동으로 지워집니다 브라우저에서 브라우저 프로세스가 종료 될 때입니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-118">Because the authentication cookie is a session cookie, it will be automatically cleared by the browser when the browser process exits.</span></span> <span data-ttu-id="502b8-119">그러나 그 전 까지는 브라우저에서는 자동으로 포함 WoodgroveBank.com 각 요청과 함께 쿠키입니다. 사용자가 이제 하므로 그녀 은행 사이트의 양식을 작성 하 고 브라우저는 서버에이 요청을 다른 계정으로 1000 달러를 전송 하려는:</span><span class="sxs-lookup"><span data-stu-id="502b8-119">However, until that time, the browser will automatically include the cookie with each request to WoodgroveBank.com. The user now wants to transfer $1000 to another account, so she fills out a form on the banking site, and the browser makes this request to the server:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample2.cmd)]

<span data-ttu-id="502b8-120">이 작업 (통화 트랜잭션 시작 함) 부작용을 사용 하므로 은행 사이트는이 작업을 시작 하기 위해 HTTP POST를 요구 하도록 선택 했습니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-120">Because this operation has a side effect (it initiates a monetary transaction), the banking site has chosen to require an HTTP POST in order to initiate this operation.</span></span> <span data-ttu-id="502b8-121">서버 요청에서 인증 토큰을 읽고, 현재 사용자의 계정 번호를 찾고, 확인 자금 부족 존재 한 다음 대상 계정으로 트랜잭션을 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-121">The server reads the authentication token from the request, looks up the current user's account number, verifies that sufficient funds exist, and then initiates the transaction into the destination account.</span></span>

<span data-ttu-id="502b8-122">완료를 온라인 뱅킹 her, 사용자 은행 사이트 밖으로 이동 하 고는 웹에서 다른 위치를 열어 봅니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-122">Her online banking complete, the user navigates away from the banking site and visits other locations on the web.</span></span> <span data-ttu-id="502b8-123">내에 포함 된 페이지에 다음 태그를 포함 하는 해당 사이트 – fabrikam.com – 중 하나는 &lt;iframe&gt;:</span><span class="sxs-lookup"><span data-stu-id="502b8-123">One of those sites – fabrikam.com – includes the following markup on a page embedded within an &lt;iframe&gt;:</span></span>

[!code-html[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample3.html)]

<span data-ttu-id="502b8-124">다음이이 요청에 대 한 브라우저를 사용 하면:</span><span class="sxs-lookup"><span data-stu-id="502b8-124">Which then causes the browser to make this request:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample4.cmd)]

<span data-ttu-id="502b8-125">공격자가 사용자 대상 웹 사이트에 대 한 유효한 인증 토큰이 있을 수 있습니다 하 고 Javascript의 작은 조각을 사용 하 여 대상 사이트에 HTTP POST를 자동으로 확인 하려면 브라우저는 그녀 악용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-125">The attacker is exploiting the fact that the user might still have a valid authentication token for the target web site, and she is using a small snippet of Javascript to cause the browser to make an HTTP POST to the target site automatically.</span></span> <span data-ttu-id="502b8-126">인증 토큰이 여전히 유효한 경우 은행 사이트 공격자가 선택한의 계정으로 $250의 전송을 시작 됩니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-126">If the authentication token is still valid, the banking site will initiate a transfer of $250 into the account of the attacker's choosing.</span></span>

### <a name="ineffective-mitigations"></a><span data-ttu-id="502b8-127">비효율적인 완화</span><span class="sxs-lookup"><span data-stu-id="502b8-127">Ineffective mitigations</span></span>

<span data-ttu-id="502b8-128">위의 시나리오에 WoodgroveBank.com SSL을 통해 액세스 하 고 있던 한 SSL 인증 쿠키에 있다는 점에서 되었음을 방지할 수 있었던 공격을 차단 하는 데 충분을 보면 흥미롭습니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-128">It is interesting to note that in the above scenario, the fact that WoodgroveBank.com was being accessed via SSL and had an SSL-only authentication cookie was insufficient to thwart the attack.</span></span> <span data-ttu-id="502b8-129">공격자는 지정할 수는 [URI 체계](http://en.wikipedia.org/wiki/URI_scheme) (https)에 &lt;양식&gt; 요소 및 브라우저 쿠키 만료 되지 않은 사이트에 보내는 대상으로 이러한 쿠키는 URI와 일치를 계속 의도 한 대상의 구성표입니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-129">The attacker is able to specify the [URI scheme](http://en.wikipedia.org/wiki/URI_scheme) (https) in her &lt;form&gt; element, and the browser will continue to send unexpired cookies to the target site as long as those cookies are consistent with the URI scheme of the intended target.</span></span>

<span data-ttu-id="502b8-130">하나는 사용자 단순히 하지 방문 하 여 신뢰할 수 없는 사이트를 방문 하는 온라인 안전 하 게 유지를 활용 하 여 신뢰할 수 있는 사이트에만 주장 수 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-130">One could argue that the user should simply not visit untrusted sites, as visiting only trusted sites is helps to remain safe online.</span></span> <span data-ttu-id="502b8-131">이 어느 정도 가능성이 있지만 불행히도이 충고 불가능 한 항상 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-131">There is some truth to this, but unfortunately this advice is not always practical.</span></span> <span data-ttu-id="502b8-132">아마도 사용자 "신뢰" 지역 뉴스 사이트 ConsolidatedMessenger 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-132">Perhaps the user "trusts" the local news site ConsolidatedMessenger.</span></span> <span data-ttu-id="502b8-133">ConsolidatedMessenger.com 및이 되는 대신, 사이트 방문 되었지만 해당 사이트를 통해 공격자가 동일한 fabrikam.com에서 실행 되 던 코드 조각을 삽입할 수 있는 XSS 취약성을 있습니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-133">ConsolidatedMessenger.com and goes to visit that site instead, but that site has an XSS vulnerability which allows an attacker to inject the same snippet of code that was running on fabrikam.com.</span></span>

<span data-ttu-id="502b8-134">들어오는 요청 권한이 있는지 확인할 수 있습니다는 [Referer 헤더로](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) 도메인을 참조 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-134">You can verify that incoming requests have a [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) referencing your domain.</span></span> <span data-ttu-id="502b8-135">이렇게 하면 실수로 제 3 자 도메인에서 제출 된 요청 중지 됩니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-135">This will stop requests unwittingly submitted from a third-party domain.</span></span> <span data-ttu-id="502b8-136">그러나 일부 사용자 개인 정보 보호를 위해 브라우저의 참조 페이지 헤더가 사용 하지 않도록 설정 하 고 공격자가 희생자에 특정 보안 되지 않은 소프트웨어가 설치 되어 있는 경우 해당 헤더를 스푸핑할 경우가 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-136">However, some people disable their browser's Referer header for privacy reasons, and attackers can sometimes spoof that header if the victim has certain insecure software installed.</span></span> <span data-ttu-id="502b8-137">확인 하 고 [Referer 헤더로](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) XSRF 공격을 방지 하는 안전한 방법으로 간주 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-137">Verifying the [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) is not considered a secure approach to preventing XSRF attacks.</span></span>

## <a name="web-stack-runtime-xsrf-mitigations"></a><span data-ttu-id="502b8-138">웹 스택 런타임 XSRF 완화</span><span class="sxs-lookup"><span data-stu-id="502b8-138">Web Stack Runtime XSRF mitigations</span></span>

<span data-ttu-id="502b8-139">ASP.NET 웹 스택 런타임에서의 변형을 사용 하 여 [동기화 장치 토큰 패턴이](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern) XSRF 공격 으로부터 보호 하기 위해 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-139">The ASP.NET Web Stack Runtime uses a variant of the [synchronizer token pattern](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern) to defend against XSRF attacks.</span></span> <span data-ttu-id="502b8-140">일반적인 형태의 동기화 장치 토큰 패턴은 두 개의 ANTI-XSRF 토큰 (인증 토큰) 외에도 각 HTTP POST를 사용 하 여 서버에 제출 되: 쿠키를 지정 하 고 양식 값으로 다른 토큰을 두 개 있습니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-140">The general form of the synchronizer token pattern is that two anti-XSRF tokens are submitted to the server with each HTTP POST (In addition to the authentication token): one token as a cookie, and the other as a form value.</span></span> <span data-ttu-id="502b8-141">ASP.NET 런타임에 의해 생성 된 토큰 값이 결정적 또는 공격자가 예측 가능한있지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-141">The token values generated by the ASP.NET runtime are not deterministic or predictable by an attacker.</span></span> <span data-ttu-id="502b8-142">토큰을 전송할 때 서버에서 두 토큰 비교 검사를 통과 하는 경우에 계속 진행 하는 요청을 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-142">When the tokens are submitted, the server will allow the request to proceed only if both tokens pass a comparison check.</span></span>

<span data-ttu-id="502b8-143">XSRF 요청 확인 *세션 토큰* HTTP 쿠키로 저장 되 고 현재 페이로드에서 다음 정보를 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-143">The XSRF request verification *session token* is stored as an HTTP cookie and currently contains the following information in its payload:</span></span>

- <span data-ttu-id="502b8-144">임의 128 비트 식별자로 구성 된 보안 토큰입니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-144">A security token, consisting of a random 128-bit identifier.</span></span>   
 <span data-ttu-id="502b8-145">다음 이미지는 Internet Explorer F12 개발자 도구와 함께 표시 XSRF 요청 확인 세션 토큰을 표시: (이 현재 구현 되며 제목, 변경 될 가능성이 합니다.)</span><span class="sxs-lookup"><span data-stu-id="502b8-145">The following image shows the XSRF request verification session token displayed with the Internet Explorer F12 developer tools: (Note this is the current implementation and is subject, even likely, to change.)</span></span>

![](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/_static/image1.png)

<span data-ttu-id="502b8-146">*필드 토큰이* 으로 저장 되는 `<input type="hidden" />` 페이로드에서 다음 정보를 포함 하 고:</span><span class="sxs-lookup"><span data-stu-id="502b8-146">The *field token* is stored as an `<input type="hidden" />` and contains the following information in its payload:</span></span>

- <span data-ttu-id="502b8-147">로그인 한 사용자의 사용자 이름 (인증) 하는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-147">The logged-in user's username (if authenticated).</span></span>
- <span data-ttu-id="502b8-148">제공 하는 모든 추가 데이터는 [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-148">Any additional data provided by an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx).</span></span>

<span data-ttu-id="502b8-149">ANTI-XSRF 토큰의 페이로드가 암호화 되 고 서명, 토큰을 검사 하려면 도구를 사용 하는 경우 사용자 이름을 볼 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-149">The payloads of the anti-XSRF tokens are encrypted and signed, so you can't view the username when using tools to examine the tokens.</span></span> <span data-ttu-id="502b8-150">웹 응용 프로그램은 ASP.NET 4.0을 대상으로 지정 하는 경우 암호화 서비스에 의해 제공 되는 [MachineKey.Encode](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx) 루틴입니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-150">When the web application is targeting ASP.NET 4.0, cryptographic services are provided by the [MachineKey.Encode](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx) routine.</span></span> <span data-ttu-id="502b8-151">웹 응용 프로그램은 ASP.NET 4.5를 대상으로 하거나 더 높은, 암호화 서비스에서 제공 때는 [MachineKey.Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110)) 더 나은 성능, 확장성 및 보안을 제공 하는 루틴입니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-151">When the web application is targeting ASP.NET 4.5 or higher, cryptographic services are provided by the [MachineKey.Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110)) routine, which offers better performance, extensibility, and security.</span></span> <span data-ttu-id="502b8-152">자세한 내용은 다음 블로그 게시물을 참조 하십시오.</span><span class="sxs-lookup"><span data-stu-id="502b8-152">See the following blog posts for more details:</span></span>

- [<span data-ttu-id="502b8-153">ASP.NET 4.5 암호화 향상 된 기능, pt입니다. 1</span><span class="sxs-lookup"><span data-stu-id="502b8-153">Cryptographic Improvements in ASP.NET 4.5, pt. 1</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/22/cryptographic-improvements-in-asp-net-4-5-pt-1.aspx)
- [<span data-ttu-id="502b8-154">ASP.NET 4.5 암호화 향상 된 기능, pt입니다. 2</span><span class="sxs-lookup"><span data-stu-id="502b8-154">Cryptographic Improvements in ASP.NET 4.5, pt. 2</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/23/cryptographic-improvements-in-asp-net-4-5-pt-2.aspx)
- [<span data-ttu-id="502b8-155">ASP.NET 4.5 암호화 향상 된 기능, pt입니다. 3</span><span class="sxs-lookup"><span data-stu-id="502b8-155">Cryptographic Improvements in ASP.NET 4.5, pt. 3</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/24/cryptographic-improvements-in-asp-net-4-5-pt-3.aspx)

## <a name="generating-the-tokens"></a><span data-ttu-id="502b8-156">토큰 생성</span><span class="sxs-lookup"><span data-stu-id="502b8-156">Generating the tokens</span></span>

<span data-ttu-id="502b8-157">ANTI-XSRF 토큰을 생성 하려면 호출는 [ @Html.AntiForgeryToken ](https://msdn.microsoft.com/library/dd470175.aspx) MVC 뷰에서 메서드 또는 @AntiForgery.GetHtmlRazor 페이지에서 ().</span><span class="sxs-lookup"><span data-stu-id="502b8-157">To generate the anti-XSRF tokens, call the [@Html.AntiForgeryToken](https://msdn.microsoft.com/library/dd470175.aspx) method from an MVC view or @AntiForgery.GetHtml() from a Razor page.</span></span> <span data-ttu-id="502b8-158">런타임은 다음 단계를 수행 다음 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-158">The runtime will then perform the following steps:</span></span>

1. <span data-ttu-id="502b8-159">현재 HTTP 요청 ANTI-XSRF 세션 토큰에 이미 포함 되어 있는 경우 (ANTI-XSRF 쿠키 \_ \_RequestVerificationToken), 보안 토큰에서 추출 됩니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-159">If the current HTTP request already contains an anti-XSRF session token (the anti-XSRF cookie \_\_RequestVerificationToken), the security token is extracted from it.</span></span> <span data-ttu-id="502b8-160">HTTP 요청에는 ANTI-XSRF 세션 토큰 또는 보안 토큰의 추출이 실패할 경우 새 임의 ANTI-XSRF 토큰 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-160">If the HTTP request does not contain an anti-XSRF session token or if extraction of the security token fails, a new random anti-XSRF token will be generated.</span></span>
2. <span data-ttu-id="502b8-161">ANTI-XSRF 필드 토큰이 현재 로그인 한 사용자의 id (1) 위의 단계에서 보안 토큰을 사용 하 여 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-161">An anti-XSRF field token is generated using the security token from step (1) above and the identity of the current logged-in user.</span></span> <span data-ttu-id="502b8-162">(사용자 id 확인에 대 한 자세한 내용은 참조는 **[특별 한 지원 사용 하는 시나리오](#_Scenarios_with_special)** 아래 섹션.) 또한 경우는 [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx) 은 구성 런타임에서 호출 됩니다는 [GetAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) 메서드 field 토큰에는 반환 된 문자열을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-162">(For more information on determining user identity, see the **[Scenarios with special support](#_Scenarios_with_special)** section below.) Additionally, if an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx) is configured, the runtime will call its [GetAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) method and include the returned string in the field token.</span></span> <span data-ttu-id="502b8-163">(참조는 **[구성 및 확장성](#_Configuration_and_extensibility)** 한 자세 합니다.)</span><span class="sxs-lookup"><span data-stu-id="502b8-163">(See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.)</span></span>
3. <span data-ttu-id="502b8-164">새 ANTI-XSRF 토큰 단계 (1)에서 생성 된, 새 세션 토큰 및 포함 하기 위해 만들어집니다 아웃 바운드 HTTP 쿠키 컬렉션에 추가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-164">If a new anti-XSRF token was generated in step (1), a new session token will be created to contain it and will be added to the outbound HTTP cookies collection.</span></span> <span data-ttu-id="502b8-165">단계 (2)에서 필드 토큰이에 래핑됩니다는 `<input type="hidden" />` 요소, 그리고이 HTML 태그의 반환 값이 됩니다 `Html.AntiForgeryToken()` 또는 `AntiForgery.GetHtml()`합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-165">The field token from step (2) will be wrapped in an `<input type="hidden" />` element, and this HTML markup will be the return value of `Html.AntiForgeryToken()` or `AntiForgery.GetHtml()`.</span></span>

## <a name="validating-the-tokens"></a><span data-ttu-id="502b8-166">토큰 유효성 검사</span><span class="sxs-lookup"><span data-stu-id="502b8-166">Validating the tokens</span></span>

<span data-ttu-id="502b8-167">들어오는 ANTI-XSRF 토큰의 유효성을 검사 하는 개발자가 포함 된 [ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) 그녀의 MVC 동작 또는 컨트롤러 또는 그녀는 호출에 특성 `@AntiForgery.Validate()` 그녀의 Razor 페이지에서.</span><span class="sxs-lookup"><span data-stu-id="502b8-167">To validate the incoming anti-XSRF tokens, the developer includes a [ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) attribute on her MVC action or controller, or she calls `@AntiForgery.Validate()` from her Razor page.</span></span> <span data-ttu-id="502b8-168">런타임에서 다음 단계를 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-168">The runtime will perform the following steps:</span></span>

1. <span data-ttu-id="502b8-169">들어오는 세션 토큰 및 필드 토큰이 읽고 ANTI-XSRF 토큰 각에서 추출 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-169">The incoming session token and field token are read and the anti-XSRF token extracted from each.</span></span> <span data-ttu-id="502b8-170">ANTI-XSRF 토큰 생성 루틴에서 단계 (2) 당 동일 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-170">The anti-XSRF tokens must be identical per step (2) in the generation routine.</span></span>
2. <span data-ttu-id="502b8-171">현재 사용자가 인증 되 면 그녀의 사용자 이름 필드 토큰에 저장 된 사용자 이름으로 비교 됩니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-171">If the current user is authenticated, her username is compared with the username stored in the field token.</span></span> <span data-ttu-id="502b8-172">사용자 이름의 일치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-172">The usernames must match.</span></span>
3. <span data-ttu-id="502b8-173">경우는 [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) 구성 된 런타임 호출 해당 *ValidateAdditionalData* 메서드.</span><span class="sxs-lookup"><span data-stu-id="502b8-173">If an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) is configured, the runtime calls its *ValidateAdditionalData* method.</span></span> <span data-ttu-id="502b8-174">이 메서드는 부울 값을 반환 해야 *true*합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-174">The method must return the Boolean value *true*.</span></span>

<span data-ttu-id="502b8-175">유효성 검사는 성공 요청은 계속 진행 하도록 허용 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-175">If validation succeeds, the request is allowed to proceed.</span></span> <span data-ttu-id="502b8-176">유효성 검사가 실패할 경우 프레임 워크에서 throw 한 *HttpAntiForgeryException*합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-176">If validation fails, the framework will throw an *HttpAntiForgeryException*.</span></span>

## <a name="failure-conditions"></a><span data-ttu-id="502b8-177">오류 상태</span><span class="sxs-lookup"><span data-stu-id="502b8-177">Failure conditions</span></span>

<span data-ttu-id="502b8-178">ASP.NET 웹 스택 런타임 v 2와 함께 시작 하는 모든 *HttpAntiForgeryException* 중에 throw 되는 유효성 검사에는 무엇이 잘못 되었는지에 대 한 자세한 정보가 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-178">Starting with The ASP.NET Web Stack Runtime v2, any *HttpAntiForgeryException* that is thrown during validation will contain detailed information about what went wrong.</span></span> <span data-ttu-id="502b8-179">현재 정의 된 오류 조건에 해당 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-179">The currently defined failure conditions are:</span></span>

- <span data-ttu-id="502b8-180">세션 토큰 또는 폼 토큰 요청에 나타나지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-180">The session token or form token is not present in the request.</span></span>
- <span data-ttu-id="502b8-181">세션 토큰 또는 폼 토큰을 읽을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-181">The session token or form token is unreadable.</span></span> <span data-ttu-id="502b8-182">이 가장 일반적인 원인은 다른 버전의 ASP.NET 웹 스택 런타임 또는 팜의를 실행 하는 팜에서 여기서는 &lt;machineKey&gt; Web.config의 요소는 컴퓨터 간에 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-182">The most likely cause of this is a farm running mismatched versions of The ASP.NET Web Stack Runtime or a farm where the &lt;machineKey&gt; element in Web.config differs between machines.</span></span> <span data-ttu-id="502b8-183">둘 중 한 ANTI-XSRF 토큰을 변조 하 여이 예외를 강제로 Fiddler와 같은 도구를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-183">You can use a tool such as Fiddler to force this exception by tampering with either anti-XSRF token.</span></span>
- <span data-ttu-id="502b8-184">세션 토큰 및 필드 토큰 교체 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-184">The session token and field token were swapped.</span></span>
- <span data-ttu-id="502b8-185">세션 토큰 및 필드 토큰이 일치 하지 않는 보안 토큰을 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-185">The session token and field token contain mismatched security tokens.</span></span>
- <span data-ttu-id="502b8-186">Field 토큰 내에 포함 된 사용자 이름에는 현재 로그인 한 사용자의 사용자 이름을 일치 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-186">The username embedded within the field token does not match the current logged-in user's username.</span></span>
- <span data-ttu-id="502b8-187">*[IAntiForgeryAdditionalDataProvider.ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* 메서드 반환 *false*합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-187">The *[IAntiForgeryAdditionalDataProvider.ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* method returned *false*.</span></span>

<span data-ttu-id="502b8-188">ANTI-XSRF 시설 토큰 생성 또는 유효성 검사를 하는 동안 추가 검사 수행 될 수 있습니다 하며 이러한 검사 중에 오류가 발생 하는 예외가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-188">The anti-XSRF facilities may also perform additional checking during token generation or validation, and failures during these checks may result in exceptions being thrown.</span></span> <span data-ttu-id="502b8-189">참조는 [WIF / ACS / 클레임 기반 인증](#_WIF_ACS) 및 **[구성 및 확장성](#_Configuration_and_extensibility)** 섹션에서 자세한 정보.</span><span class="sxs-lookup"><span data-stu-id="502b8-189">See the [WIF / ACS / claims-based authentication](#_WIF_ACS) and **[Configuration and extensibility](#_Configuration_and_extensibility)** sections for more information.</span></span>

<a id="_Scenarios_with_special"></a>

## <a name="scenarios-with-special-support"></a><span data-ttu-id="502b8-190">특별 한 지원 사용 하는 시나리오</span><span class="sxs-lookup"><span data-stu-id="502b8-190">Scenarios with special support</span></span>

### <a name="anonymous-authentication"></a><span data-ttu-id="502b8-191">익명 인증</span><span class="sxs-lookup"><span data-stu-id="502b8-191">Anonymous authentication</span></span>

<span data-ttu-id="502b8-192">ANTI-XSRF 시스템에 "익명"가 정의 되어 있는 사용자로 익명 사용자에 대 한 특별 한 지원이 포함 되어 있는 *IIdentity.IsAuthenticated* 속성에서 반환 *false*합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-192">The anti-XSRF system contains special support for anonymous users, where "anonymous" is defined as a user where the *IIdentity.IsAuthenticated* property returns *false*.</span></span> <span data-ttu-id="502b8-193">XSRF 보호 (사용자가 인증) 전에 로그인 페이지 및 응용 프로그램 사용 하는 경우는 메커니즘이 아닌 다른 사용자 지정 인증 체계를 제공 하는 것이 시나리오로 *IIdentity* 사용자를 식별 하 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-193">Scenarios include providing XSRF protection to the login page (before the user is authenticated) and custom authentication schemes where the application uses a mechanism other than *IIdentity* to identify users.</span></span>

<span data-ttu-id="502b8-194">이러한 시나리오를 지원 하려면 세션 및 필드 토큰 보안 토큰에는 128 비트 임의로 생성 된 불투명 식별자로 결합 된 점에 유의 하십시오.</span><span class="sxs-lookup"><span data-stu-id="502b8-194">To support these scenarios, recall that the session and field tokens are joined by a security token, which is a 128-bit randomly-generated opaque identifier.</span></span> <span data-ttu-id="502b8-195">이 보안 토큰이 이므로 익명 식별자의 용도 효과적으로 역할은 사이트를 탐색 하면서 그녀는 개별 사용자의 세션을 추적 하기 위해 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-195">This security token is used to track an individual user's session as she navigates the site, so it effectively serves the purpose of an anonymous identifier.</span></span> <span data-ttu-id="502b8-196">빈 문자열은 위에서 설명한 생성 및 유효성 검사 루틴에 대 한 사용자 이름 대신 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-196">An empty string is used in place of the username for the generation and validation routines described above.</span></span>

<a id="_WIF_ACS"></a>

### <a name="wif--acs--claims-based-authentication"></a><span data-ttu-id="502b8-197">WIF / ACS / 클레임 기반 인증</span><span class="sxs-lookup"><span data-stu-id="502b8-197">WIF / ACS / claims-based authentication</span></span>

<span data-ttu-id="502b8-198">일반적으로 *IIdentity* .NET Framework에 기본 제공 하는 클래스 속성에는 있는 *IIdentity.Name* 특정 응용 프로그램 내에서 특정 사용자를 고유 하 게 식별 하는 충분 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-198">Normally, the *IIdentity* classes built in to the .NET Framework have the property that *IIdentity.Name* is sufficient to uniquely identify a particular user within a particular application.</span></span> <span data-ttu-id="502b8-199">예를 들어 *FormsIdentity.Name* (이 해당 데이터베이스에 따라 모든 응용 프로그램에 대해 고유) 구성원 데이터베이스에 저장 된 사용자 이름을 반환 *WindowsIdentity.Name* 반환는 사용자 및 등의 정규화 된 도메인 id입니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-199">For example, *FormsIdentity.Name* returns the username stored in the membership database (which is unique for all applications depending on that database), *WindowsIdentity.Name* returns the domain-qualified identity of the user, and so on.</span></span> <span data-ttu-id="502b8-200">이러한 시스템 제공 뿐만 아니라 인증; 또한 *식별* 응용 프로그램에 사용자입니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-200">These systems provide not only authentication; they also *identify* users to an application.</span></span>

<span data-ttu-id="502b8-201">클레임 기반 인증 반면에 필요는 없습니다 특정 사용자를 식별 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-201">Claims-based authentication, on the other hand, does not necessarily require identifying a particular user.</span></span> <span data-ttu-id="502b8-202">대신,는 *ClaimsPrincipal* 및 *ClaimsIdentity* 유형은의 집합과 연결 *클레임* 인스턴스를 개별 클레임 수 있는 "18 + 세 is" 또는 " 관리자가 다른 사용자 계정으로 "입니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-202">Instead, the *ClaimsPrincipal* and *ClaimsIdentity* types are associated with a set of *Claim* instances, where the individual claims might be "is 18+ years of age" or "is an administrator" to anything else.</span></span> <span data-ttu-id="502b8-203">사용자를 확인 했으면 반드시 않은 이후 런타임에서 사용할 수 없습니다는 *ClaimsIdentity.Name* 이 특정 사용자에 대 한 고유 식별자로 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-203">Since the user hasn't necessarily been identified, the runtime cannot use the *ClaimsIdentity.Name* property as a unique identifier for this particular user.</span></span> <span data-ttu-id="502b8-204">팀에서 실제 예에 표시 여기서 *ClaimsIdentity.Name* 반환 *null*, 대화명 (표시) 이름을 반환 또는 그렇지 않은 경우 고유 식별자로 사용 하기에 적합 하지 않은 문자열을 반환 합니다. 에 대 한 사용자입니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-204">The team has seen real-world examples where *ClaimsIdentity.Name* returns *null*, returns a friendly (display) name, or otherwise returns a string that isn't appropriate for use as a unique identifier for the user.</span></span>

<span data-ttu-id="502b8-205">사용 하는 다양 한 클레임 기반 인증을 사용 하 여 배포 [Azure 액세스 제어 서비스](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) (ACS) 특히 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-205">Many of deployments which use claims-based authentication are using [Azure Access Control Service](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) (ACS) in particular.</span></span> <span data-ttu-id="502b8-206">ACS 개별 개발자가 구성할 수 있습니다 *id 공급자* (ADFS를 Microsoft 계정 공급자와 같은 OpenID 공급자 등의 yahoo! 등)를 반환 하는 id 공급자 및 *식별자이름지정*.</span><span class="sxs-lookup"><span data-stu-id="502b8-206">ACS allows the developer to configure individual *identity providers* (such as ADFS, the Microsoft Account provider, OpenID providers like Yahoo!, etc.), and the identity providers return *name identifiers*.</span></span> <span data-ttu-id="502b8-207">이러한 이름 식별자 개인 식별이 가능한 정보 (PII) 전자 메일 주소 처럼 포함 되거나 같은 식별자 PPID (Private Personal)를 실적과 될 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-207">These name identifiers may contain Personally Identifiable Information (PII) like an email address, or they could be anonymized like a Private Personal Identifier (PPID).</span></span> <span data-ttu-id="502b8-208">그럼에도 불구 하 고 (id 공급자, 이름 식별자) 튜플 충분히 역할을 특정 사용자에 대 한 적절 한 추적 토큰 그녀 ASP.NET 웹 스택 런타임이 생성 하는 경우 사용자 이름 대신 튜플을 사용할 수 있도록 사이트를 검색 하는 동안 및 ANTI-XSRF 필드 토큰 유효성을 검사 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-208">Regardless, the tuple (identity provider, name identifier) sufficiently serves as an appropriate tracking token for a particular user while she is browsing the site, so the ASP.NET Web Stack Runtime can use the tuple in place of the username when generating and validating anti-XSRF field tokens.</span></span> <span data-ttu-id="502b8-209">Id 공급자와의 이름 식별자에 대 한 특정 Uri는:</span><span class="sxs-lookup"><span data-stu-id="502b8-209">The particular URIs for the identity provider and the name identifier are :</span></span>

- `http://schemas.microsoft.com/accesscontrolservice/2010/07/claims/identityprovider`
- `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier`

<span data-ttu-id="502b8-210">(이 [ACS doc 페이지](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx) 대 한 자세한 정보.)</span><span class="sxs-lookup"><span data-stu-id="502b8-210">(see this [ACS doc page](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx) for more info.)</span></span>

<span data-ttu-id="502b8-211">를 생성 하거나 유효성을 검사 하는 토큰 ASP.NET 웹 스택 런타임 런타임 시 시도 합니다 형식에 바인딩:</span><span class="sxs-lookup"><span data-stu-id="502b8-211">When generating or validating a token, the ASP.NET Web Stack Runtime will at runtime try binding to the types:</span></span>

- <span data-ttu-id="502b8-212">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (SDK에 대 한는 WIF.)</span><span class="sxs-lookup"><span data-stu-id="502b8-212">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (For the WIF SDK.)</span></span>
- <span data-ttu-id="502b8-213">`System.Security.Claims.ClaimsIdentity` (.NET 4.5) 용.</span><span class="sxs-lookup"><span data-stu-id="502b8-213">`System.Security.Claims.ClaimsIdentity` (For .NET 4.5).</span></span>

<span data-ttu-id="502b8-214">이러한 형식은 존재 한 경우 현재 사용자의 *IIIIdentity* 유형 중 하나 구현 또는 서브 클래스 (id 공급자, 이름 식별자) ANTI-XSRF 시설 사용, 생성 하는 경우 사용자 이름 대신 튜플 및 토큰의 유효성 검사.</span><span class="sxs-lookup"><span data-stu-id="502b8-214">If these types exist, and if the current user's *IIIIdentity* implements or subclasses one of these types, the anti-XSRF facility will use the (identity provider, name identifier) tuple in place of the username when generating and validating the tokens.</span></span> <span data-ttu-id="502b8-215">이러한 튜플이 있는 경우 사용 중인 특정 클레임 기반 인증 메커니즘을 이해 하려면 ANTI-XSRF 시스템을 구성 하는 방법을 개발자에 게 설명 하는 오류와 함께 요청이 실패 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-215">If no such tuple is present, the request will fail with an error describing to the developer how to configure the anti-XSRF system to understand the particular claims-based authentication mechanism in use.</span></span> <span data-ttu-id="502b8-216">참조는 **[구성 및 확장성](#_Configuration_and_extensibility)** 한 자세 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-216">See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.</span></span>

### <a name="oauth--openid-authentication"></a><span data-ttu-id="502b8-217">OAuth / OpenID 인증</span><span class="sxs-lookup"><span data-stu-id="502b8-217">OAuth / OpenID authentication</span></span>

<span data-ttu-id="502b8-218">마지막으로, ANTI-XSRF 시설에 OAuth 또는 OpenID 인증을 사용 하는 응용 프로그램에 대 한 특별 한 지원이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-218">Finally, the anti-XSRF facility has special support for applications which use OAuth or OpenID authentication.</span></span> <span data-ttu-id="502b8-219">이 지원은 추론 기반: 경우 현재 *IIdentity.Name* 다음 사용자 이름 비교를 수행할 수는 http:// 또는 https://로 시작 기본 OrdinalIgnoreCase 비교자 보다는 서 수는 비교자를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-219">This support is heuristic-based: if the current *IIdentity.Name* begins with http:// or https://, then username comparisons will be done using an Ordinal comparer rather than the default OrdinalIgnoreCase comparer.</span></span>

<a id="_Configuration_and_extensibility"></a>

## <a name="configuration-and-extensibility"></a><span data-ttu-id="502b8-220">구성 및 확장성</span><span class="sxs-lookup"><span data-stu-id="502b8-220">Configuration and extensibility</span></span>

<span data-ttu-id="502b8-221">경우에 따라 개발자 ANTI-XSRF 생성 및 유효성 검사 동작 더 엄격한 제어를 원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-221">Occasionally, developers may want tighter control over the anti-XSRF generation and validation behaviors.</span></span> <span data-ttu-id="502b8-222">예를 들어 웹 페이지 및 MVC 도우미 기본 동작은 자동으로 응답에 HTTP 쿠키를 추가 하는 것이 좋은 경우 아마도 및 개발자는 토큰을 다른 위치를 유지 하려는 경우가 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-222">For example, perhaps the MVC and Web Pages helpers' default behavior of automatically adding HTTP cookies to the response is undesirable, and the developer may wish to persist the tokens elsewhere.</span></span> <span data-ttu-id="502b8-223">이 지원 하기 위해 두 개의 Api 존재 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-223">There exist two APIs to assist with this:</span></span>

`AntiForgery.GetTokens(string oldCookieToken, out string newCookieToken, out string formToken);`  
`AntiForgery.Validate(string cookieToken, string formToken);`

<span data-ttu-id="502b8-224">*GetTokens* 는 기존 XSRF 요청 확인 세션 토큰 (null 일 수 있음)을 입력 하는 메서드 사용으로 및 새 XSRF 요청 확인 세션 토큰 및 필드 토큰이 생성으로 출력 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-224">The *GetTokens* method takes as input an existing XSRF request verification session token (which may be null) and produces as output a new XSRF request verification session token and field token.</span></span> <span data-ttu-id="502b8-225">토큰은; 장식이 없는 단순히 불투명 문자열 *formToken* 값 예를 들어 바꿈되지에 &lt;입력&gt; 태그입니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-225">The tokens are simply opaque strings with no decoration; the *formToken* value will for instance not be wrapped in an &lt;input&gt; tag.</span></span> <span data-ttu-id="502b8-226">*newCookieToken* 값 null 일 수 있습니다;이 문제가 발생 하면 *oldCookieToken* 값이 유효한 지 그리고 없는 새 응답 쿠키를 설정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-226">The *newCookieToken* value may be null; if this occurs, then the *oldCookieToken* value is still valid and no new response cookie need be set.</span></span> <span data-ttu-id="502b8-227">호출자 *GetTokens* 은 모든 필요한 응답 쿠키를 유지 하거나 필요한 모든 태그; 생성는 *GetTokens* 메서드 자체 응답 부작용으로 영향을 주지 것입니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-227">The caller of *GetTokens* is responsible for persisting any necessary response cookies or generating any necessary markup; the *GetTokens* method itself will not alter the response as a side effect.</span></span> <span data-ttu-id="502b8-228">*유효성 검사* 메서드는 들어오는 세션을 사용 하 고 필드 토큰에 대해 앞에서 언급 한 유효성 검사 논리를 실행 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-228">The *Validate* method takes the incoming session and field tokens and runs the aforementioned validation logic over them.</span></span>

### <a name="antiforgeryconfig"></a><span data-ttu-id="502b8-229">AntiForgeryConfig</span><span class="sxs-lookup"><span data-stu-id="502b8-229">AntiForgeryConfig</span></span>

<span data-ttu-id="502b8-230">개발자는 응용 프로그램에서 ANTI-XSRF 시스템을 구성할 수 있습니다\_시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-230">The developer may configure the anti-XSRF system from Application\_Start.</span></span> <span data-ttu-id="502b8-231">구성은은 프로그래밍 방식입니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-231">Configuration is programmatic.</span></span> <span data-ttu-id="502b8-232">정적 속성 *AntiForgeryConfig* 종류는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-232">The properties of the static *AntiForgeryConfig* type are described below.</span></span> <span data-ttu-id="502b8-233">대부분의 사용자 클레임을 사용 하 여 UniqueClaimTypeIdentifier 속성을 설정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-233">Most users using claims will want to set the UniqueClaimTypeIdentifier property.</span></span>

| <span data-ttu-id="502b8-234">**Property**</span><span class="sxs-lookup"><span data-stu-id="502b8-234">**Property**</span></span> | <span data-ttu-id="502b8-235">**설명**</span><span class="sxs-lookup"><span data-stu-id="502b8-235">**Description**</span></span> |
| --- | --- |
| <span data-ttu-id="502b8-236">**AdditionalDataProvider**</span><span class="sxs-lookup"><span data-stu-id="502b8-236">**AdditionalDataProvider**</span></span> | <span data-ttu-id="502b8-237">[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) 토큰 생성 하는 동안 추가 데이터를 제공 하 고 토큰 유효성 검사 중 추가 데이터를 많이 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-237">An [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) that provides additional data during token generation and consumes additional data during token validation.</span></span> <span data-ttu-id="502b8-238">기본값은 *null*합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-238">The default value is *null*.</span></span> <span data-ttu-id="502b8-239">자세한 내용은 참조는 [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) 섹션.</span><span class="sxs-lookup"><span data-stu-id="502b8-239">For more information, see the [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) section.</span></span> |
| <span data-ttu-id="502b8-240">**CookieName**</span><span class="sxs-lookup"><span data-stu-id="502b8-240">**CookieName**</span></span> | <span data-ttu-id="502b8-241">ANTI-XSRF 세션 토큰을 저장 하는 데 사용 되는 HTTP 쿠키의 이름을 지정 하는 문자열입니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-241">A string that provides the name of the HTTP cookie that is used to store the anti-XSRF session token.</span></span> <span data-ttu-id="502b8-242">이 값을 설정 하지 않으면 경우 응용 프로그램의 배포 된 가상 경로에 따라 이름이 자동으로 생성 됩니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-242">If this value is not set, a name will be automatically generated based on the application's deployed virtual path.</span></span> <span data-ttu-id="502b8-243">기본값은 *null*합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-243">The default value is *null*.</span></span> |
| <span data-ttu-id="502b8-244">**RequireSsl**</span><span class="sxs-lookup"><span data-stu-id="502b8-244">**RequireSsl**</span></span> | <span data-ttu-id="502b8-245">ANTI-XSRF 토큰 SSL 보안 채널을 통해 전송 될 필요한 지 여부를 결정 하는 부울입니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-245">A Boolean that dictates whether the anti-XSRF tokens are required to be submitted over an SSL-secured channel.</span></span> <span data-ttu-id="502b8-246">이 값이 *true*이 고, 자동으로 생성 된 쿠키는 "secure" 플래그를 설정 하 고, 고 ANTI-XSRF Api는 SSL을 통해 전송 되지 않습니다는 요청 내에서 호출 된 경우 throw 됩니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-246">If this value is *true*, any automatically-generated cookies will have the "secure" flag set, and the anti-XSRF APIs will throw if called from within a request that is not submitted via SSL.</span></span> <span data-ttu-id="502b8-247">기본값은 *false*입니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-247">The default value is *false*.</span></span> |
| <span data-ttu-id="502b8-248">**SuppressIdentityHeuristicChecks**</span><span class="sxs-lookup"><span data-stu-id="502b8-248">**SuppressIdentityHeuristicChecks**</span></span> | <span data-ttu-id="502b8-249">ANTI-XSRF 시스템 클레임 기반 id에 대 한 지원을 비활성화 해야 하는지 여부를 결정 하는 부울입니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-249">A Boolean that dictates whether the anti-XSRF system should deactivate its support for claims-based identities.</span></span> <span data-ttu-id="502b8-250">이 값이 *true*, 시스템이 있다고 가정 합니다 *IIdentity.Name* 고유한 사용자 식별자로 사용 하기에 적합 하 고는 특별 한 경우 하려고 *IClaimsIdentity*또는 *ClClaimsIdentity* 에 설명 된 대로 [WIF / ACS / 클레임 기반 인증](#_WIF_ACS) 섹션.</span><span class="sxs-lookup"><span data-stu-id="502b8-250">If this value is *true*, the system will assume that *IIdentity.Name* is appropriate for use as a unique per-user identifier and will not try to special-case *IClaimsIdentity* or *ClClaimsIdentity* as described in the [WIF / ACS / claims-based authentication](#_WIF_ACS) section.</span></span> <span data-ttu-id="502b8-251">기본값은 `false`입니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-251">The default value is `false`.</span></span> |
| <span data-ttu-id="502b8-252">**UniqueClaimTypeIdentifier**</span><span class="sxs-lookup"><span data-stu-id="502b8-252">**UniqueClaimTypeIdentifier**</span></span> | <span data-ttu-id="502b8-253">클레임 유형 나타내는 문자열은 고유한 사용자 식별자로 사용 하기에 적합 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-253">A string that indicates which claim type is appropriate for use as a unique per-user identifier.</span></span> <span data-ttu-id="502b8-254">이 값이 설정 및 현재 *IIdentity* 하 여 지정 된 클레임 기반, 시스템이 형식의 클레임을 추출 하는 *UniqueClaimTypeIdentifier*, 해당 값이 사용 됩니다 대신 사용자의 사용자 이름 필드 토큰을 생성 하는 경우입니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-254">If this value is set and the current *IIdentity* is claims-based, the system will attempt to extract a claim of the type specified by *UniqueClaimTypeIdentifier*, and the corresponding value will be used in place of the user's username when generating the field token.</span></span> <span data-ttu-id="502b8-255">클레임 유형이 없는 경우 시스템은 요청을 거부 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-255">If the claim type is not found, the system will fail the request.</span></span> <span data-ttu-id="502b8-256">기본값은 *null*, 시스템 (id 공급자, 이름 식별자)을 사용 해야 함을 나타내는 튜플 앞에서 설명한 대로 사용자의 사용자 이름 대신 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-256">The default value is *null*, which indicates that the system should use the (identity provider, name identifier) tuple as previously described in place of the user's username.</span></span> |

<a id="_IAntiForgeryAdditionalDataProvider"></a>

### <a name="iantiforgeryadditionaldataprovider"></a><span data-ttu-id="502b8-257">IAntiForgeryAdditionalDataProvider</span><span class="sxs-lookup"><span data-stu-id="502b8-257">IAntiForgeryAdditionalDataProvider</span></span>

<span data-ttu-id="502b8-258">*[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* 형식에서는 개발자가 각 토큰의 추가 데이터를 왕복 하 여 ANTI-XSRF 시스템의 동작을 확장할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-258">The *[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* type allows developers to extend the behavior of the anti-XSRF system by round-tripping additional data in each token.</span></span> <span data-ttu-id="502b8-259">*GetAdditionalData* 될 때마다 메서드는 필드 토큰이 생성 되 고 반환 값은 생성 되는 토큰 내에 포함 되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-259">The *GetAdditionalData* method is called each time a field token is generated, and the return value is embedded within the generated token.</span></span> <span data-ttu-id="502b8-260">구현 자가이 메서드에서 타임 스탬프, nonce, 또는 그녀 하지 않고자 한다면 다른 모든 값을 반환할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-260">An implementer could return a timestamp, a nonce, or any other value she wishes from this method.</span></span>

<span data-ttu-id="502b8-261">마찬가지로,는 *ValidateAdditionalData* 될 때마다 메서드는 필드 토큰의 유효성을 검사 하 고 토큰 내에 포함 된 "데이터 추가" 문자열 메서드에 전달 됩니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-261">Similarly, the *ValidateAdditionalData* method is called each time a field token is validated, and the "additional data" string that was embedded within the token is passed to the method.</span></span> <span data-ttu-id="502b8-262">루틴 또는 기타 검사 nonce 원하는 논리, 유효성 검사 루틴 (토큰을 만들 때 저장 된 시간에 대해 현재 시간을 확인 하는 중)에서 시간 초과 구현할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-262">The validation routine could implement a timeout (by checking the current time against the time that was stored when the token was created), a nonce checking routine, or any other desired logic.</span></span>

## <a name="design-decisions-and-security-considerations"></a><span data-ttu-id="502b8-263">디자인 결정 사항 및 보안 고려 사항</span><span class="sxs-lookup"><span data-stu-id="502b8-263">Design decisions and security considerations</span></span>

<span data-ttu-id="502b8-264">세션 및 필드 토큰을 연결 하는 보안 토큰은 기술적으로 필요한 경우에 XSRF 공격에 대 한 익명 / 인증 되지 않은 사용자가 보호 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-264">The security token that links the session and field tokens is technically only necessary when trying to protect anonymous / unauthenticated users against XSRF attacks.</span></span> <span data-ttu-id="502b8-265">하나로 (아마도 쿠키의 형태로 제출) 자체 인증 토큰을 사용할 수는 사용자가 인증 될 때 동기화 프로그램의 절반 토큰 쌍입니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-265">When the user is authenticated, the authentication token itself (presumably submitted in the form of a cookie) could be used as one half of a synchronizer token pair.</span></span> <span data-ttu-id="502b8-266">그러나 인증 되지 않은 사용자가 로그인 페이지를 보호 하는 데 유효한 시나리오가 있습니다 않으며 ANTI-XSRF 논리 항상 생성 하 고 인증 된 사용자에 대해서도 보안 토큰을 확인 하 여 간단한 만들어졌습니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-266">However, there are valid scenarios for protecting login pages hit by unauthenticated users, and the anti-XSRF logic was made simpler by always generating and validating the security token, even for authenticated users.</span></span> <span data-ttu-id="502b8-267">또한 필드 토큰이 설정 또는 세션 토큰에 해결 하기 위해 공격자에 대 한 다른 장애물 것 추측 공격자가 손상 되는 몇 가지 추가 보호를 제공지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-267">It also does provide some additional protection in the event that a field token is ever compromised by an attacker, as setting or guessing the session token would be another hurdle for the attacker to overcome.</span></span>

<span data-ttu-id="502b8-268">개발자가 여러 응용 프로그램이 단일 도메인에서 호스팅되는 경우 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-268">Developers should use caution when multiple applications are hosted in a single domain.</span></span> <span data-ttu-id="502b8-269">예를 들어 있지만 *example1.cloudapp.net* 및 *example2.cloudapp.net* 는 서로 다른 호스트의 모든 호스트 간의 암시적 트러스트 관계가 있는  *\*. cloudapp.net에* 도메인입니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-269">For example, even though *example1.cloudapp.net* and *example2.cloudapp.net* are different hosts, there is an implicit trust relationship between all hosts under the *\*.cloudapp.net* domain.</span></span> <span data-ttu-id="502b8-270">이 암시적 신뢰 관계가 [통해 다른 사용자의 쿠키에 영향을 신뢰할 수 없는 호스트](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) (AJAX 요청을 제어 하는 동일 원본 정책 반드시에 적용 되지 않습니다 HTTP 쿠키).</span><span class="sxs-lookup"><span data-stu-id="502b8-270">This implicit trust relationship [allows potentially untrusted hosts to affect each other's cookies](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) (the same-origin policies that govern AJAX requests do not necessarily apply to HTTP cookies).</span></span> <span data-ttu-id="502b8-271">사용자 이름 필드 토큰에 포함 되어 있으므로 악의적인 하위 도메인은 세션 토큰을 덮어쓸 수 있는 경우에 됩니다 하지 사용자에 대 한 유효한 필드 토큰을 생성할 수 있다는 점에서 ASP.NET 웹 스택 런타임 몇 가지 완화를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-271">The ASP.NET Web Stack Runtime provides some mitigation in that the username is embedded into the field token, so even if a malicious subdomain is able to overwrite a session token it will be unable to generate a valid field token for the user.</span></span> <span data-ttu-id="502b8-272">그러나 이러한 환경에서 호스팅되는 경우 기본 제공 ANTI-XSRF 루틴 여전히 없습니다 방어 세션 하이재킹 또는 XSRF 로그인 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-272">However, when hosted in such an environment the built-in anti-XSRF routines still cannot defend against session hijacking or login XSRF.</span></span>

<span data-ttu-id="502b8-273">ANTI-XSRF 루틴 현재 로부터 보호 되지 않는 [clickjacking](https://www.owasp.org/index.php/Clickjacking)합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-273">The anti-XSRF routines currently do not defend against [clickjacking](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="502b8-274">Clickjacking 으로부터 자신을 방어 하는 응용 프로그램 수 쉽게 수행할 보내기는 X 프레임 옵션: SAMEORIGIN 헤더는 각 응답 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-274">Applications that wish to defend themselves against clickjacking may easily do so by sending an X-Frame-Options: SAMEORIGIN header with each response.</span></span> <span data-ttu-id="502b8-275">이 헤더는 모든 최신 브라우저에서 지원 됩니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-275">This header is supported by all recent browsers.</span></span> <span data-ttu-id="502b8-276">자세한 내용은 참조는 [IE 블로그](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx), [SDL 블로그](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx), 및 [OWASP](https://www.owasp.org/index.php/Clickjacking)합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-276">For more information, see the [IE blog](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx), the [SDL blog](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx), and [OWASP](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="502b8-277">이 공격 으로부터 응용 프로그램은 자동으로 보호 되도록 자동으로이 헤더를 설정할 웹 페이지 ANTI-XSRF 도우미 및 ASP.NET 웹 스택 런타임 일부 향후 릴리스에서 make MVC 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-277">The ASP.NET Web Stack Runtime may in some future release make the MVC and Web Pages anti-XSRF helpers automatically set this header so that applications are automatically protected against this attack.</span></span>

<span data-ttu-id="502b8-278">웹 개발자는 자신의 사이트 XSS 공격에 노출 되지 않도록 하려면 계속 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-278">Web developers should continue to ensure that their site is not vulnerable to XSS attacks.</span></span> <span data-ttu-id="502b8-279">XSS 공격은 매우 강력 하 고 성공적으로 악용은 XSRF 공격에 대 한 ASP.NET 웹 스택 런타임을 방어 페이지 나누기입니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-279">XSS attacks are very powerful, and a successful exploit would also break the ASP.NET Web Stack Runtime defenses against XSRF attacks.</span></span>

## <a name="acknowledgment"></a><span data-ttu-id="502b8-280">승인</span><span class="sxs-lookup"><span data-stu-id="502b8-280">Acknowledgment</span></span>

<span data-ttu-id="502b8-281">[@LeviBroderick](https://twitter.com/LeviBroderick)누가 작성 ASP.NET 보안 코드의 대부분이 정보의 대부분 합니다.</span><span class="sxs-lookup"><span data-stu-id="502b8-281">[@LeviBroderick](https://twitter.com/LeviBroderick), who wrote much of the ASP.NET security code the bulk of this information.</span></span>
